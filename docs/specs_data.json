{
    "spec_functions": [
        {
            "id": "lemmas__common_lemmas__number_theory_lemmas__spec_extended_gcd",
            "name": "spec_extended_gcd",
            "signature": "pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult decreases b,",
            "body": "pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult\n    decreases b,\n{\n    if b == 0 {\n        ExtGcdResult { gcd: a, x: 1, y: 0 }\n    } else {\n        let r = spec_extended_gcd(b, a % b);\n        ExtGcdResult { gcd: r.gcd, x: r.y, y: r.x - (a / b) as int * r.y }\n    }\n}",
            "file": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
            "line": 908,
            "module": "lemmas::common_lemmas::number_theory_lemmas",
            "short_module": "lemmas",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: Extended Euclidean Algorithm\n\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\n\nThis is a constructive algorithm that produces the Bezout coefficients.\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\n= a*y' + b*(x' - (a/b)*y')\nso (gcd, y', x' - (a/b)*y')",
            "math_interpretation": "gcd(a,b) = ax + by (Bezout coefficients)",
            "informal_interpretation": "Spec function: Extended Euclidean Algorithm\\n\\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\\n\\nThis is a constructive algorithm that produces the Bezout coefficients.\\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\\n= a*y' + b*(x' - (a/b)*y')\\nso (gcd, y', x' - (a/b)*y')",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L908",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "lemmas__common_lemmas__number_theory_lemmas__spec_gcd",
            "name": "spec_gcd",
            "signature": "pub open spec fn spec_gcd(a: nat, b: nat) -> nat decreases b,",
            "body": "pub open spec fn spec_gcd(a: nat, b: nat) -> nat\n    decreases b,\n{\n    if b == 0 {\n        a\n    } else {\n        spec_gcd(b, a % b)\n    }\n}",
            "file": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
            "line": 27,
            "module": "lemmas::common_lemmas::number_theory_lemmas",
            "short_module": "lemmas",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: Greatest Common Divisor using Euclidean algorithm\n\nThis is a constructive definition that computes gcd(a, b) recursively.\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0",
            "math_interpretation": "gcd(a, b) via Euclidean algorithm",
            "informal_interpretation": "Spec function: Greatest Common Divisor using Euclidean algorithm\\n\\nThis is a constructive definition that computes gcd(a, b) recursively.\\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L27",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "lemmas__common_lemmas__number_theory_lemmas__spec_mod_inverse",
            "name": "spec_mod_inverse",
            "signature": "pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat recommends m > 1, spec_gcd(a % m, m) == 1,",
            "body": "pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat\n    recommends\n        m > 1,\n        spec_gcd(a % m, m) == 1,\n{\n    if m <= 1 || spec_gcd(a % m, m) != 1 {\n        0  // Undefined case - return 0 by convention\n\n    } else {\n        let r = spec_extended_gcd(a % m, m);\n        // r.x might be negative, so normalize to [0, m)\n        (((r.x % (m as int)) + (m as int)) % (m as int)) as nat\n    }\n}",
            "file": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
            "line": 980,
            "module": "lemmas::common_lemmas::number_theory_lemmas",
            "short_module": "lemmas",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: Compute modular inverse using extended Euclidean algorithm\n\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\na * x ≡ 1 (mod m).\n\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\nTaking mod m: (a*x) % m = 1\n\nWe normalize the result to be in [0, m) by computing x % m (handling negative x).",
            "math_interpretation": "a^(-1) mod m, via extended GCD",
            "informal_interpretation": "Spec function: Compute modular inverse using extended Euclidean algorithm\\n\\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\\na * x ≡ 1 (mod m).\\n\\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\\nTaking mod m: (a*x) % m = 1\\n\\nWe normalize the result to be in [0, m) by computing x % m (handling negative x).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L980",
            "category": "spec",
            "referenced_specs": [
                "spec_extended_gcd",
                "spec_gcd"
            ]
        },
        {
            "id": "specs__core_specs__u8_32_as_nat",
            "name": "u8_32_as_nat",
            "signature": "pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat",
            "body": "pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat {\n    (bytes[ 0] as nat) * pow2( 0 * 8) +\n    (bytes[ 1] as nat) * pow2( 1 * 8) +\n    (bytes[ 2] as nat) * pow2( 2 * 8) +\n    (bytes[ 3] as nat) * pow2( 3 * 8) +\n    (bytes[ 4] as nat) * pow2( 4 * 8) +\n    (bytes[ 5] as nat) * pow2( 5 * 8) +\n    (bytes[ 6] as nat) * pow2( 6 * 8) +\n    (bytes[ 7] as nat) * pow2( 7 * 8) +\n    (bytes[ 8] as nat) * pow2( 8 * 8) +\n    (bytes[ 9] as nat) * pow2( 9 * 8) +\n    (bytes[10] as nat) * pow2(10 * 8) +\n    (bytes[11] as nat) * pow2(11 * 8) +\n    (bytes[12] as nat) * pow2(12 * 8) +\n    (bytes[13] as nat) * pow2(13 * 8) +\n    (bytes[14] as nat) * pow2(14 * 8) +\n    (bytes[15] as nat) * pow2(15 * 8) +\n    (bytes[16] as nat) * pow2(16 * 8) +\n    (bytes[17] as nat) * pow2(17 * 8) +\n    (bytes[18] as nat) * pow2(18 * 8) +\n    (bytes[19] as nat) * pow2(19 * 8) +\n    (bytes[20] as nat) * pow2(20 * 8) +\n    (bytes[21] as nat) * pow2(21 * 8) +\n    (bytes[22] as nat) * pow2(22 * 8) +\n    (bytes[23] as nat) * pow2(23 * 8) +\n    (bytes[24] as nat) * pow2(24 * 8) +\n    (bytes[25] as nat) * pow2(25 * 8) +\n    (bytes[26] as nat) * pow2(26 * 8) +\n    (bytes[27] as nat) * pow2(27 * 8) +\n    (bytes[28] as nat) * pow2(28 * 8) +\n    (bytes[29] as nat) * pow2(29 * 8) +\n    (bytes[30] as nat) * pow2(30 * 8) +\n    (bytes[31] as nat) * pow2(31 * 8)\n}",
            "file": "curve25519-dalek/src/specs/core_specs.rs",
            "line": 20,
            "module": "specs::core_specs",
            "short_module": "core",
            "visibility": "pub open spec fn",
            "doc_comment": "Convert a 32-byte array to its natural number representation (little-endian).\n\nThis function interprets a byte array as a 256-bit little-endian integer:\nbytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ... + bytes[31] * 2^248\n\nIMPORTANT: This explicit 32-term form is kept for SMT solver efficiency.\nFor generic arrays, use `bytes_seq_as_nat(bytes@)` directly.",
            "math_interpretation": "sum_i b[i] * 2^(8i), little-endian 256-bit",
            "informal_interpretation": "Interprets a 32-byte little-endian array as a natural number.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L20",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__core_specs__bytes_seq_as_nat",
            "name": "bytes_seq_as_nat",
            "signature": "pub open spec fn bytes_seq_as_nat(bytes: Seq<u8>) -> nat decreases bytes.len(),",
            "body": "pub open spec fn bytes_seq_as_nat(bytes: Seq<u8>) -> nat\n    decreases bytes.len(),\n{\n    if bytes.len() == 0 {\n        0\n    } else {\n        (bytes[0] as nat) + pow2(8) * bytes_seq_as_nat(bytes.skip(1))\n    }\n}",
            "file": "curve25519-dalek/src/specs/core_specs.rs",
            "line": 118,
            "module": "specs::core_specs",
            "short_module": "core",
            "visibility": "pub open spec fn",
            "doc_comment": "Little-endian natural value of an arbitrary-length byte sequence.\nComputes: bytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ...",
            "math_interpretation": "sum_i b[i] * 2^(8i), variable-length",
            "informal_interpretation": "Interprets a sequence of bytes as a natural number in little-endian order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L118",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__edwards_specs__compressed_edwards_y_corresponds_to_edwards",
            "name": "compressed_edwards_y_corresponds_to_edwards",
            "signature": "pub open spec fn compressed_edwards_y_corresponds_to_edwards( compressed: CompressedEdwardsY, point: EdwardsPoint, ) -> bool",
            "body": "pub open spec fn compressed_edwards_y_corresponds_to_edwards(\n    compressed: CompressedEdwardsY,\n    point: EdwardsPoint,\n) -> bool {\n    let (x_affine, y_affine) = edwards_point_as_affine(point);\n    // The y-coordinate in the compressed form matches the affine y-coordinate\n    field_element_from_bytes(&compressed.0)\n        == y_affine\n    // The sign bit matches the sign of the affine x-coordinate\n     && (compressed.0[31] >> 7) == (((x_affine % crate::specs::field_specs_u64::p()) % 2) as u8)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 480,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: check if a CompressedEdwardsY corresponds to an EdwardsPoint\nThe compressed form should match the affine y-coordinate and x sign bit",
            "math_interpretation": "Compressed(y,sign) matches (X:Y:Z:T) in E(F_p)",
            "informal_interpretation": "Relates a `CompressedEdwardsY` encoding to an `EdwardsPoint` (y-coordinate matches; sign bit matches x).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L480",
            "category": "spec",
            "referenced_specs": [
                "edwards_point_as_affine",
                "p",
                "field_element_from_bytes"
            ]
        },
        {
            "id": "specs__edwards_specs__compressed_y_has_valid_sign_bit",
            "name": "compressed_y_has_valid_sign_bit",
            "signature": "pub open spec fn compressed_y_has_valid_sign_bit(bytes: &[u8; 32]) -> bool",
            "body": "pub open spec fn compressed_y_has_valid_sign_bit(bytes: &[u8; 32]) -> bool {\n    let y = field_element_from_bytes(bytes);\n    let sign_bit = bytes[31] >> 7;\n    // If y² ≡ 1 (mod p), then x = 0, so sign_bit must be 0\n    // Equivalently: sign_bit == 1 implies y² ≢ 1\n    field_square(y) == 1 ==> sign_bit == 0\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 503,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Check if a CompressedEdwardsY has a valid sign bit.\n\n## Mathematical basis\n\nFor points with x = 0 on the Edwards curve, the curve equation gives y² = 1,\nso y = ±1. These special points (the identity (0,1) and the point (0,-1))\nhave only one valid sign bit: 0, since sign_bit = x % 2 = 0.\n\n## Definition\n\nIf the Y coordinate yields x = 0 (i.e., y² ≡ 1 mod p), the sign bit must be 0.",
            "math_interpretation": "y^2 = 1 mod p => sign_bit = 0",
            "informal_interpretation": "Predicate capturing when the sign bit in a compressed Edwards-Y encoding is valid for decoding.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L503",
            "category": "spec",
            "referenced_specs": [
                "field_square",
                "p",
                "field_element_from_bytes"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_add",
            "name": "edwards_add",
            "signature": "pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat)",
            "body": "pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n    let x1x2 = field_mul(x1, x2);\n    let y1y2 = field_mul(y1, y2);\n    let x1y2 = field_mul(x1, y2);\n    let y1x2 = field_mul(y1, x2);\n    let t = field_mul(d, field_mul(x1x2, y1y2));\n    let denom_x = field_add(1, t);\n    let denom_y = field_sub(1, t);\n    let x3 = field_mul(field_add(x1y2, y1x2), field_inv(denom_x));\n    let y3 = field_mul(field_add(y1y2, x1x2), field_inv(denom_y));\n    (x3, y3)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 706,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Affine Edwards addition for a = -1 twisted Edwards curves (Ed25519).\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) + (x2,y2).\nFormulas:\nx3 = (x1*y2 + y1*x2) / (1 + d*x1*x2*y1*y2)\ny3 = (y1*y2 + x1*x2) / (1 - d*x1*x2*y1*y2)\n\nThese are the unified addition formulas for twisted Edwards curves with a = -1.\nReference: [BBJLP2008] Section 3.1, [RFC8032] Section 5.1.4",
            "math_interpretation": "(x1,y1) + (x2,y2) on -x^2+y^2=1+dx^2y^2",
            "informal_interpretation": "Adds two affine Edwards points (group law).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L706",
            "category": "spec",
            "referenced_specs": [
                "field_add",
                "field_inv",
                "field_mul",
                "field_sub",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_double",
            "name": "edwards_double",
            "signature": "pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat)",
            "body": "pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat) {\n    edwards_add(x, y, x, y)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 721,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Affine Edwards doubling defined as addition with itself.",
            "math_interpretation": "2P = P + P on twisted Edwards",
            "informal_interpretation": "Affine Edwards doubling defined as addition with itself.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L721",
            "category": "spec",
            "referenced_specs": [
                "edwards_add"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_neg",
            "name": "edwards_neg",
            "signature": "pub open spec fn edwards_neg(point: (nat, nat)) -> (nat, nat)",
            "body": "pub open spec fn edwards_neg(point: (nat, nat)) -> (nat, nat) {\n    (field_neg(point.0), point.1)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 749,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Affine Edwards negation for twisted Edwards curves with a=-1.\nThe negation of point (x, y) is (-x, y).",
            "math_interpretation": "(x,y) -> (-x,y) on twisted Edwards",
            "informal_interpretation": "Negates an affine Edwards point (group inverse).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L749",
            "category": "spec",
            "referenced_specs": [
                "field_neg"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_point_as_affine",
            "name": "edwards_point_as_affine",
            "signature": "pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat)",
            "body": "pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let (x, y, z, _t) = spec_edwards_point(point);\n    let z_inv = field_inv(z);\n    (field_mul(x, z_inv), field_mul(y, z_inv))\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 394,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns the abstract affine coordinates (x, y) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) represents affine point (X/Z, Y/Z).",
            "math_interpretation": "(X:Y:Z:T) -> (X/Z, Y/Z) in F_p x F_p",
            "informal_interpretation": "Converts an extended/projective Edwards point representation to affine coordinates.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L394",
            "category": "spec",
            "referenced_specs": [
                "field_inv",
                "field_mul",
                "spec_edwards_point"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_point_limbs_bounded",
            "name": "edwards_point_limbs_bounded",
            "signature": "pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool",
            "body": "pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool {\n    fe51_limbs_bounded(&point.X, 52) && fe51_limbs_bounded(&point.Y, 52) && fe51_limbs_bounded(\n        &point.Z,\n        52,\n    ) && fe51_limbs_bounded(&point.T, 52)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 366,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "EdwardsPoint invariant: all coordinate limbs must be 52-bounded.",
            "math_interpretation": "all limbs of (X,Y,Z,T) < 2^52",
            "informal_interpretation": "EdwardsPoint invariant: all coordinate limbs must be 52-bounded.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L366",
            "category": "spec",
            "referenced_specs": [
                "fe51_limbs_bounded"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_scalar_mul",
            "name": "edwards_scalar_mul",
            "signature": "pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat) decreases n,",
            "body": "pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat)\n    decreases n,\n{\n    if n == 0 {\n        math_edwards_identity()  // (0, 1)\n\n    } else if n == 1 {\n        point_affine\n    } else if n % 2 == 0 {\n        let half = edwards_scalar_mul(point_affine, (n / 2) as nat);\n        edwards_double(half.0, half.1)\n    } else {\n        let prev = edwards_scalar_mul(point_affine, (n - 1) as nat);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 831,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Scalar multiplication on Edwards curve points (affine coordinates).\n\nUses double-and-add instead of linear recursion to closer match the implementation of mul_by_pow_2\n\n- **Linear**: `n*P = (n-1)*P + P` — reveal gives `add(scalar_mul(P, n-1), P)`\n- **Double-and-add**: even n → `double(scalar_mul(P, n/2))`",
            "math_interpretation": "[n]P via double-and-add on E(F_p)",
            "informal_interpretation": "Computes scalar multiplication of an affine Edwards point by a natural number.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L831",
            "category": "spec",
            "referenced_specs": [
                "edwards_add",
                "edwards_double",
                "math_edwards_identity"
            ]
        },
        {
            "id": "specs__edwards_specs__edwards_sub",
            "name": "edwards_sub",
            "signature": "pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat)",
            "body": "pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    edwards_add(x1, y1, field_neg(x2), y2)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 757,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Affine Edwards subtraction for twisted Edwards curves.\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) - (x2,y2).\nSubtraction is defined as addition with the negation of the second point.\nFor twisted Edwards curves, the negation of (x, y) is (-x, y).",
            "math_interpretation": "(x1,y1) - (x2,y2) = (x1,y1) + (-x2,y2)",
            "informal_interpretation": "Subtracts two affine Edwards points.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L757",
            "category": "spec",
            "referenced_specs": [
                "edwards_add",
                "field_neg"
            ]
        },
        {
            "id": "specs__edwards_specs__is_identity_edwards_point",
            "name": "is_identity_edwards_point",
            "signature": "pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool",
            "body": "pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n\n    z != 0 && x == 0 && y == z\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 324,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Check if an EdwardsPoint represents the identity point\nThe identity point is (0, 1) in affine coordinates\nIn projective coordinates (X:Y:Z:T), this means X/Z = 0 and Y/Z = 1\nWhich is equivalent to X ≡ 0 (mod p) and Y ≡ Z (mod p) with Z ≠ 0",
            "math_interpretation": "X = 0, Y = Z, Z != 0 (projective identity)",
            "informal_interpretation": "Checks whether an Edwards point is the identity (neutral element).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L324",
            "category": "spec",
            "referenced_specs": [
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__is_valid_edwards_point",
            "name": "is_valid_edwards_point",
            "signature": "pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool",
            "body": "pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n    let t = fe51_as_canonical_nat(&point.T);\n\n    math_is_valid_extended_edwards_point(x, y, z, t)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 356,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Check if an EdwardsPoint in extended coordinates is valid\nAn EdwardsPoint (X:Y:Z:T) is valid if:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T\n\nExtended coordinates (X:Y:Z:T) with X·Y = Z·T enable faster point arithmetic.\nReference: [HWCD2008] Section 3 for extended twisted Edwards coordinates",
            "math_interpretation": "(X:Y:Z:T) satisfies curve eq + XY = ZT",
            "informal_interpretation": "Checks that an Edwards point satisfies the curve equation (mathematically valid).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L356",
            "category": "spec",
            "referenced_specs": [
                "math_is_valid_extended_edwards_point",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__is_well_formed_edwards_point",
            "name": "is_well_formed_edwards_point",
            "signature": "pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool",
            "body": "pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    is_valid_edwards_point(point) && edwards_point_limbs_bounded(point) && sum_of_limbs_bounded(\n        &point.Y,\n        &point.X,\n        u64::MAX,\n    )\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 374,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "A well-formed EdwardsPoint: mathematically valid and properly bounded.",
            "math_interpretation": "valid on curve + limbs bounded",
            "informal_interpretation": "Stronger validity predicate: point is valid and its internal representation satisfies required bounds.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L374",
            "category": "spec",
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "sum_of_limbs_bounded"
            ]
        },
        {
            "id": "specs__edwards_specs__math_edwards_identity",
            "name": "math_edwards_identity",
            "signature": "pub open spec fn math_edwards_identity() -> (nat, nat)",
            "body": "pub open spec fn math_edwards_identity() -> (nat, nat) {\n    (0, 1)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 311,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "The identity point in affine coordinates (0, 1)",
            "math_interpretation": "O = (0, 1) in affine coordinates",
            "informal_interpretation": "The affine identity point of the Edwards group.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L311",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__edwards_specs__math_is_valid_extended_edwards_point",
            "name": "math_is_valid_extended_edwards_point",
            "signature": "pub open spec fn math_is_valid_extended_edwards_point(x: nat, y: nat, z: nat, t: nat) -> bool",
            "body": "pub open spec fn math_is_valid_extended_edwards_point(x: nat, y: nat, z: nat, t: nat) -> bool {\n    z != 0 && math_on_edwards_curve_projective(x, y, z) && field_mul(x, y) == field_mul(\n        z,\n        t,\n    )\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 341,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\n\nThis is the \"unpacked\" version of `is_valid_edwards_point` that operates directly on the\nmathematical values `(x, y, z, t)` (all reduced mod p via `field_*`).\n\nAn (X:Y:Z:T) tuple is valid iff:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T",
            "math_interpretation": "Z != 0, curve eq holds, XY = ZT",
            "informal_interpretation": "Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\\n\\nThis is the \"unpacked\" version of `is_valid_edwards_point` that operates directly on the\\nmathematical values `(x, y, z, t)` (all reduced mod p via `field_*`).\\n\\nAn (X:Y:Z:T) tuple is valid iff:\\n1. Z ≠ 0\\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\\n3. The Segre relation holds: X·Y = Z·T",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L341",
            "category": "spec",
            "referenced_specs": [
                "field_mul",
                "math_on_edwards_curve_projective"
            ]
        },
        {
            "id": "specs__edwards_specs__math_is_valid_y_coordinate",
            "name": "math_is_valid_y_coordinate",
            "signature": "pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool",
            "body": "pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n    let y2 = field_square(y);\n\n    // Compute u = y² - 1\n    let u = field_sub(y2, 1);\n\n    // Compute v = d·y² + 1\n    let v = field_add(field_mul(d, y2), 1);\n\n    if u % p() == 0 {\n        // If u = 0, then y² = 1, so y = ±1, which gives valid points (x=0, y=±1)\n        true\n    } else if v % p() == 0 {\n        // If v = 0 but u ≠ 0, division by zero case - invalid\n        false\n    } else {\n        // Check if there exists r such that r² * v ≡ ±u (mod p)\n        // This is what sqrt_ratio_i determines\n        exists|r: nat|\n            r < p() && (#[trigger] field_mul(field_square(r), v) == u % p()\n                || #[trigger] field_mul(field_square(r), v) == field_neg(u))\n    }\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 285,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: Check if a y-coordinate corresponds to a valid point on the curve.\nMirrors the sqrt_ratio_i computation from field.rs to determine if u/v is a square.\nFrom the curve equation: x² = (y² - 1) / (d·y² + 1)\nThis computes the same check as sqrt_ratio_i(&u, &v) where:\nu = y² - 1\nv = d·y² + 1\nReturns true if u/v is a square (i.e., x can be recovered)",
            "math_interpretation": "exists x. (x, y) in E(F_p)",
            "informal_interpretation": "Checks whether a field element can be a y-coordinate of some Edwards curve point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L285",
            "category": "spec",
            "referenced_specs": [
                "field_add",
                "field_mul",
                "field_neg",
                "field_square",
                "field_sub",
                "p",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__math_on_edwards_curve_projective",
            "name": "math_on_edwards_curve_projective",
            "signature": "pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool",
            "body": "pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n\n    // Compute X², Y², Z²\n    let x2 = field_square(x);\n    let y2 = field_square(y);\n    let z2 = field_square(z);\n    let z4 = field_square(z2);\n\n    // LHS: (-X² + Y²)·Z² = (Y² - X²)·Z²\n    let lhs = field_mul(field_sub(y2, x2), z2);\n\n    // RHS: Z⁴ + d·X²·Y²\n    let rhs = field_add(z4, field_mul(d, field_mul(x2, y2)));\n\n    lhs == rhs\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 260,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Homogenized Edwards curve equation for projective coordinates\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\nThis is equivalent to the affine equation when Z ≠ 0\n\nReference: [BBJLP2008] Section 3",
            "math_interpretation": "(Y^2 - X^2)Z^2 = Z^4 + dX^2Y^2",
            "informal_interpretation": "Homogenized Edwards curve equation for projective coordinates\\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\\nThis is equivalent to the affine equation when Z ≠ 0\\n\\nReference: [BBJLP2008] Section 3",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L260",
            "category": "spec",
            "referenced_specs": [
                "field_add",
                "field_mul",
                "field_square",
                "field_sub",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__spec_ed25519_basepoint",
            "name": "spec_ed25519_basepoint",
            "signature": "pub open spec fn spec_ed25519_basepoint() -> (nat, nat)",
            "body": "pub open spec fn spec_ed25519_basepoint() -> (nat, nat) {\n    (u64_5_as_nat(ED25519_BASEPOINT_POINT.X.limbs), u64_5_as_nat(ED25519_BASEPOINT_POINT.Y.limbs))\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 75,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "The Ed25519 basepoint B in affine coordinates (x, y).\nThis is the generator point of the prime-order subgroup.\n\nReferences the actual constant ED25519_BASEPOINT_POINT from constants.rs.\nThe y-coordinate is 4/5 mod p (the first 255 bits of the compressed form).\nThe x-coordinate is the positive square root satisfying the curve equation.\n\nReference: [RFC8032] Section 5.1",
            "math_interpretation": "B = (x_B, y_B), Ed25519 generator",
            "informal_interpretation": "Returns the Ed25519 basepoint in affine coordinates (spec-level).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L75",
            "category": "spec",
            "referenced_specs": [
                "u64_5_as_nat"
            ]
        },
        {
            "id": "specs__edwards_specs__spec_edwards_point",
            "name": "spec_edwards_point",
            "signature": "pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat)",
            "body": "pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat) {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n    let t = fe51_as_canonical_nat(&point.T);\n    (x, y, z, t)\n}",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 384,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.",
            "math_interpretation": "(X, Y, Z, T) field values of extended point",
            "informal_interpretation": "Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L384",
            "category": "spec",
            "referenced_specs": [
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__field_specs__fe51_limbs_bounded",
            "name": "fe51_limbs_bounded",
            "signature": "pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool",
            "body": "pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe.limbs[i] < (1u64 << bit_limit)\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 27,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec predicate: all limbs are bounded by a given bit limit",
            "math_interpretation": "forall i in [0..5). limb[i] < 2^b",
            "informal_interpretation": "Checks that a field element’s radix-2^51 limbs are within the given bound.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L27",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__field_specs__field_add",
            "name": "field_add",
            "signature": "pub open spec fn field_add(a: nat, b: nat) -> nat",
            "body": "pub open spec fn field_add(a: nat, b: nat) -> nat {\n    (a + b) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 110,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field addition",
            "math_interpretation": "(a + b) mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field addition",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L110",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__field_inv",
            "name": "field_inv",
            "signature": "pub open spec fn field_inv(a: nat) -> nat",
            "body": "pub open spec fn field_inv(a: nat) -> nat {\n    if a % p() == 0 {\n        0  // Convention: inverse of 0 is defined as 0\n\n    } else {\n        spec_mod_inverse(a, p())\n    }\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 141,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field inversion: returns w such that (a * w) % p == 1\n\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\n\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\nwhich relies on p being prime.",
            "math_interpretation": "a^(-1) mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field inversion: returns w such that (a * w) % p == 1\\n\\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\\n\\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\\nwhich relies on p being prime.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L141",
            "category": "spec",
            "referenced_specs": [
                "p",
                "spec_mod_inverse"
            ]
        },
        {
            "id": "specs__field_specs__field_mul",
            "name": "field_mul",
            "signature": "pub open spec fn field_mul(a: nat, b: nat) -> nat",
            "body": "pub open spec fn field_mul(a: nat, b: nat) -> nat {\n    (a * b) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 120,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field multiplication",
            "math_interpretation": "(a * b) mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field multiplication",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L120",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__field_neg",
            "name": "field_neg",
            "signature": "pub open spec fn field_neg(a: nat) -> nat",
            "body": "pub open spec fn field_neg(a: nat) -> nat {\n    (p() - (a % p())) as nat % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 125,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field negation",
            "math_interpretation": "-a mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field negation",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L125",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__field_square",
            "name": "field_square",
            "signature": "pub open spec fn field_square(a: nat) -> nat",
            "body": "pub open spec fn field_square(a: nat) -> nat {\n    (a * a) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 130,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field squaring",
            "math_interpretation": "a^2 mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field squaring",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L130",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__field_sub",
            "name": "field_sub",
            "signature": "pub open spec fn field_sub(a: nat, b: nat) -> nat",
            "body": "pub open spec fn field_sub(a: nat, b: nat) -> nat {\n    (((a % p()) + p()) - (b % p())) as nat % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 115,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Math-level field subtraction",
            "math_interpretation": "(a - b) mod p, p = 2^255-19",
            "informal_interpretation": "Math-level field subtraction",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L115",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__nat_invsqrt",
            "name": "nat_invsqrt",
            "signature": "pub open spec fn nat_invsqrt(a: nat) -> nat",
            "body": "pub open spec fn nat_invsqrt(a: nat) -> nat {\n    if a % p() == 0 {\n        0\n    } else {\n        choose|r: nat|\n            #![auto]\n            !is_negative(r) && (is_sqrt_ratio(1, a, r) || is_sqrt_ratio_times_i(\n                1,\n                a,\n                r,\n            ))\n    }\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 510,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec-only model of inverse square root with a canonical sign choice.\n\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).",
            "math_interpretation": "1/sqrt(a) mod p (canonical sign)",
            "informal_interpretation": "Spec-only model of inverse square root with a canonical sign choice.\\n\\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L510",
            "category": "spec",
            "referenced_specs": [
                "is_negative",
                "is_sqrt_ratio",
                "is_sqrt_ratio_times_i",
                "p"
            ]
        },
        {
            "id": "specs__field_specs__is_negative",
            "name": "is_negative",
            "signature": "pub open spec fn is_negative(a: nat) -> bool",
            "body": "pub open spec fn is_negative(a: nat) -> bool {\n    (a % p()) % 2 == 1\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 503,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec predicate: a field element is negative if its canonical low bit is 1.",
            "math_interpretation": "a mod p is odd (sign convention)",
            "informal_interpretation": "Spec predicate: a field element is negative if its canonical low bit is 1.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L503",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__is_sqrt_ratio",
            "name": "is_sqrt_ratio",
            "signature": "pub open spec fn is_sqrt_ratio(u: nat, v: nat, r: nat) -> bool",
            "body": "pub open spec fn is_sqrt_ratio(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == u\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 491,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: r² * v = u (mod p) — math version operating on nat values\nThis is the mathematical equivalent of fe51_is_sqrt_ratio but without FieldElement wrappers.\nUse this when working with mathematical values directly in lemmas.",
            "math_interpretation": "r^2 * v = u (mod p)",
            "informal_interpretation": "Spec function: r² * v = u (mod p) — math version operating on nat values\\nThis is the mathematical equivalent of fe51_is_sqrt_ratio but without FieldElement wrappers.\\nUse this when working with mathematical values directly in lemmas.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L491",
            "category": "spec",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__field_specs__is_sqrt_ratio_times_i",
            "name": "is_sqrt_ratio_times_i",
            "signature": "pub open spec fn is_sqrt_ratio_times_i(u: nat, v: nat, r: nat) -> bool",
            "body": "pub open spec fn is_sqrt_ratio_times_i(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == (sqrt_m1() * u) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 498,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: r² * v = i*u (mod p) — math version operating on nat values\nUsed for the nonsquare case in sqrt_ratio_i.\nThis is the mathematical equivalent of fe51_is_sqrt_ratio_times_i.",
            "math_interpretation": "r^2 * v = i*u (mod p), i = sqrt(-1)",
            "informal_interpretation": "Spec function: r² * v = i*u (mod p) — math version operating on nat values\\nUsed for the nonsquare case in sqrt_ratio_i.\\nThis is the mathematical equivalent of fe51_is_sqrt_ratio_times_i.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L498",
            "category": "spec",
            "referenced_specs": [
                "p",
                "sqrt_m1"
            ]
        },
        {
            "id": "specs__field_specs__u8_32_from_nat",
            "name": "u8_32_from_nat",
            "signature": "pub open spec fn u8_32_from_nat(n: nat) -> [u8; 32]",
            "body": "pub open spec fn u8_32_from_nat(n: nat) -> [u8; 32] {\n    choose|b: [u8; 32]| u8_32_as_nat(&b) == n % pow2(256)\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 525,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Canonical little-endian bytes for a nat (mod 2^256).",
            "math_interpretation": "n mod 2^256 -> [u8;32] little-endian",
            "informal_interpretation": "Canonical little-endian bytes for a nat (mod 2^256).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L525",
            "category": "spec",
            "referenced_specs": [
                "u8_32_as_nat"
            ]
        },
        {
            "id": "specs__field_specs__fe51_as_canonical_nat",
            "name": "fe51_as_canonical_nat",
            "signature": "pub open spec fn fe51_as_canonical_nat(fe: &FieldElement51) -> nat",
            "body": "pub open spec fn fe51_as_canonical_nat(fe: &FieldElement51) -> nat {\n    fe51_as_nat(fe) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 75,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns the canonical mathematical value of a field element in [0, p)\nwhere p = 2^255 - 19",
            "math_interpretation": "fe -> fe mod p, canonical in [0, p)",
            "informal_interpretation": "Interprets a field element value as an integer modulo the prime p.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L75",
            "category": "spec",
            "referenced_specs": [
                "p",
                "fe51_as_nat"
            ]
        },
        {
            "id": "specs__field_specs__fe51_as_nat",
            "name": "fe51_as_nat",
            "signature": "pub open spec fn fe51_as_nat(fe: &FieldElement51) -> nat",
            "body": "pub open spec fn fe51_as_nat(fe: &FieldElement51) -> nat {\n    u64_5_as_nat(fe.limbs)\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 69,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "",
            "math_interpretation": "sum_i limb[i] * 2^(51i)",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L69",
            "category": "spec",
            "referenced_specs": [
                "u64_5_as_nat"
            ]
        },
        {
            "id": "specs__field_specs__field_element_from_bytes",
            "name": "field_element_from_bytes",
            "signature": "pub open spec fn field_element_from_bytes(bytes: &[u8; 32]) -> nat",
            "body": "pub open spec fn field_element_from_bytes(bytes: &[u8; 32]) -> nat {\n    (u8_32_as_nat(bytes) % pow2(255)) % p()\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 98,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns the canonical mathematical value when creating a field element from bytes.\nThe bytes are interpreted as a little-endian integer with the high bit of byte[31] ignored.\nThe result is the canonical value in [0, p) where p = 2^255 - 19.",
            "math_interpretation": "LE(b) mod 2^255 mod p",
            "informal_interpretation": "Interprets 32 bytes as a field element (spec-level decoding).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L98",
            "category": "spec",
            "referenced_specs": [
                "u8_32_as_nat",
                "p"
            ]
        },
        {
            "id": "specs__field_specs__fe51_as_canonical_nat_sign_bit",
            "name": "fe51_as_canonical_nat_sign_bit",
            "signature": "pub open spec fn fe51_as_canonical_nat_sign_bit(fe: &FieldElement51) -> u8",
            "body": "pub open spec fn fe51_as_canonical_nat_sign_bit(fe: &FieldElement51) -> u8 {\n    ((fe51_as_canonical_nat(fe) % p()) % 2) as u8\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 104,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function: Get the sign bit of a field element\nIn Curve25519, the sign bit is the least significant bit of the canonical representation",
            "math_interpretation": "(fe mod p) mod 2 (parity bit)",
            "informal_interpretation": "Returns the sign bit used in point compression (typically the parity of x).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L104",
            "category": "spec",
            "referenced_specs": [
                "p",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__field_specs__sqrt_m1",
            "name": "sqrt_m1",
            "signature": "pub open spec fn sqrt_m1() -> nat",
            "body": "pub open spec fn sqrt_m1() -> nat {\n    fe51_as_canonical_nat(&constants::SQRT_M1)\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 584,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "The mathematical value of SQRT_M1 (sqrt(-1) mod p)\nThis is the 4th root of unity i such that i² = -1 (mod p)",
            "math_interpretation": "i in F_p : i^2 = -1 (mod p)",
            "informal_interpretation": "The mathematical value of SQRT_M1 (sqrt(-1) mod p)\\nThis is the 4th root of unity i such that i² = -1 (mod p)",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L584",
            "category": "spec",
            "referenced_specs": [
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__field_specs__sum_of_limbs_bounded",
            "name": "sum_of_limbs_bounded",
            "signature": "pub open spec fn sum_of_limbs_bounded( fe1: &FieldElement51, fe2: &FieldElement51, bound: u64, ) -> bool",
            "body": "pub open spec fn sum_of_limbs_bounded(\n    fe1: &FieldElement51,\n    fe2: &FieldElement51,\n    bound: u64,\n) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe1.limbs[i] + fe2.limbs[i] < bound\n}",
            "file": "curve25519-dalek/src/specs/field_specs.rs",
            "line": 32,
            "module": "specs::field_specs",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec predicate: sum of limbs are bounded by a given bit limit",
            "math_interpretation": "forall i. limb1[i] + limb2[i] < bound",
            "informal_interpretation": "Checks that adding two field-element limb arrays stays within a safe bound (used to justify u64/u128 arithmetic).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L32",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__field_specs_u64__p",
            "name": "p",
            "signature": "pub open spec fn p() -> nat",
            "body": "pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}",
            "file": "curve25519-dalek/src/specs/field_specs_u64.rs",
            "line": 11,
            "module": "specs::field_specs_u64",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "",
            "math_interpretation": "p = 2^255 - 19 (Curve25519 prime)",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L11",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__field_specs_u64__u64_5_as_nat",
            "name": "u64_5_as_nat",
            "signature": "pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat",
            "body": "pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}",
            "file": "curve25519-dalek/src/specs/field_specs_u64.rs",
            "line": 52,
            "module": "specs::field_specs_u64",
            "short_module": "field",
            "visibility": "pub open spec fn",
            "doc_comment": "",
            "math_interpretation": "sum_i limb[i] * 2^(51i), radix-2^51",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L52",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__montgomery_specs__is_equal_to_minus_one",
            "name": "is_equal_to_minus_one",
            "signature": "pub open spec fn is_equal_to_minus_one(u: nat) -> bool",
            "body": "pub open spec fn is_equal_to_minus_one(u: nat) -> bool {\n    u == field_sub(0, 1)  // u == -1\n\n}",
            "file": "curve25519-dalek/src/specs/montgomery_specs.rs",
            "line": 258,
            "module": "specs::montgomery_specs",
            "short_module": "montgomery",
            "visibility": "pub open spec fn",
            "doc_comment": "Check if a Montgomery u-coordinate is invalid for conversion to Edwards\nu = -1 is invalid because it corresponds to a point on the twist",
            "math_interpretation": "u = p - 1 (i.e. u = -1 mod p)",
            "informal_interpretation": "Checks whether a field element equals -1 modulo the prime field.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L258",
            "category": "spec",
            "referenced_specs": [
                "field_sub"
            ]
        },
        {
            "id": "specs__montgomery_specs__montgomery_corresponds_to_edwards",
            "name": "montgomery_corresponds_to_edwards",
            "signature": "pub open spec fn montgomery_corresponds_to_edwards( montgomery: crate::montgomery::MontgomeryPoint, edwards: crate::edwards::EdwardsPoint, ) -> bool",
            "body": "pub open spec fn montgomery_corresponds_to_edwards(\n    montgomery: crate::montgomery::MontgomeryPoint,\n    edwards: crate::edwards::EdwardsPoint,\n) -> bool {\n    let u = spec_montgomery(montgomery);\n    let (x, y) = crate::specs::edwards_specs::edwards_point_as_affine(edwards);\n    let denominator = field_sub(1, y);\n\n    if denominator == 0 {\n        // Special case: Edwards identity (x=0, y=1) maps to Montgomery u=0\n        u == 0\n    } else {\n        // General case: u = (1+y)/(1-y)\n        let numerator = field_add(1, y);\n        u == field_mul(numerator, field_inv(denominator))\n    }\n}",
            "file": "curve25519-dalek/src/specs/montgomery_specs.rs",
            "line": 213,
            "module": "specs::montgomery_specs",
            "short_module": "montgomery",
            "visibility": "pub open spec fn",
            "doc_comment": "Check if a MontgomeryPoint corresponds to an EdwardsPoint\nvia the birational map u = (1+y)/(1-y)\nSpecial case: Edwards identity (y=1) maps to u=0",
            "math_interpretation": "u = (1+y)/(1-y), birational map",
            "informal_interpretation": "Relates a Montgomery u-coordinate representation to an Edwards point under the standard birational map.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L213",
            "category": "spec",
            "referenced_specs": [
                "edwards_point_as_affine",
                "field_add",
                "field_inv",
                "field_mul",
                "field_sub",
                "spec_montgomery"
            ]
        },
        {
            "id": "specs__montgomery_specs__spec_montgomery",
            "name": "spec_montgomery",
            "signature": "pub open spec fn spec_montgomery(point: crate::montgomery::MontgomeryPoint) -> nat",
            "body": "pub open spec fn spec_montgomery(point: crate::montgomery::MontgomeryPoint) -> nat {\n    field_element_from_bytes(&point.0)\n}",
            "file": "curve25519-dalek/src/specs/montgomery_specs.rs",
            "line": 206,
            "module": "specs::montgomery_specs",
            "short_module": "montgomery",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns the u-coordinate of a Montgomery point as a field element\nMontgomery points only store the u-coordinate; sign information is lost",
            "math_interpretation": "MontgomeryPoint -> u in F_p",
            "informal_interpretation": "Interprets a `MontgomeryPoint` as a field element u-coordinate (spec-level).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L206",
            "category": "spec",
            "referenced_specs": [
                "field_element_from_bytes"
            ]
        },
        {
            "id": "specs__ristretto_specs__is_in_even_subgroup",
            "name": "is_in_even_subgroup",
            "signature": "pub open spec fn is_in_even_subgroup(point: EdwardsPoint) -> bool",
            "body": "pub open spec fn is_in_even_subgroup(point: EdwardsPoint) -> bool {\n    exists|q: EdwardsPoint|\n        edwards_point_as_affine(point) == edwards_scalar_mul(\n            #[trigger] edwards_point_as_affine(q),\n            2,\n        )\n}",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 346,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "pub open spec fn",
            "doc_comment": "Point is in the even subgroup 2E = {2Q : Q ∈ E}; valid Ristretto points must lie in 2E.",
            "math_interpretation": "P in 2E = {2Q : Q in E(F_p)}",
            "informal_interpretation": "Predicate that an Edwards point lies in the even (torsion-free) subgroup used by Ristretto decoding.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L346",
            "category": "spec",
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul"
            ]
        },
        {
            "id": "specs__ristretto_specs__spec_ristretto_basepoint",
            "name": "spec_ristretto_basepoint",
            "signature": "pub open spec fn spec_ristretto_basepoint() -> (nat, nat)",
            "body": "pub open spec fn spec_ristretto_basepoint() -> (nat, nat) {\n    spec_ed25519_basepoint()\n}",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 194,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "pub open spec fn",
            "doc_comment": "The canonical representative of the Ristretto basepoint.\n\nThe Ristretto basepoint is the equivalence class [B] where B is the\nEd25519 basepoint. We use B itself as the canonical representative.",
            "math_interpretation": "[B] (Ristretto basepoint = Ed25519 B)",
            "informal_interpretation": "Returns the Ristretto basepoint (spec-level).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L194",
            "category": "spec",
            "referenced_specs": [
                "spec_ed25519_basepoint"
            ]
        },
        {
            "id": "specs__ristretto_specs__spec_ristretto_compress",
            "name": "spec_ristretto_compress",
            "signature": "pub open spec fn spec_ristretto_compress(point: RistrettoPoint) -> [u8; 32]",
            "body": "pub open spec fn spec_ristretto_compress(point: RistrettoPoint) -> [u8; 32] {\n    let (x, y, z, t) = spec_edwards_point(point.0);\n    spec_ristretto_compress_extended(x, y, z, t)\n}",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 113,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec-only model of Ristretto compression from a RistrettoPoint.\n\nThis captures the canonical encoding of a Ristretto point.\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\"",
            "math_interpretation": "E/~ -> [u8;32], Ristretto encoding",
            "informal_interpretation": "Spec-level function computing the canonical compressed encoding of a Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L113",
            "category": "spec",
            "referenced_specs": [
                "spec_edwards_point",
                "spec_ristretto_compress_extended"
            ]
        },
        {
            "id": "specs__ristretto_specs__spec_ristretto_compress_extended",
            "name": "spec_ristretto_compress_extended",
            "signature": "pub open spec fn spec_ristretto_compress_extended(x: nat, y: nat, z: nat, t: nat) -> [u8; 32]",
            "body": "pub open spec fn spec_ristretto_compress_extended(x: nat, y: nat, z: nat, t: nat) -> [u8; 32] {\n    let u1 = field_mul(field_add(z, y), field_sub(z, y));\n    let u2 = field_mul(x, y);\n    let invsqrt = nat_invsqrt(field_mul(u1, field_square(u2)));\n    let i1 = field_mul(invsqrt, u1);\n    let i2 = field_mul(invsqrt, u2);\n    let z_inv = field_mul(i1, field_mul(i2, t));\n    let den_inv = i2;\n\n    let iX = field_mul(x, sqrt_m1());\n    let iY = field_mul(y, sqrt_m1());\n    let enchanted_denominator = field_mul(\n        i1,\n        fe51_as_canonical_nat(&u64_constants::INVSQRT_A_MINUS_D),\n    );\n\n    let rotate = is_negative(field_mul(t, z_inv));\n    let x_rot = if rotate {\n        iY\n    } else {\n        x\n    };\n    let y_rot = if rotate {\n        iX\n    } else {\n        y\n    };\n    let den_inv_rot = if rotate {\n        enchanted_denominator\n    } else {\n        den_inv\n    };\n\n    let y_final = if is_negative(field_mul(x_rot, z_inv)) {\n        field_neg(y_rot)\n    } else {\n        y_rot\n    };\n    let s = field_mul(den_inv_rot, field_sub(z, y_final));\n    let s_final = if is_negative(s) {\n        field_neg(s)\n    } else {\n        s\n    };\n\n    u8_32_from_nat(s_final)\n}",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 61,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "pub open spec fn",
            "doc_comment": "Core Ristretto compression from extended coordinates (X, Y, Z, T).\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\";\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html.",
            "math_interpretation": "(X,Y,Z,T) -> [u8;32], core encoding",
            "informal_interpretation": "Core Ristretto compression from extended coordinates (X, Y, Z, T).\\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\";\\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L61",
            "category": "spec",
            "referenced_specs": [
                "field_add",
                "field_mul",
                "field_neg",
                "field_square",
                "field_sub",
                "nat_invsqrt",
                "is_negative",
                "u8_32_from_nat",
                "fe51_as_canonical_nat",
                "sqrt_m1"
            ]
        },
        {
            "id": "specs__ristretto_specs__spec_ristretto_decompress",
            "name": "spec_ristretto_decompress",
            "signature": "pub open spec fn spec_ristretto_decompress(bytes: [u8; 32]) -> Option<RistrettoPoint>",
            "body": "pub open spec fn spec_ristretto_decompress(bytes: [u8; 32]) -> Option<RistrettoPoint> {\n    let s_bytes_nat = u8_32_as_nat(&bytes);\n    let s = field_element_from_bytes(&bytes);\n    let s_encoding_is_canonical = s_bytes_nat < p();\n    let s_is_negative = is_negative(s);\n\n    if !s_encoding_is_canonical || s_is_negative {\n        None\n    } else {\n        let ss = field_square(s);\n        let u1 = field_sub(1, ss);\n        let u2 = field_add(1, ss);\n        let u2_sqr = field_square(u2);\n        let neg_d = field_neg(fe51_as_canonical_nat(&EDWARDS_D));\n        let u1_sqr = field_square(u1);\n        let v = field_sub(field_mul(neg_d, u1_sqr), u2_sqr);\n\n        let invsqrt_input = field_mul(v, u2_sqr);\n        let invsqrt = nat_invsqrt(invsqrt_input);\n        let ok = is_sqrt_ratio(1, invsqrt_input, invsqrt);\n\n        let dx = field_mul(invsqrt, u2);\n        let dy = field_mul(invsqrt, field_mul(dx, v));\n        let x_tmp = field_mul(field_add(s, s), dx);\n        let x = if is_negative(x_tmp) {\n            field_neg(x_tmp)\n        } else {\n            x_tmp\n        };\n        let y = field_mul(u1, dy);\n        let t = field_mul(x, y);\n\n        let t_is_negative = is_negative(t);\n        let y_is_zero = y == 0;\n\n        if !ok || t_is_negative || y_is_zero {\n            None\n        } else if exists|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t) {\n            Some(choose|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t))\n        } else {\n            None\n        }\n    }\n}",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 131,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec-only model of Ristretto decompression.\nReference: [RISTRETTO], §5.2 \"Ristretto255 Decoding\";\n[DECAF], Section 6 (decoding formulas), and https://ristretto.group/formulas/decoding.html.",
            "math_interpretation": "[u8;32] -> Option<E/~>, Ristretto decoding",
            "informal_interpretation": "Spec-level function decoding a compressed Ristretto encoding to an optional point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L131",
            "category": "spec",
            "referenced_specs": [
                "u8_32_as_nat",
                "field_add",
                "field_mul",
                "field_neg",
                "field_square",
                "field_sub",
                "nat_invsqrt",
                "is_negative",
                "is_sqrt_ratio",
                "p",
                "spec_edwards_point",
                "fe51_as_canonical_nat",
                "field_element_from_bytes"
            ]
        },
        {
            "id": "specs__scalar52_specs__group_order",
            "name": "group_order",
            "signature": "pub open spec fn group_order() -> nat",
            "body": "pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}",
            "file": "curve25519-dalek/src/specs/scalar52_specs.rs",
            "line": 69,
            "module": "specs::scalar52_specs",
            "short_module": "scalar",
            "visibility": "pub open spec fn",
            "doc_comment": "",
            "math_interpretation": "L = 2^252 + 27742317777372353535851937790883648493",
            "informal_interpretation": "Returns the Curve25519/Ed25519 scalar field modulus (group order).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L69",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__scalar_specs__is_canonical_scalar",
            "name": "is_canonical_scalar",
            "signature": "pub open spec fn is_canonical_scalar(s: &Scalar) -> bool",
            "body": "pub open spec fn is_canonical_scalar(s: &Scalar) -> bool {\n    // Invariant #2: Scalar is reduced (< group order)\n    u8_32_as_nat(&s.bytes)\n        < group_order()\n    // Invariant #1: High bit is clear (< 2^255)\n     && s.bytes[31] <= 127\n}",
            "file": "curve25519-dalek/src/specs/scalar_specs.rs",
            "line": 30,
            "module": "specs::scalar_specs",
            "short_module": "scalar",
            "visibility": "pub open spec fn",
            "doc_comment": "Checks if a Scalar satisfies the canonical representation invariants:\n- Invariant #1: High bit (bit 255) is clear, ensuring s < 2^255\n- Invariant #2: Scalar is reduced modulo group order, i.e., s < ℓ",
            "math_interpretation": "0 <= s < L and s < 2^255",
            "informal_interpretation": "Predicate that a `Scalar` is in canonical form (reduced modulo the group order).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L30",
            "category": "spec",
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order"
            ]
        },
        {
            "id": "specs__scalar_specs__is_clamped_integer",
            "name": "is_clamped_integer",
            "signature": "pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool",
            "body": "pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool {\n    // The 3 least significant bits are cleared (divisible by 8)\n    bytes[0] & 0b0000_0111\n        == 0\n    // Bit 255 (MSB) is cleared, making it < 2^255\n     && bytes[31] & 0b1000_0000 == 0\n    // Bit 254 is set, so result >= 2^254\n     && bytes[31] & 0b0100_0000\n        == 0b0100_0000\n    // MSB cleared implies bytes[31] <= 127 (needed for mul_req precondition)\n     && bytes[31] <= 127\n}",
            "file": "curve25519-dalek/src/specs/scalar_specs.rs",
            "line": 90,
            "module": "specs::scalar_specs",
            "short_module": "scalar",
            "visibility": "pub open spec fn",
            "doc_comment": "Returns true iff a byte array represents a clamped integer for X25519.\nA clamped integer has:\n- The 3 least significant bits cleared (divisible by 8)\n- Bit 255 (MSB) cleared (< 2^255), which means bytes[31] <= 127\n- Bit 254 set (>= 2^254)\nThis creates values in range: 2^254 + 8*{0, 1, 2, ..., 2^251 - 1}",
            "math_interpretation": "bits 0-2 clear, bit 254 set, bit 255 clear",
            "informal_interpretation": "Checks that a 32-byte array satisfies X25519 clamping (bit constraints).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L90",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "specs__scalar_specs__scalar_as_nat",
            "name": "scalar_as_nat",
            "signature": "pub open spec fn scalar_as_nat(s: &Scalar) -> nat",
            "body": "pub open spec fn scalar_as_nat(s: &Scalar) -> nat {\n    u8_32_as_nat(&s.bytes)\n}",
            "file": "curve25519-dalek/src/specs/scalar_specs.rs",
            "line": 17,
            "module": "specs::scalar_specs",
            "short_module": "scalar",
            "visibility": "pub open spec fn",
            "doc_comment": "",
            "math_interpretation": "LE(s.bytes) -> nat",
            "informal_interpretation": "Interprets a `Scalar`’s canonical byte encoding as a natural number.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L17",
            "category": "spec",
            "referenced_specs": [
                "u8_32_as_nat"
            ]
        },
        {
            "id": "specs__scalar_specs__spec_clamp_integer",
            "name": "spec_clamp_integer",
            "signature": "pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32]",
            "body": "pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32] {\n    // Build the result array element by element\n    [\n        bytes[0] & 0b1111_1000,  // Clear low 3 bits of byte 0\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n        bytes[6],\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n        bytes[19],\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        (bytes[31] & 0b0111_1111) | 0b0100_0000,  // Clear bit 7 and set bit 6 of byte 31\n    ]\n}",
            "file": "curve25519-dalek/src/specs/scalar_specs.rs",
            "line": 112,
            "module": "specs::scalar_specs",
            "short_module": "scalar",
            "visibility": "pub open spec fn",
            "doc_comment": "Spec function for clamping a byte array to produce a valid X25519 scalar.\nThis is the spec-level version of the `clamp_integer` exec function.\n\nThe clamping operation:\n- Clears the 3 least significant bits (bits 0-2 of byte 0)\n- Clears bit 255 (bit 7 of byte 31)\n- Sets bit 6 of byte 31)\n\nThis produces a value in the range [2^254, 2^255) that is divisible by 8.",
            "math_interpretation": "clamp: clear bits 0-2 and 255, set bit 254",
            "informal_interpretation": "Specification function computing the clamped 32-byte scalar used in X25519.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L112",
            "category": "spec",
            "referenced_specs": []
        },
        {
            "id": "core_assumes__axiom_hash_is_canonical",
            "name": "axiom_hash_is_canonical",
            "signature": "pub proof fn axiom_hash_is_canonical<H>(",
            "body": "pub proof fn axiom_hash_is_canonical<H>(\n    point1: &MontgomeryPoint,\n    point2: &MontgomeryPoint,\n    state: H,\n)\n    requires\n// The two points represent the same field element (same canonical value)\n\n        field_element_from_bytes(&point1.0) == field_element_from_bytes(&point2.0),\n    ensures\n// Points with equal field element values hash to the same state\n\n        spec_state_after_hash_montgomery(state, point1) == spec_state_after_hash_montgomery(\n            state,\n            point2,\n        ),",
            "file": "curve25519-dalek/src/core_assumes.rs",
            "line": 241,
            "module": "core_assumes",
            "short_module": "core_assumes",
            "visibility": "proof fn",
            "doc_comment": "",
            "math_interpretation": "field_element(P1) = field_element(P2) => hash(P1) = hash(P2)",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L241",
            "category": "axiom",
            "referenced_specs": [
                "field_element_from_bytes"
            ]
        },
        {
            "id": "core_assumes__axiom_sha512_output_length",
            "name": "axiom_sha512_output_length",
            "signature": "pub proof fn axiom_sha512_output_length(input: Seq<u8>)",
            "body": "pub proof fn axiom_sha512_output_length(input: Seq<u8>)\n    ensures\n        spec_sha512(input).len() == 64,",
            "file": "curve25519-dalek/src/core_assumes.rs",
            "line": 374,
            "module": "core_assumes",
            "short_module": "core_assumes",
            "visibility": "proof fn",
            "doc_comment": "Axiom: SHA-512 always produces exactly 64 bytes of output.",
            "math_interpretation": "|SHA-512(input)| = 64 bytes",
            "informal_interpretation": "Axiom: SHA-512 always produces exactly 64 bytes of output.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L374",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__common_lemmas__number_theory_lemmas__axiom_binomial_theorem",
            "name": "axiom_binomial_theorem",
            "signature": "proof fn axiom_binomial_theorem(a: nat, n: nat)",
            "body": "proof fn axiom_binomial_theorem(a: nat, n: nat)\n    ensures\n        binomial_sum(a, n, n) == pow((a + 1) as int, n) as nat,",
            "file": "curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs",
            "line": 533,
            "module": "lemmas::common_lemmas::number_theory_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)",
            "math_interpretation": "Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)",
            "informal_interpretation": "Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L533",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__edwards_lemmas__constants_lemmas__axiom_edwards_d2_is_2d",
            "name": "axiom_edwards_d2_is_2d",
            "signature": "pub(crate) proof fn axiom_edwards_d2_is_2d()",
            "body": "pub(crate) proof fn axiom_edwards_d2_is_2d()\n    ensures\n        fe51_as_canonical_nat(&constants::EDWARDS_D2) == field_mul(\n            2,\n            fe51_as_canonical_nat(&EDWARDS_D),\n        ),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs",
            "line": 126,
            "module": "lemmas::edwards_lemmas::constants_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "EDWARDS_D2 equals 2 * EDWARDS_D in the field\n\n## Mathematical Background\nEDWARDS_D2 is precomputed as 2*d mod p in the curve25519-dalek library.\nThis is a well-established relationship for the curve25519 constants.\n\nThe postcondition states that fe51_as_canonical_nat(&EDWARDS_D2) equals\nfield_mul(2, fe51_as_canonical_nat(&EDWARDS_D)), i.e., 2*d mod p.",
            "math_interpretation": "D2 = 2*D in F_p",
            "informal_interpretation": "EDWARDS_D2 equals 2 * EDWARDS_D in the field",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs#L126",
            "category": "axiom",
            "referenced_specs": [
                "field_mul",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "lemmas__edwards_lemmas__curve_equation_lemmas__axiom_add_neg_is_identity",
            "name": "axiom_add_neg_is_identity",
            "signature": "pub proof fn axiom_add_neg_is_identity(P: (nat, nat))",
            "body": "pub proof fn axiom_add_neg_is_identity(P: (nat, nat))\n    ensures\n        edwards_add(P.0, P.1, edwards_neg(P).0, edwards_neg(P).1) == math_edwards_identity(),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs",
            "line": 1113,
            "module": "lemmas::edwards_lemmas::curve_equation_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Adding a point and its negation gives identity.\nP + (-P) = O (identity)",
            "math_interpretation": "P + (-P) = O (identity)",
            "informal_interpretation": "Axiom: Adding a point and its negation gives identity.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1113",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add",
                "edwards_neg",
                "math_edwards_identity"
            ]
        },
        {
            "id": "lemmas__edwards_lemmas__curve_equation_lemmas__axiom_edwards_add_associative",
            "name": "axiom_edwards_add_associative",
            "signature": "pub proof fn axiom_edwards_add_associative(x1: nat, y1: nat, x2: nat, y2: nat, x3: nat, y3: nat)",
            "body": "pub proof fn axiom_edwards_add_associative(x1: nat, y1: nat, x2: nat, y2: nat, x3: nat, y3: nat)\n    ensures\n        ({\n            let ab = edwards_add(x1, y1, x2, y2);\n            edwards_add(ab.0, ab.1, x3, y3)\n        }) == ({\n            let bc = edwards_add(x2, y2, x3, y3);\n            edwards_add(x1, y1, bc.0, bc.1)\n        }),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs",
            "line": 686,
            "module": "lemmas::edwards_lemmas::curve_equation_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Edwards addition is associative.\n\nThis is a standard group-law property.",
            "math_interpretation": "(P + Q) + R = P + (Q + R) on Edwards curve",
            "informal_interpretation": "Axiom: Edwards addition is associative.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L686",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add"
            ]
        },
        {
            "id": "lemmas__edwards_lemmas__curve_equation_lemmas__axiom_edwards_scalar_mul_signed_additive",
            "name": "axiom_edwards_scalar_mul_signed_additive",
            "signature": "pub proof fn axiom_edwards_scalar_mul_signed_additive(P: (nat, nat), a: int, b: int)",
            "body": "pub proof fn axiom_edwards_scalar_mul_signed_additive(P: (nat, nat), a: int, b: int)\n    ensures\n        ({\n            let pa = edwards_scalar_mul_signed(P, a);\n            let pb = edwards_scalar_mul_signed(P, b);\n            edwards_add(pa.0, pa.1, pb.0, pb.1)\n        }) == edwards_scalar_mul_signed(P, a + b),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs",
            "line": 1123,
            "module": "lemmas::edwards_lemmas::curve_equation_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: [a]P + [b]P = [a+b]P for signed scalars a, b.\n\nThis is the group law for scalar multiplication linearity (group homomorphism property).",
            "math_interpretation": "[a]P + [b]P = [a+b]P (signed scalars)",
            "informal_interpretation": "Axiom: [a]P + [b]P = [a+b]P for signed scalars a, b.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1123",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add"
            ]
        },
        {
            "id": "lemmas__edwards_lemmas__curve_equation_lemmas__axiom_neg_distributes_over_add",
            "name": "axiom_neg_distributes_over_add",
            "signature": "pub proof fn axiom_neg_distributes_over_add(P: (nat, nat), Q: (nat, nat))",
            "body": "pub proof fn axiom_neg_distributes_over_add(P: (nat, nat), Q: (nat, nat))\n    ensures\n        edwards_add(edwards_neg(P).0, edwards_neg(P).1, edwards_neg(Q).0, edwards_neg(Q).1)\n            == edwards_neg(edwards_add(P.0, P.1, Q.0, Q.1)),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs",
            "line": 1103,
            "module": "lemmas::edwards_lemmas::curve_equation_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Negation distributes over addition (group homomorphism property).\n(-P) + (-Q) = -(P + Q)",
            "math_interpretation": "(-P) + (-Q) = -(P + Q)",
            "informal_interpretation": "Axiom: Negation distributes over addition (group homomorphism property).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1103",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add",
                "edwards_neg"
            ]
        },
        {
            "id": "lemmas__edwards_lemmas__curve_equation_lemmas__axiom_scalar_mul_distributes_over_neg",
            "name": "axiom_scalar_mul_distributes_over_neg",
            "signature": "pub proof fn axiom_scalar_mul_distributes_over_neg(P: (nat, nat), n: nat)",
            "body": "pub proof fn axiom_scalar_mul_distributes_over_neg(P: (nat, nat), n: nat)\n    ensures\n        edwards_scalar_mul(edwards_neg(P), n) == edwards_neg(edwards_scalar_mul(P, n)),",
            "file": "curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs",
            "line": 1094,
            "module": "lemmas::edwards_lemmas::curve_equation_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Scalar multiplication distributes over point negation.\n[n](-P) = -([n]P)",
            "math_interpretation": "[n](-P) = -([n]P)",
            "informal_interpretation": "Axiom: Scalar multiplication distributes over point negation.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1094",
            "category": "axiom",
            "referenced_specs": [
                "edwards_neg",
                "edwards_scalar_mul"
            ]
        },
        {
            "id": "lemmas__field_lemmas__field_algebra_lemmas__axiom_birational_edwards_montgomery",
            "name": "axiom_birational_edwards_montgomery",
            "signature": "pub proof fn axiom_birational_edwards_montgomery(y: nat, z: nat)",
            "body": "pub proof fn axiom_birational_edwards_montgomery(y: nat, z: nat)\n    requires\n        z % p() != 0,  // Non-identity point (Z ≠ 0)\n\n    ensures\n        ({\n            let y_affine = field_mul(y, field_inv(z));\n            let one_plus_y = field_add(1, y_affine);\n            let one_minus_y = field_sub(1, y_affine);\n            let projective_result = field_mul(\n                field_add(z, y),\n                field_inv(field_sub(z, y)),\n            );\n            let affine_result = field_mul(one_plus_y, field_inv(one_minus_y));\n            projective_result == affine_result\n        }),",
            "file": "curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs",
            "line": 1783,
            "module": "lemmas::field_lemmas::field_algebra_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Lemma: Birational map identity for Edwards-to-Montgomery conversion\n\n## Mathematical Proof\nThe birational map from Edwards to Montgomery is u = (1+y)/(1-y).\nIn projective coordinates with affine y = Y/Z, this becomes:\n\n```text\n(1 + Y/Z) / (1 - Y/Z) = ((Z + Y)/Z) / ((Z - Y)/Z)\n= (Z + Y) / (Z - Y)       [Z cancels]\n```\n\nThis identity is fundamental to the Edwards-Montgomery birational equivalence.",
            "math_interpretation": "(z+y)/(z-y) = (1+y/z)/(1-y/z) (birational map)",
            "informal_interpretation": "Lemma: Birational map identity for Edwards-to-Montgomery conversion",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs#L1783",
            "category": "axiom",
            "referenced_specs": [
                "field_add",
                "field_inv",
                "field_mul",
                "field_sub",
                "p"
            ]
        },
        {
            "id": "lemmas__field_lemmas__sqrt_m1_lemmas__axiom_neg_sqrt_m1_not_square",
            "name": "axiom_neg_sqrt_m1_not_square",
            "signature": "pub proof fn axiom_neg_sqrt_m1_not_square()",
            "body": "pub proof fn axiom_neg_sqrt_m1_not_square()\n    ensures\n        !is_square((p() - sqrt_m1()) as nat),",
            "file": "curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs",
            "line": 87,
            "module": "lemmas::field_lemmas::sqrt_m1_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "AXIOM: -i = -(sqrt(-1)) is not a square in F_p\n\nMathematical justification:\n- (-i)^((p-1)/2) = (-1)^((p-1)/2) · i^((p-1)/2)\n- (p-1)/2 = 2^254 - 10, which is even, so (-1)^((p-1)/2) = 1\n- From axiom_sqrt_m1_not_square: i^((p-1)/2) = -1\n- Therefore (-i)^((p-1)/2) = 1 · (-1) = -1 ≠ 1\n- By Euler's criterion, -i is NOT a square\n\nUsed in: lemma_no_square_root_when_times_i",
            "math_interpretation": "-sqrt(-1) is not a quadratic residue mod p",
            "informal_interpretation": "AXIOM: -i = -(sqrt(-1)) is not a square in F_p",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L87",
            "category": "axiom",
            "referenced_specs": [
                "p",
                "sqrt_m1"
            ]
        },
        {
            "id": "lemmas__field_lemmas__sqrt_m1_lemmas__axiom_sqrt_m1_not_square",
            "name": "axiom_sqrt_m1_not_square",
            "signature": "pub proof fn axiom_sqrt_m1_not_square()",
            "body": "pub proof fn axiom_sqrt_m1_not_square()\n    ensures\n        !is_square(sqrt_m1()),",
            "file": "curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs",
            "line": 70,
            "module": "lemmas::field_lemmas::sqrt_m1_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "AXIOM: i = sqrt(-1) is not a square in F_p\n\nMathematical justification:\n- p = 2^255 - 19 ≡ 5 (mod 8)\n- For p ≡ 5 (mod 8), the Euler criterion gives:\ni^((p-1)/2) = (i²)^((p-1)/4) = (-1)^((p-1)/4)\n- (p-1)/4 = (2^255 - 20)/4 = 2^253 - 5, which is odd\n- Therefore (-1)^((p-1)/4) = -1 ≠ 1\n- By Euler's criterion, i is NOT a square\n\nUsed in: lemma_no_square_root_when_times_i",
            "math_interpretation": "sqrt(-1) is not a quadratic residue mod p",
            "informal_interpretation": "AXIOM: i = sqrt(-1) is not a square in F_p",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L70",
            "category": "axiom",
            "referenced_specs": [
                "sqrt_m1"
            ]
        },
        {
            "id": "lemmas__field_lemmas__sqrt_m1_lemmas__axiom_sqrt_m1_squared",
            "name": "axiom_sqrt_m1_squared",
            "signature": "pub proof fn axiom_sqrt_m1_squared()",
            "body": "pub proof fn axiom_sqrt_m1_squared()\n    ensures\n        (sqrt_m1() * sqrt_m1()) % p() == (p() - 1),",
            "file": "curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs",
            "line": 52,
            "module": "lemmas::field_lemmas::sqrt_m1_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "AXIOM: i² = -1 (mod p) — Definition of SQRT_M1\n\nMathematical justification:\n- SQRT_M1 is a specific constant computed to satisfy i² ≡ -1 (mod p)\n- The value is approximately 2^252.3 (a ~252-bit number)\n- Verification would require BigInt computation of the actual product\n\nUsed in: lemma_sqrt_m1_neq_one, lemma_sqrt_m1_neq_neg_one,\nlemma_multiply_by_i_flips_sign, lemma_no_square_root_when_times_i",
            "math_interpretation": "i^2 = -1 (mod p), where i = sqrt(-1)",
            "informal_interpretation": "AXIOM: i² = -1 (mod p) — Definition of SQRT_M1",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L52",
            "category": "axiom",
            "referenced_specs": [
                "p",
                "sqrt_m1"
            ]
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_montgomery_add_associative",
            "name": "axiom_montgomery_add_associative",
            "signature": "pub proof fn axiom_montgomery_add_associative(",
            "body": "pub proof fn axiom_montgomery_add_associative(\n    P: MontgomeryAffine,\n    Q: MontgomeryAffine,\n    R: MontgomeryAffine,\n)\n    ensures\n        montgomery_add(montgomery_add(P, Q), R) == montgomery_add(P, montgomery_add(Q, R)),",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 37,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Montgomery addition is associative\n(P + Q) + R = P + (Q + R)",
            "math_interpretation": "(P + Q) + R = P + (Q + R)",
            "informal_interpretation": "Axiom: Montgomery addition is associative",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L37",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_montgomery_add_identity",
            "name": "axiom_montgomery_add_identity",
            "signature": "pub proof fn axiom_montgomery_add_identity(P: MontgomeryAffine)",
            "body": "pub proof fn axiom_montgomery_add_identity(P: MontgomeryAffine)\n    ensures\n        montgomery_add(P, MontgomeryAffine::Infinity) == P,",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 59,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Infinity is the identity element (right identity)\nP + ∞ = P",
            "math_interpretation": "P + ∞ = P",
            "informal_interpretation": "Axiom: Infinity is the identity element (right identity)",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L59",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_montgomery_add_identity_left",
            "name": "axiom_montgomery_add_identity_left",
            "signature": "pub proof fn axiom_montgomery_add_identity_left(P: MontgomeryAffine)",
            "body": "pub proof fn axiom_montgomery_add_identity_left(P: MontgomeryAffine)\n    ensures\n        montgomery_add(MontgomeryAffine::Infinity, P) == P,",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 50,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Left identity element\n∞ + P = P",
            "math_interpretation": "∞ + P = P",
            "informal_interpretation": "Axiom: Left identity element",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L50",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_montgomery_add_inverse",
            "name": "axiom_montgomery_add_inverse",
            "signature": "pub proof fn axiom_montgomery_add_inverse(P: MontgomeryAffine)",
            "body": "pub proof fn axiom_montgomery_add_inverse(P: MontgomeryAffine)\n    ensures\n        montgomery_add(P, montgomery_neg(P)) == MontgomeryAffine::Infinity,",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 68,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "Axiom: every point has an inverse\nP + (-P) = ∞",
            "math_interpretation": "P + (-P) = ∞",
            "informal_interpretation": "Axiom: every point has an inverse",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L68",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_xadd_projective_correct",
            "name": "axiom_xadd_projective_correct",
            "signature": "pub(crate) proof fn axiom_xadd_projective_correct(",
            "body": "pub(crate) proof fn axiom_xadd_projective_correct(\n    P: MontgomeryAffine,\n    Q: MontgomeryAffine,\n    U_P: nat,\n    W_P: nat,\n    U_Q: nat,\n    W_Q: nat,\n    affine_PmQ: nat,\n)\n    requires\n// (U_P:W_P) represents P; (U_Q:W_Q) represents Q\n\n        projective_represents_montgomery_or_infinity_nat(U_P, W_P, P),\n        projective_represents_montgomery_or_infinity_nat(U_Q, W_Q, Q),\n        P != Q,\n        affine_PmQ != 0,\n        // u-coordinate is symmetric: u(P-Q) = u(Q-P) since u is invariant under negation\n        affine_PmQ == spec_u_coordinate(montgomery_sub(P, Q)) || affine_PmQ == spec_u_coordinate(\n            montgomery_sub(Q, P),\n        ),\n    ensures\n        ({\n            let (U_PpQ, W_PpQ) = spec_xadd_projective(U_P, W_P, U_Q, W_Q, affine_PmQ);\n            projective_represents_montgomery_or_infinity_nat(U_PpQ, W_PpQ, montgomery_add(P, Q))\n        }),",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 240,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "**xADD Axiom**: `spec_xadd_projective` correctly computes P + Q.\n\nRequires P ≠ Q and u(P - Q) ≠ 0.",
            "math_interpretation": "xADD(U_P:W_P, U_Q:W_Q) represents P + Q",
            "informal_interpretation": "**xADD Axiom**: `spec_xadd_projective` correctly computes P + Q.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L240",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "lemmas__montgomery_curve_lemmas__axiom_xdbl_projective_correct",
            "name": "axiom_xdbl_projective_correct",
            "signature": "pub(crate) proof fn axiom_xdbl_projective_correct(P: MontgomeryAffine, U: nat, W: nat)",
            "body": "pub(crate) proof fn axiom_xdbl_projective_correct(P: MontgomeryAffine, U: nat, W: nat)\n    requires\n// (U:W) represents P: for finite points u = U/W; for ∞ we have W = 0, U ≠ 0\n\n        projective_represents_montgomery_or_infinity_nat(U, W, P),\n    ensures\n        ({\n            let (U2, W2) = spec_xdbl_projective(U, W);\n            projective_represents_montgomery_or_infinity_nat(U2, W2, montgomery_add(P, P))\n        }),",
            "file": "curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs",
            "line": 122,
            "module": "lemmas::montgomery_curve_lemmas",
            "short_module": "lemmas",
            "visibility": "proof fn",
            "doc_comment": "**xDBL Axiom**: `spec_xdbl_projective` correctly computes [2]P.\n\nIf `(U:W)` represents affine point `P`, then `xDBL(U,W)` represents `[2]P`.",
            "math_interpretation": "xDBL(U:W) represents [2]P",
            "informal_interpretation": "**xDBL Axiom**: `spec_xdbl_projective` correctly computes [2]P.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L122",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "specs__edwards_specs__axiom_ed25519_basepoint_canonical",
            "name": "axiom_ed25519_basepoint_canonical",
            "signature": "pub proof fn axiom_ed25519_basepoint_canonical()",
            "body": "pub proof fn axiom_ed25519_basepoint_canonical()\n    ensures\n        spec_ed25519_basepoint().0 < p(),\n        spec_ed25519_basepoint().1 < p(),",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 91,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "proof fn",
            "doc_comment": "The Ed25519 basepoint has reduced coordinates (both < p)\n\nThis is a property of the specific basepoint constant definition from the Ed25519 spec.\nThe basepoint X and Y coordinates are canonical field elements < p.\n\n## Values\n- X = 15112221349535807912866137220509078935008241517709382056166116785143545249788\n- Y = 46316835694926478169428394003475163141307993866256225615783033603165251855960\n- p = 57896044618658097711785492504343953926634992332820282019728792003956564819949\n\nBoth X < p and Y < p by direct comparison.\n",
            "math_interpretation": "B_x < p, B_y < p",
            "informal_interpretation": "The Ed25519 basepoint has reduced coordinates (both < p)",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L91",
            "category": "axiom",
            "referenced_specs": [
                "p",
                "spec_ed25519_basepoint"
            ]
        },
        {
            "id": "specs__edwards_specs__axiom_ed25519_basepoint_table_valid",
            "name": "axiom_ed25519_basepoint_table_valid",
            "signature": "pub proof fn axiom_ed25519_basepoint_table_valid()",
            "body": "pub proof fn axiom_ed25519_basepoint_table_valid()\n    ensures\n        is_valid_edwards_basepoint_table(*ED25519_BASEPOINT_TABLE, spec_ed25519_basepoint()),",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 144,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "proof fn",
            "doc_comment": "Axiom: ED25519_BASEPOINT_TABLE is a valid basepoint table for the Ed25519 basepoint.\nThis connects the hardcoded constant to our specification.",
            "math_interpretation": "ED25519_BASEPOINT_TABLE is valid for B",
            "informal_interpretation": "Axiom: ED25519_BASEPOINT_TABLE is a valid basepoint table for the Ed25519 basepoint.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L144",
            "category": "axiom",
            "referenced_specs": [
                "spec_ed25519_basepoint"
            ]
        },
        {
            "id": "specs__edwards_specs__axiom_eight_torsion_well_formed",
            "name": "axiom_eight_torsion_well_formed",
            "signature": "pub proof fn axiom_eight_torsion_well_formed()",
            "body": "pub proof fn axiom_eight_torsion_well_formed()\n    ensures\n        is_well_formed_edwards_point(EIGHT_TORSION[0]),\n        is_well_formed_edwards_point(EIGHT_TORSION[1]),\n        is_well_formed_edwards_point(EIGHT_TORSION[2]),\n        is_well_formed_edwards_point(EIGHT_TORSION[3]),\n        is_well_formed_edwards_point(EIGHT_TORSION[4]),\n        is_well_formed_edwards_point(EIGHT_TORSION[5]),\n        is_well_formed_edwards_point(EIGHT_TORSION[6]),\n        is_well_formed_edwards_point(EIGHT_TORSION[7]),",
            "file": "curve25519-dalek/src/specs/edwards_specs.rs",
            "line": 161,
            "module": "specs::edwards_specs",
            "short_module": "edwards",
            "visibility": "proof fn",
            "doc_comment": "Axiom: All 8-torsion points are well-formed.\n\nThe EIGHT_TORSION array contains the 8-torsion subgroup E[8] of the curve.\nEach element satisfies `is_well_formed_edwards_point`, which requires:\n- `is_valid_edwards_point`: Z ≠ 0, projective curve equation, X·Y = Z·T\n- `edwards_point_limbs_bounded`: all limbs < 2^52\n- `sum_of_limbs_bounded(Y, X)`: Y + X doesn't overflow\n\nThis is verified by the `test_eight_torsion_well_formed` test below.",
            "math_interpretation": "All E[8] torsion points are well-formed",
            "informal_interpretation": "Axiom: All 8-torsion points are well-formed.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L161",
            "category": "axiom",
            "referenced_specs": [
                "is_well_formed_edwards_point"
            ]
        },
        {
            "id": "specs__primality_specs__axiom_p_is_prime",
            "name": "axiom_p_is_prime",
            "signature": "pub proof fn axiom_p_is_prime()",
            "body": "pub proof fn axiom_p_is_prime()\n    ensures\n        is_prime(p()),",
            "file": "curve25519-dalek/src/specs/primality_specs.rs",
            "line": 24,
            "module": "specs::primality_specs",
            "short_module": "primality_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: The field modulus p() = 2^255 - 19 is prime\n\nThis is a well-known mathematical fact. The number 2^255 - 19 has been\nverified to be prime and is the foundation of the Curve25519 construction.\n\nThis axiom is the basis for field-theoretic properties like:\n- Existence of multiplicative inverses for all non-zero elements\n- Fermat's Little Theorem: x^(p-1) ≡ 1 (mod p) for x ≢ 0 (mod p)",
            "math_interpretation": "p = 2^255 - 19 is prime",
            "informal_interpretation": "Axiom: The field modulus p() = 2^255 - 19 is prime",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/primality_specs.rs#L24",
            "category": "axiom",
            "referenced_specs": [
                "p"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_from_bytes_independent",
            "name": "axiom_from_bytes_independent",
            "signature": "pub proof fn axiom_from_bytes_independent(",
            "body": "pub proof fn axiom_from_bytes_independent(\n    bytes1: &[u8; 32],\n    bytes2: &[u8; 32],\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n)\n    requires\n        fe51_as_nat(fe1) == u8_32_as_nat(bytes1) % pow2(255),\n        fe51_as_nat(fe2) == u8_32_as_nat(bytes2) % pow2(255),\n        is_independent_uniform_bytes32(bytes1, bytes2),\n    ensures\n        is_independent_uniform_field_elements(fe1, fe2),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 157,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: `from_bytes` preserves independence.\n\nIf two 32-byte strings are sampled independently, then the corresponding\nfield elements produced by `from_bytes` are also sampled independently.",
            "math_interpretation": "independent bytes => independent field elements",
            "informal_interpretation": "Axiom: `from_bytes` preserves independence.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L157",
            "category": "axiom",
            "referenced_specs": [
                "u8_32_as_nat",
                "fe51_as_nat"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_from_bytes_uniform",
            "name": "axiom_from_bytes_uniform",
            "signature": "pub proof fn axiom_from_bytes_uniform(bytes: &[u8; 32], fe: &FieldElement)",
            "body": "pub proof fn axiom_from_bytes_uniform(bytes: &[u8; 32], fe: &FieldElement)\n    requires\n        fe51_as_nat(fe) == u8_32_as_nat(bytes) % pow2(255),\n    ensures\n        is_uniform_bytes(bytes) ==> is_uniform_field_element(fe),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 144,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Clearing bit 255 of uniform bytes preserves uniform distribution.\n\nMathematical justification:\n- If X is uniform over [0, 2^256), then X mod 2^255 is uniform over [0, 2^255)\n- This is because the high bit is independent of the lower 255 bits\n- The limb representation is a bijection from 255-bit values to FieldElement\n\nNote: There's negligible bias (19/2^255 ≈ 5.4e-77) from values in [p, 2^255)\nthat wrap when used in field arithmetic, but this is cryptographically negligible.",
            "math_interpretation": "uniform bytes => uniform field element",
            "informal_interpretation": "Axiom: Clearing bit 255 of uniform bytes preserves uniform distribution.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L144",
            "category": "axiom",
            "referenced_specs": [
                "u8_32_as_nat",
                "fe51_as_nat"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_uniform_bytes_split",
            "name": "axiom_uniform_bytes_split",
            "signature": "pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])",
            "body": "pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 119,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Splitting uniform bytes preserves uniformity on each half.\n\nMathematical justification:\nIf X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\nare each uniform over [0, 2^256) (they are independent uniform samples).",
            "math_interpretation": "split(uniform_64) -> (uniform_32, uniform_32, independent)",
            "informal_interpretation": "Axiom: Splitting uniform bytes preserves uniformity on each half.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L119",
            "category": "axiom",
            "referenced_specs": []
        },
        {
            "id": "specs__proba_specs__axiom_uniform_elligator",
            "name": "axiom_uniform_elligator",
            "signature": "pub proof fn axiom_uniform_elligator(fe: &FieldElement, point: &RistrettoPoint)",
            "body": "pub proof fn axiom_uniform_elligator(fe: &FieldElement, point: &RistrettoPoint)\n    requires\n        edwards_point_as_affine(point.0) == spec_elligator_ristretto_flavor(fe51_as_canonical_nat(fe)),\n        is_uniform_field_element(fe),\n    ensures\n        is_uniform_over_elligator_image(point),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 187,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Elligator map on uniform field element produces uniform point\nover the Elligator IMAGE (approximately half the Ristretto group).\n\nIMPORTANT: A single Elligator call does NOT produce a uniform point over\nthe full Ristretto group. Elligator maps F_p to roughly half the curve points\n(those with a certain Jacobi symbol). See:\n- Bernstein et al., \"Elligator: Elliptic-curve points indistinguishable from uniform random strings\"\n- https://ristretto.group/formulas/elligator.html\n\nTo get uniform distribution over the FULL group, use two independent Elligator\ncalls and add the results (see `axiom_uniform_elligator_sum`).",
            "math_interpretation": "uniform field element => uniform over Elligator image",
            "informal_interpretation": "Axiom: Elligator map on uniform field element produces uniform point",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L187",
            "category": "axiom",
            "referenced_specs": [
                "edwards_point_as_affine",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_uniform_elligator_independent",
            "name": "axiom_uniform_elligator_independent",
            "signature": "pub proof fn axiom_uniform_elligator_independent(",
            "body": "pub proof fn axiom_uniform_elligator_independent(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n)\n    requires\n        edwards_point_as_affine(p1.0) == spec_elligator_ristretto_flavor(fe51_as_canonical_nat(fe1)),\n        edwards_point_as_affine(p2.0) == spec_elligator_ristretto_flavor(fe51_as_canonical_nat(fe2)),\n        is_independent_uniform_field_elements(fe1, fe2),\n    ensures\n        is_independent_uniform_ristretto_points(p1, p2),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 201,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Elligator preserves independence.\n\nIf two field elements are sampled independently, then applying the Elligator\nmap to each yields independently sampled points (over the Elligator image).",
            "math_interpretation": "independent field elements => independent Ristretto points",
            "informal_interpretation": "Axiom: Elligator preserves independence.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L201",
            "category": "axiom",
            "referenced_specs": [
                "edwards_point_as_affine",
                "fe51_as_canonical_nat"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_uniform_elligator_sum",
            "name": "axiom_uniform_elligator_sum",
            "signature": "pub proof fn axiom_uniform_elligator_sum(",
            "body": "pub proof fn axiom_uniform_elligator_sum(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n    sum: &RistrettoPoint,\n)\n    requires\n        edwards_point_as_affine(sum.0) == edwards_add(\n            edwards_point_as_affine(p1.0).0,\n            edwards_point_as_affine(p1.0).1,\n            edwards_point_as_affine(p2.0).0,\n            edwards_point_as_affine(p2.0).1,\n        ),\n        is_uniform_over_elligator_image(p1),\n        is_uniform_over_elligator_image(p2),\n        is_independent_uniform_ristretto_points(p1, p2),\n    ensures\n        is_uniform_ristretto_point(sum),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 229,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Sum of two *independent* uniform-over-Elligator-image points\nproduces a point uniform over the FULL Ristretto group.\n\nMathematical justification (Bernstein et al., ristretto.group):\n- Elligator(fe1) is uniform over ~half the group (Elligator image)\n- Elligator(fe2) is uniform over ~half the group (independent)\n- p1 + p2 covers the full group uniformly\n\nThis is precisely why `from_uniform_bytes` uses TWO Elligator calls + addition.",
            "math_interpretation": "P1 + P2 is uniform if P1, P2 independent from Elligator",
            "informal_interpretation": "Axiom: Sum of two *independent* uniform-over-Elligator-image points",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L229",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_uniform_mod_reduction",
            "name": "axiom_uniform_mod_reduction",
            "signature": "pub proof fn axiom_uniform_mod_reduction(input: &[u8; 64], result: &Scalar)",
            "body": "pub proof fn axiom_uniform_mod_reduction(input: &[u8; 64], result: &Scalar)\n    requires\n// result is the reduction of input mod group_order\n\n        scalar_as_nat(result) == bytes_seq_as_nat(input@) % group_order(),\n    ensures\n        is_uniform_bytes(input) ==> is_uniform_scalar(result),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 286,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Reducing 512 uniform bits modulo L produces a nearly uniform scalar.\n\nMathematical justification:\n- Input: 64 bytes = 512 bits, uniform over [0, 2^512)\n- Output: reduced modulo L (group order ≈ 2^253)\n- Each residue r ∈ [0, L) appears floor(2^512/L) or ceil(2^512/L) times\n- Statistical distance from uniform: at most L/2^512 ≈ 2^-259 (cryptographically negligible)",
            "math_interpretation": "X mod L is uniform over Z_L when X uniform over [0, 2^512)",
            "informal_interpretation": "Axiom: Reducing 512 uniform bits modulo L produces a nearly uniform scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L286",
            "category": "axiom",
            "referenced_specs": [
                "bytes_seq_as_nat",
                "group_order",
                "scalar_as_nat"
            ]
        },
        {
            "id": "specs__proba_specs__axiom_uniform_point_add",
            "name": "axiom_uniform_point_add",
            "signature": "pub proof fn axiom_uniform_point_add(p1: &RistrettoPoint, p2: &RistrettoPoint, sum: &RistrettoPoint)",
            "body": "pub proof fn axiom_uniform_point_add(p1: &RistrettoPoint, p2: &RistrettoPoint, sum: &RistrettoPoint)\n    requires\n        edwards_point_as_affine(sum.0) == edwards_add(\n            edwards_point_as_affine(p1.0).0,\n            edwards_point_as_affine(p1.0).1,\n            edwards_point_as_affine(p2.0).0,\n            edwards_point_as_affine(p2.0).1,\n        ),\n        is_uniform_ristretto_point(p1),\n        is_uniform_ristretto_point(p2),\n        is_independent_uniform_ristretto_points(p1, p2),\n    ensures\n        is_uniform_ristretto_point(sum),",
            "file": "curve25519-dalek/src/specs/proba_specs.rs",
            "line": 259,
            "module": "specs::proba_specs",
            "short_module": "proba_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: Sum of two *independent* uniform points is uniform (group theory property).\n\nMathematical justification:\nIn a prime-order group G, if X and Y are independent uniform elements of G,\nthen X + Y is also uniform over G. Without independence this is false\n(e.g. if Y = -X then X + Y is always the identity).",
            "math_interpretation": "P1 + P2 is uniform if P1, P2 uniform and independent",
            "informal_interpretation": "Axiom: Sum of two *independent* uniform points is uniform (group theory property).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L259",
            "category": "axiom",
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine"
            ]
        },
        {
            "id": "specs__ristretto_specs__axiom_ristretto_basepoint_table_valid",
            "name": "axiom_ristretto_basepoint_table_valid",
            "signature": "pub proof fn axiom_ristretto_basepoint_table_valid()",
            "body": "pub proof fn axiom_ristretto_basepoint_table_valid()\n    ensures\n        is_valid_edwards_basepoint_table(\n            constants::RISTRETTO_BASEPOINT_TABLE.0,\n            spec_ristretto_basepoint(),\n        ),",
            "file": "curve25519-dalek/src/specs/ristretto_specs.rs",
            "line": 204,
            "module": "specs::ristretto_specs",
            "short_module": "ristretto",
            "visibility": "proof fn",
            "doc_comment": "Axiom: `RISTRETTO_BASEPOINT_TABLE` is a valid precomputed table for the Ristretto basepoint.\n\nSince `RistrettoBasepointTable` wraps `EdwardsBasepointTable` and\n`RISTRETTO_BASEPOINT_TABLE` is a pointer cast of `ED25519_BASEPOINT_TABLE`,\nthis follows from `axiom_ed25519_basepoint_table_valid()`.",
            "math_interpretation": "RISTRETTO_BASEPOINT_TABLE is valid for Ristretto basepoint",
            "informal_interpretation": "Axiom: `RISTRETTO_BASEPOINT_TABLE` is a valid precomputed table for the Ristretto basepoint.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L204",
            "category": "axiom",
            "referenced_specs": [
                "spec_ristretto_basepoint"
            ]
        },
        {
            "id": "specs__window_specs__axiom_affine_odd_multiples_of_basepoint_valid",
            "name": "axiom_affine_odd_multiples_of_basepoint_valid",
            "signature": "pub proof fn axiom_affine_odd_multiples_of_basepoint_valid()",
            "body": "pub proof fn axiom_affine_odd_multiples_of_basepoint_valid()\n    ensures\n        naf_lookup_table8_affine_limbs_bounded(AFFINE_ODD_MULTIPLES_OF_BASEPOINT.0),\n        is_valid_naf_lookup_table8_affine_coords(\n            AFFINE_ODD_MULTIPLES_OF_BASEPOINT.0,\n            spec_ed25519_basepoint(),\n        ),",
            "file": "curve25519-dalek/src/specs/window_specs.rs",
            "line": 205,
            "module": "specs::window_specs",
            "short_module": "window_specs",
            "visibility": "proof fn",
            "doc_comment": "Axiom: AFFINE_ODD_MULTIPLES_OF_BASEPOINT is a valid NAF lookup table for the Ed25519 basepoint.\nThis connects the hardcoded constant to our specification.\n\nThe table contains odd multiples [1·B, 3·B, 5·B, ..., 127·B] where B is the Ed25519 basepoint.",
            "math_interpretation": "[1*B, 3*B, ..., 127*B] table is valid",
            "informal_interpretation": "Axiom: AFFINE_ODD_MULTIPLES_OF_BASEPOINT is a valid NAF lookup table for the Ed25519 basepoint.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L205",
            "category": "axiom",
            "referenced_specs": [
                "spec_ed25519_basepoint"
            ]
        }
    ],
    "verified_functions": [
        {
            "name": "conditional_assign",
            "display_name": "AffineNielsPoint::conditional_assign",
            "impl_type": "AffineNielsPoint",
            "contract": "fn conditional_assign(&mut self, other: &Self, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> *self == *old(self),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> *self == *other,",
            "requires": [],
            "ensures": [
                "!choice_is_true(choice) ==> *self == *old(self),",
                "choice_is_true(choice) ==> *self == *other,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 460,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L460",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "affinenielspoint__conditional_assign"
        },
        {
            "name": "identity",
            "display_name": "AffineNielsPoint::identity",
            "impl_type": "AffineNielsPoint",
            "contract": "fn identity() -> (result: ProjectivePoint)\n    ensures\n        result == identity_projective_point_edwards(),",
            "requires": [],
            "ensures": [
                "result == identity_projective_point_edwards(),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 265,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L297",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "affinenielspoint__identity"
        },
        {
            "name": "neg",
            "display_name": "AffineNielsPoint::neg",
            "impl_type": "AffineNielsPoint",
            "contract": "fn neg(self) -> (result:\n    AffineNielsPoint)/* requires clause in NegSpecImpl:\n   requires fe51_limbs_bounded(&self.xy2d, 51)\n*/\n\n    ensures\n// Structural: negation swaps y_plus_x and y_minus_x\n\n        result.y_plus_x == self.y_minus_x,\n        result.y_minus_x == self.y_plus_x,\n        // Mathematical: the affine point is negated (x, y) → (-x, y)\n        ({\n            let self_affine = affine_niels_point_as_affine_edwards(*self);\n            let result_affine = affine_niels_point_as_affine_edwards(result);\n            result_affine == (field_neg(self_affine.0), self_affine.1)\n        }),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "result.y_plus_x == self.y_minus_x,",
                "result.y_minus_x == self.y_plus_x,",
                "({ let self_affine = affine_niels_point_as_affine_edwards(*self); let result_affine = affine_niels_point_as_affine_edwards(result); result_affine == (field_neg(self_affine.0), self_affine.1) }),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_neg"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 1318,
            "module": "backend",
            "doc_comment": "Negate an AffineNielsPoint: for Edwards point (x, y), negation is (-x, y).\nIn AffineNiels form (y+x, y-x, xy2d), this swaps y+x ↔ y-x and negates xy2d.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1318",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "affinenielspoint__neg"
        },
        {
            "name": "zeroize",
            "display_name": "AffineNielsPoint::zeroize",
            "impl_type": "AffineNielsPoint",
            "contract": "fn zeroize(&mut self)\n    ensures\n// All fields are zeroed (each limb is 0)\n\n        forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,",
                "forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,",
                "forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 210,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L210",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "affinenielspoint__zeroize"
        },
        {
            "name": "as_extended",
            "display_name": "CompletedPoint::as_extended",
            "impl_type": "CompletedPoint",
            "contract": "pub fn as_extended(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_completed_point(*self),\n        // preconditions for mul\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n        fe51_limbs_bounded(&self.T, 54),\n    ensures\n        is_valid_edwards_point(result),\n        is_well_formed_edwards_point(result),\n        // Explicit bounds: mul() produces 52-bounded output\n        fe51_limbs_bounded(&result.X, 52),\n        fe51_limbs_bounded(&result.Y, 52),\n        fe51_limbs_bounded(&result.Z, 52),\n        fe51_limbs_bounded(&result.T, 52),\n        spec_edwards_point(result) == spec_completed_to_extended(*self),\n        edwards_point_as_affine(result) == completed_point_as_affine_edwards(*self),",
            "requires": [
                "is_valid_completed_point(*self),",
                "fe51_limbs_bounded(&self.X, 54),",
                "fe51_limbs_bounded(&self.Y, 54),",
                "fe51_limbs_bounded(&self.Z, 54),",
                "fe51_limbs_bounded(&self.T, 54),"
            ],
            "ensures": [
                "is_valid_edwards_point(result),",
                "is_well_formed_edwards_point(result),",
                "fe51_limbs_bounded(&result.X, 52),",
                "fe51_limbs_bounded(&result.Y, 52),",
                "fe51_limbs_bounded(&result.Z, 52),",
                "fe51_limbs_bounded(&result.T, 52),",
                "spec_edwards_point(result) == spec_completed_to_extended(*self),",
                "edwards_point_as_affine(result) == completed_point_as_affine_edwards(*self),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "is_well_formed_edwards_point",
                "spec_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 653,
            "module": "backend",
            "doc_comment": "Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n\\\\) model to the \\\\( \\mathbb P\\^3 \\\\) model.\n\nThis costs \\\\(4 \\mathrm M \\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L653",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "completedpoint__as_extended"
        },
        {
            "name": "as_projective",
            "display_name": "CompletedPoint::as_projective",
            "impl_type": "CompletedPoint",
            "contract": "pub fn as_projective(&self) -> (result: ProjectivePoint)\n    requires\n        is_valid_completed_point(*self),\n        // preconditions for arithmetic traits\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n        fe51_limbs_bounded(&self.T, 54),\n    ensures\n        is_valid_projective_point(result),\n        spec_projective_point_edwards(result) == spec_completed_to_projective(*self),\n        projective_point_as_affine_edwards(result) == completed_point_as_affine_edwards(*self),\n        // Limb bounds from mul() postconditions (mul produces 52-bounded output)\n        fe51_limbs_bounded(&result.X, 52),\n        fe51_limbs_bounded(&result.Y, 52),\n        fe51_limbs_bounded(&result.Z, 52),\n        // Sum bounded: X, Y each < 2^52, so sum < 2^53 < u64::MAX\n        sum_of_limbs_bounded(&result.X, &result.Y, u64::MAX),",
            "requires": [
                "is_valid_completed_point(*self),",
                "fe51_limbs_bounded(&self.X, 54),",
                "fe51_limbs_bounded(&self.Y, 54),",
                "fe51_limbs_bounded(&self.Z, 54),",
                "fe51_limbs_bounded(&self.T, 54),"
            ],
            "ensures": [
                "is_valid_projective_point(result),",
                "spec_projective_point_edwards(result) == spec_completed_to_projective(*self),",
                "projective_point_as_affine_edwards(result) == completed_point_as_affine_edwards(*self),",
                "fe51_limbs_bounded(&result.X, 52),",
                "fe51_limbs_bounded(&result.Y, 52),",
                "fe51_limbs_bounded(&result.Z, 52),",
                "sum_of_limbs_bounded(&result.X, &result.Y, u64::MAX),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 522,
            "module": "backend",
            "doc_comment": "Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n\\\\) model to the \\\\( \\mathbb P\\^2 \\\\) model.\n\nThis costs \\\\(3 \\mathrm M \\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L522",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "completedpoint__as_projective"
        },
        {
            "name": "add",
            "display_name": "EdwardsPoint::add",
            "impl_type": "EdwardsPoint",
            "contract": "fn add(self, other: &'b ProjectiveNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in AddSpecImpl::add_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        fe51_limbs_bounded(&other.Y_plus_X, 54),\n        fe51_limbs_bounded(&other.Y_minus_X, 54),\n        fe51_limbs_bounded(&other.Z, 54),\n        fe51_limbs_bounded(&other.T2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards addition of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        completed_point_as_affine_edwards(result) == spec_edwards_add_projective_niels(\n            *self,\n            *other,\n        ),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),",
            "requires": [
                "is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded fe51_limbs_bounded(&other.Y_plus_X, 54),",
                "fe51_limbs_bounded(&other.Y_minus_X, 54),",
                "fe51_limbs_bounded(&other.Z, 54),",
                "fe51_limbs_bounded(&other.T2d, 54),",
                "*/"
            ],
            "ensures": [
                "is_valid_completed_point(result),",
                "completed_point_as_affine_edwards(result) == spec_edwards_add_projective_niels( *self,",
                "*other,",
                "),",
                "fe51_limbs_bounded(&result.X, 54),",
                "fe51_limbs_bounded(&result.Y, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 854,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L854",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__add_L854"
        },
        {
            "name": "add",
            "display_name": "EdwardsPoint::add",
            "impl_type": "EdwardsPoint",
            "contract": "fn add(self, other: &'b AffineNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in AddSpecImpl::add_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),\n        fe51_limbs_bounded(&other.y_plus_x, 54),\n        fe51_limbs_bounded(&other.y_minus_x, 54),\n        fe51_limbs_bounded(&other.xy2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards addition of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        completed_point_as_affine_edwards(result) == spec_edwards_add_affine_niels(\n            *self,\n            *other,\n        ),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),",
            "requires": [
                "is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),",
                "fe51_limbs_bounded(&other.y_plus_x, 54),",
                "fe51_limbs_bounded(&other.y_minus_x, 54),",
                "fe51_limbs_bounded(&other.xy2d, 54),",
                "*/"
            ],
            "ensures": [
                "is_valid_completed_point(result),",
                "completed_point_as_affine_edwards(result) == spec_edwards_add_affine_niels( *self,",
                "*other,",
                "),",
                "fe51_limbs_bounded(&result.X, 54),",
                "fe51_limbs_bounded(&result.Y, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 1068,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1068",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__add_L1068"
        },
        {
            "name": "sub",
            "display_name": "EdwardsPoint::sub",
            "impl_type": "EdwardsPoint",
            "contract": "fn sub(self, other: &'b ProjectiveNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in SubSpecImpl::sub_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        fe51_limbs_bounded(&other.Y_plus_X, 54),\n        fe51_limbs_bounded(&other.Y_minus_X, 54),\n        fe51_limbs_bounded(&other.Z, 54),\n        fe51_limbs_bounded(&other.T2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards subtraction of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        ({\n            let self_affine = edwards_point_as_affine(*self);\n            let other_affine = projective_niels_point_as_affine_edwards(*other);\n            completed_point_as_affine_edwards(result) == edwards_sub(\n                self_affine.0,\n                self_affine.1,\n                other_affine.0,\n                other_affine.1,\n            )\n        }),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),",
            "requires": [
                "is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded fe51_limbs_bounded(&other.Y_plus_X, 54),",
                "fe51_limbs_bounded(&other.Y_minus_X, 54),",
                "fe51_limbs_bounded(&other.Z, 54),",
                "fe51_limbs_bounded(&other.T2d, 54),",
                "*/"
            ],
            "ensures": [
                "is_valid_completed_point(result),",
                "({ let self_affine = edwards_point_as_affine(*self); let other_affine = projective_niels_point_as_affine_edwards(*other); completed_point_as_affine_edwards(result) == edwards_sub( self_affine.0, self_affine.1, other_affine.0, other_affine.1, ) }), fe51_limbs_bounded(&result.X, 54),",
                "fe51_limbs_bounded(&result.Y, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T, 54),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 954,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L954",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__sub_L954"
        },
        {
            "name": "sub",
            "display_name": "EdwardsPoint::sub",
            "impl_type": "EdwardsPoint",
            "contract": "fn sub(self, other: &'b AffineNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in SubSpecImpl::sub_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),\n        fe51_limbs_bounded(&other.y_plus_x, 54),\n        fe51_limbs_bounded(&other.y_minus_x, 54),\n        fe51_limbs_bounded(&other.xy2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards subtraction of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        ({\n            let self_affine = edwards_point_as_affine(*self);\n            let other_affine = affine_niels_point_as_affine_edwards(*other);\n            completed_point_as_affine_edwards(result) == edwards_sub(\n                self_affine.0,\n                self_affine.1,\n                other_affine.0,\n                other_affine.1,\n            )\n        }),",
            "requires": [
                "is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),",
                "fe51_limbs_bounded(&other.y_plus_x, 54),",
                "fe51_limbs_bounded(&other.y_minus_x, 54),",
                "fe51_limbs_bounded(&other.xy2d, 54),",
                "*/"
            ],
            "ensures": [
                "is_valid_completed_point(result),",
                "({ let self_affine = edwards_point_as_affine(*self); let other_affine = affine_niels_point_as_affine_edwards(*other); completed_point_as_affine_edwards(result) == edwards_sub( self_affine.0, self_affine.1, other_affine.0, other_affine.1, ) }),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 1163,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1163",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__sub_L1163"
        },
        {
            "name": "add",
            "display_name": "FieldElement51::add",
            "impl_type": "FieldElement51",
            "contract": "fn add(self, _rhs: &'a FieldElement51) -> (output: FieldElement51)\n    ensures\n        output == spec_add_fe51_limbs(self, _rhs),\n        fe51_as_nat(&output) == fe51_as_nat(self)\n            + fe51_as_nat(_rhs),\n        fe51_as_canonical_nat(&output) == field_add(\n            fe51_as_canonical_nat(self),\n            fe51_as_canonical_nat(_rhs),\n        ),\n        // Bound propagation: tighter inputs give tighter output\n        fe51_limbs_bounded(self, 51) && fe51_limbs_bounded(_rhs, 51) ==> fe51_limbs_bounded(\n            &output,\n            52,\n        ),",
            "requires": [],
            "ensures": [
                "output == spec_add_fe51_limbs(self, _rhs),",
                "fe51_as_nat(&output) == fe51_as_nat(self) + fe51_as_nat(_rhs),",
                "fe51_as_canonical_nat(&output) == field_add( fe51_as_canonical_nat(self),",
                "fe51_as_canonical_nat(_rhs),",
                "),",
                "fe51_limbs_bounded(self, 51) && fe51_limbs_bounded(_rhs, 51) ==> fe51_limbs_bounded( &output,",
                "52,",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_add",
                "fe51_as_canonical_nat",
                "fe51_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 229,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L229",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__add"
        },
        {
            "name": "add_assign",
            "display_name": "FieldElement51::add_assign",
            "impl_type": "FieldElement51",
            "contract": "fn add_assign(&mut self, _rhs: &'a FieldElement51)\n    requires\n        sum_of_limbs_bounded(old(self), _rhs, u64::MAX),\n    ensures\n        *self == spec_add_fe51_limbs(old(self), _rhs),\n        fe51_as_nat(self) == fe51_as_nat(old(self))\n            + fe51_as_nat(_rhs),\n        fe51_as_canonical_nat(self) == field_add(\n            fe51_as_canonical_nat(old(self)),\n            fe51_as_canonical_nat(_rhs),\n        ),",
            "requires": [
                "sum_of_limbs_bounded(old(self), _rhs, u64::MAX),"
            ],
            "ensures": [
                "*self == spec_add_fe51_limbs(old(self), _rhs),",
                "fe51_as_nat(self) == fe51_as_nat(old(self)) + fe51_as_nat(_rhs),",
                "fe51_as_canonical_nat(self) == field_add( fe51_as_canonical_nat(old(self)),",
                "fe51_as_canonical_nat(_rhs),",
                "),"
            ],
            "referenced_specs": [
                "field_add",
                "fe51_as_canonical_nat",
                "fe51_as_nat",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 172,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L172",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__add_assign"
        },
        {
            "name": "as_bytes",
            "display_name": "FieldElement51::as_bytes",
            "impl_type": "FieldElement51",
            "contract": "pub fn as_bytes(self) -> (r: [u8; 32])\n    ensures\n// Canonical encoding: bytes represent the field element value\n\n        u8_32_as_nat(&r) == fe51_as_canonical_nat(&self),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&r) == fe51_as_canonical_nat(&self),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 1025,
            "module": "backend",
            "doc_comment": "Serialize this `FieldElement51` to a 32-byte array.  The\nencoding is canonical.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1025",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__as_bytes"
        },
        {
            "name": "conditional_assign",
            "display_name": "FieldElement51::conditional_assign",
            "impl_type": "FieldElement51",
            "contract": "fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> (forall|i: int|\n            0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> (forall|i: int|\n            0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n        // Field element value preservation\n        !choice_is_true(choice) ==> fe51_as_canonical_nat(self) == fe51_as_canonical_nat(old(self)),\n        choice_is_true(choice) ==> fe51_as_canonical_nat(self) == fe51_as_canonical_nat(other),\n        // Boundedness preservation\n        (fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(other, 54))\n            ==> fe51_limbs_bounded(self, 54),",
            "requires": [],
            "ensures": [
                "!choice_is_true(choice) ==> (forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),",
                "choice_is_true(choice) ==> (forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),",
                "!choice_is_true(choice) ==> fe51_as_canonical_nat(self) == fe51_as_canonical_nat(old(self)),",
                "choice_is_true(choice) ==> fe51_as_canonical_nat(self) == fe51_as_canonical_nat(other),",
                "(fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(other, 54)) ==> fe51_limbs_bounded(self, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 738,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L738",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__conditional_assign"
        },
        {
            "name": "from_limbs",
            "display_name": "FieldElement51::from_limbs",
            "impl_type": "FieldElement51",
            "contract": "pub(crate) const fn from_limbs(limbs: [u64; 5]) -> (result: FieldElement51)\n    ensures\n        (result == FieldElement51 { limbs }),",
            "requires": [],
            "ensures": [
                "(result == FieldElement51 { limbs }),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 780,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L780",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__from_limbs"
        },
        {
            "name": "mul",
            "display_name": "FieldElement51::mul",
            "impl_type": "FieldElement51",
            "contract": "fn mul(self, _rhs: &'a FieldElement51) -> (output:\n    FieldElement51)/*  VERIFICATION NOTE:\n- PROOF BYPASS\n- REVIEW SPEC WHILE DOING THE PROOF\n*/\n\n    ensures\n        fe51_as_canonical_nat(&output) == field_mul(\n            fe51_as_canonical_nat(self),\n            fe51_as_canonical_nat(_rhs),\n        ),\n        // Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n        fe51_limbs_bounded(&output, 52),\n        // 52-bit implies 54-bit (for compatibility with callers)\n        fe51_limbs_bounded(&output, 54),",
            "requires": [],
            "ensures": [
                "fe51_as_canonical_nat(&output) == field_mul( fe51_as_canonical_nat(self),",
                "fe51_as_canonical_nat(_rhs),",
                "),",
                "fe51_limbs_bounded(&output, 52),",
                "fe51_limbs_bounded(&output, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_mul",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 488,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L488",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "fieldelement51__mul"
        },
        {
            "name": "mul_assign",
            "display_name": "FieldElement51::mul_assign",
            "impl_type": "FieldElement51",
            "contract": "fn mul_assign(&mut self, _rhs: &'a FieldElement51)\n    requires\n        fe51_limbs_bounded(old(self), 54),\n        fe51_limbs_bounded(_rhs, 54),\n    ensures\n        fe51_as_canonical_nat(self) == field_mul(\n            fe51_as_canonical_nat(old(self)),\n            fe51_as_canonical_nat(_rhs),\n        ),\n        fe51_limbs_bounded(self, 54),",
            "requires": [
                "fe51_limbs_bounded(old(self), 54),",
                "fe51_limbs_bounded(_rhs, 54),"
            ],
            "ensures": [
                "fe51_as_canonical_nat(self) == field_mul( fe51_as_canonical_nat(old(self)),",
                "fe51_as_canonical_nat(_rhs),",
                "),",
                "fe51_limbs_bounded(self, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_mul",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 447,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L447",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__mul_assign"
        },
        {
            "name": "neg",
            "display_name": "FieldElement51::neg",
            "impl_type": "FieldElement51",
            "contract": "fn neg(self) -> (output: FieldElement51)\n    ensures\n        fe51_as_canonical_nat(&output) == field_neg(fe51_as_canonical_nat(self)),\n        forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 52),",
            "requires": [],
            "ensures": [
                "fe51_as_canonical_nat(&output) == field_neg(fe51_as_canonical_nat(self)),",
                "forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 52),"
            ],
            "referenced_specs": [
                "field_neg",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 652,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L652",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__neg"
        },
        {
            "name": "negate",
            "display_name": "FieldElement51::negate",
            "impl_type": "FieldElement51",
            "contract": "pub fn negate(&mut self)\n    requires\n        forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 54),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, u64_5_as_nat((c0, c, c, c, c)) = p, so\n        // u64_5_as_nat(16 * (c0, c, c, c, c) - l) is 16p - u64_5_as_nat(l)\n        // We know u64_5_as_nat(reduce(v)) = u64_5_as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // u64_5_as_nat(negate(l)) = u64_5_as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - u64_5_as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        u64_5_as_nat(self.limbs) == 16 * p() - u64_5_as_nat(old(self).limbs) - p() * ((\n        36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n        (u64_5_as_nat(self.limbs) + u64_5_as_nat(old(self).limbs)) % p() == 0,\n        self.limbs == spec_negate(old(self).limbs),",
            "requires": [
                "forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 54),"
            ],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),",
                "u64_5_as_nat(self.limbs) == 16 * p() - u64_5_as_nat(old(self).limbs) - p() * (( 36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),",
                "(u64_5_as_nat(self.limbs) + u64_5_as_nat(old(self).limbs)) % p() == 0,",
                "self.limbs == spec_negate(old(self).limbs),"
            ],
            "referenced_specs": [
                "p",
                "u64_5_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 811,
            "module": "backend",
            "doc_comment": "Invert the sign of this field element\n\n# Implementation Note on Limb Bounds\n\nThe implementation adds 16*p (constants around 2^55) then subtracts and reduces.\nThe math shows it can actually handle larger inputs without underflow:\n- For 52-bit limbs (< 2^52): 2^55 - 2^52 = 7*2^52 > 0 ✓ (no underflow)\n- For 54-bit limbs (< 2^54): 2^55 - 2^54 = 2^54 > 0 ✓ (no underflow)\n",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L811",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__negate"
        },
        {
            "name": "pow2k",
            "display_name": "FieldElement51::pow2k",
            "impl_type": "FieldElement51",
            "contract": "pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n    requires\n        k > 0,  // debug_assert!( k > 0 );\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < 1u64 << 54  // 51 + b for b = 3\n        ,\n    ensures\n// Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation in reduction)\n\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n        // 52-bit implies 54-bit (for compatibility with callers)\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n        u64_5_as_nat(r.limbs) % p() == pow(\n            u64_5_as_nat(self.limbs) as int,\n            pow2(k as nat),\n        ) as nat % p(),",
            "requires": [
                "k > 0,  // debug_assert!( k > 0 ); forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54  // 51 + b for b = 3 ,"
            ],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,",
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,",
                "u64_5_as_nat(r.limbs) % p() == pow( u64_5_as_nat(self.limbs) as int,",
                "pow2(k as nat),",
                ") as nat % p(),"
            ],
            "referenced_specs": [
                "p",
                "u64_5_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 1148,
            "module": "backend",
            "doc_comment": "Given `k > 0`, return `self^(2^k)`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1148",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__pow2k"
        },
        {
            "name": "reduce",
            "display_name": "FieldElement51::reduce",
            "impl_type": "FieldElement51",
            "contract": "fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n    ensures\n        r.limbs == spec_reduce(limbs),\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n        u64_5_as_nat(r.limbs) == u64_5_as_nat(limbs) - p() * (limbs[4] >> 51),\n        u64_5_as_nat(r.limbs) % p() == u64_5_as_nat(limbs) % p(),\n        u64_5_as_nat(r.limbs) < 2 * p(),",
            "requires": [],
            "ensures": [
                "r.limbs == spec_reduce(limbs),",
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),",
                "(forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),",
                "u64_5_as_nat(r.limbs) == u64_5_as_nat(limbs) - p() * (limbs[4] >> 51),",
                "u64_5_as_nat(r.limbs) % p() == u64_5_as_nat(limbs) % p(),",
                "u64_5_as_nat(r.limbs) < 2 * p(),"
            ],
            "referenced_specs": [
                "p",
                "u64_5_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 867,
            "module": "backend",
            "doc_comment": "Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L867",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__reduce"
        },
        {
            "name": "square",
            "display_name": "FieldElement51::square",
            "impl_type": "FieldElement51",
            "contract": "pub fn square(&self) -> (r: FieldElement51)\n    requires\n// The precondition in pow2k loop propagates to here\n\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n    ensures\n// Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n        // 52-bit implies 54-bit (for compatibility with callers)\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n        u64_5_as_nat(r.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p(),",
            "requires": [
                "forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,"
            ],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,",
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,",
                "u64_5_as_nat(r.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p(),"
            ],
            "referenced_specs": [
                "p",
                "u64_5_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 1309,
            "module": "backend",
            "doc_comment": "Returns the square of this field element.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1309",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__square"
        },
        {
            "name": "square2",
            "display_name": "FieldElement51::square2",
            "impl_type": "FieldElement51",
            "contract": "pub fn square2(&self) -> (r: FieldElement51)\n    requires\n// The precondition in pow2k loop propagates to here\n\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n    ensures\n        u64_5_as_nat(r.limbs) % p() == (2 * pow(u64_5_as_nat(self.limbs) as int, 2)) as nat\n            % p(),\n        // Bounds: pow2k gives 52-bounded, doubling gives 53-bounded\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 53,\n        // 53-bounded implies 54-bounded (for compatibility)\n        fe51_limbs_bounded(&r, 54),",
            "requires": [
                "forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,"
            ],
            "ensures": [
                "u64_5_as_nat(r.limbs) % p() == (2 * pow(u64_5_as_nat(self.limbs) as int, 2)) as nat % p(),",
                "forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 53,",
                "fe51_limbs_bounded(&r, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "p",
                "u64_5_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 1330,
            "module": "backend",
            "doc_comment": "Returns 2 times the square of this field element.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1330",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__square2"
        },
        {
            "name": "sub",
            "display_name": "FieldElement51::sub",
            "impl_type": "FieldElement51",
            "contract": "fn sub(self, _rhs: &'a FieldElement51) -> (output:\n    FieldElement51)\n// VERIFICATION NOTE: PROOF BYPASS\n\n    ensures\n        output == spec_sub_limbs(self, _rhs),\n        fe51_as_canonical_nat(&output) == field_sub(\n            fe51_as_canonical_nat(self),\n            fe51_as_canonical_nat(_rhs),\n        ),\n        fe51_limbs_bounded(&output, 54),",
            "requires": [],
            "ensures": [
                "output == spec_sub_limbs(self, _rhs),",
                "fe51_as_canonical_nat(&output) == field_sub( fe51_as_canonical_nat(self),",
                "fe51_as_canonical_nat(_rhs),",
                "),",
                "fe51_limbs_bounded(&output, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_sub",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 343,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L343",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__sub"
        },
        {
            "name": "sub_assign",
            "display_name": "FieldElement51::sub_assign",
            "impl_type": "FieldElement51",
            "contract": "fn sub_assign(\n    &mut self,\n    _rhs: &'a FieldElement51,\n)\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(_rhs, 54),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n        *self == spec_sub_limbs(old(self), _rhs),\n        fe51_as_canonical_nat(self) == field_sub(\n            fe51_as_canonical_nat(old(self)),\n            fe51_as_canonical_nat(_rhs),\n        ),",
            "requires": [
                "fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(_rhs, 54),"
            ],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),",
                "*self == spec_sub_limbs(old(self), _rhs),",
                "fe51_as_canonical_nat(self) == field_sub( fe51_as_canonical_nat(old(self)),",
                "fe51_as_canonical_nat(_rhs),",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_sub",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 285,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L285",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "fieldelement51__sub_assign"
        },
        {
            "name": "zeroize",
            "display_name": "FieldElement51::zeroize",
            "impl_type": "FieldElement51",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 129,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L129",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement51__zeroize"
        },
        {
            "name": "optional_multiscalar_mul_verus",
            "display_name": "Pippenger::optional_multiscalar_mul_verus",
            "impl_type": "Pippenger",
            "contract": "pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where S: Borrow<Scalar>, I: Iterator<Item = S>, J: Iterator<Item = Option<EdwardsPoint>>\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some iff all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>( points,",
                ").len(),",
                "forall|i: int| 0 <= i < spec_optional_points_from_iter::<J>(points).len() && ( #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some() ==> is_well_formed_edwards_point( spec_optional_points_from_iter::<J>(points)[i].unwrap(),",
                "),"
            ],
            "ensures": [
                "result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),",
                "result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),",
                "result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "unwrap_points(spec_optional_points_from_iter::<J>(points)),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs",
            "line": 219,
            "module": "backend",
            "doc_comment": "Verus-compatible version of optional_multiscalar_mul.\nComputes sum(scalars[i] * points[i]) for all i where points[i] is Some.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs#L219",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "pippenger__optional_multiscalar_mul_verus"
        },
        {
            "name": "conditional_assign",
            "display_name": "ProjectiveNielsPoint::conditional_assign",
            "impl_type": "ProjectiveNielsPoint",
            "contract": "fn conditional_assign(&mut self, other: &Self, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> *self == *old(self),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> *self == *other,",
            "requires": [],
            "ensures": [
                "!choice_is_true(choice) ==> *self == *old(self),",
                "choice_is_true(choice) ==> *self == *other,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 414,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L414",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivenielspoint__conditional_assign"
        },
        {
            "name": "identity",
            "display_name": "ProjectiveNielsPoint::identity",
            "impl_type": "ProjectiveNielsPoint",
            "contract": "fn identity() -> (result: ProjectivePoint)\n    ensures\n        result == identity_projective_point_edwards(),",
            "requires": [],
            "ensures": [
                "result == identity_projective_point_edwards(),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 265,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L274",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "projectivenielspoint__identity"
        },
        {
            "name": "neg",
            "display_name": "ProjectiveNielsPoint::neg",
            "impl_type": "ProjectiveNielsPoint",
            "contract": "fn neg(self) -> (result:\n    ProjectiveNielsPoint)/* requires clause in NegSpecImpl:\n   requires fe51_limbs_bounded(&self.T2d, 51)\n*/\n\n    ensures\n// Structural: negation swaps Y_plus_X and Y_minus_X, keeps Z\n\n        result.Y_plus_X == self.Y_minus_X,\n        result.Y_minus_X == self.Y_plus_X,\n        result.Z == self.Z,\n        // Mathematical: the affine point is negated (x, y) → (-x, y)\n        ({\n            let self_affine = projective_niels_point_as_affine_edwards(*self);\n            let result_affine = projective_niels_point_as_affine_edwards(result);\n            result_affine == (field_neg(self_affine.0), self_affine.1)\n        }),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "result.Y_plus_X == self.Y_minus_X,",
                "result.Y_minus_X == self.Y_plus_X,",
                "result.Z == self.Z,",
                "({ let self_affine = projective_niels_point_as_affine_edwards(*self); let result_affine = projective_niels_point_as_affine_edwards(result); result_affine == (field_neg(self_affine.0), self_affine.1) }),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_neg"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 1257,
            "module": "backend",
            "doc_comment": "Negate a ProjectiveNielsPoint: for Edwards point (x, y), negation is (-x, y).\nIn Niels form (Y+X, Y-X, Z, T2d), this swaps Y+X ↔ Y-X and negates T2d.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1257",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivenielspoint__neg"
        },
        {
            "name": "zeroize",
            "display_name": "ProjectiveNielsPoint::zeroize",
            "impl_type": "ProjectiveNielsPoint",
            "contract": "fn zeroize(&mut self)\n    ensures\n// All fields are zeroed (each limb is 0)\n\n        forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,",
                "forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,",
                "forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 210,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L240",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "projectivenielspoint__zeroize"
        },
        {
            "name": "as_extended",
            "display_name": "ProjectivePoint::as_extended",
            "impl_type": "ProjectivePoint",
            "contract": "pub fn as_extended(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_projective_point(*self),\n        // preconditions for arithmetic traits\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n    ensures\n        is_valid_edwards_point(result),\n        spec_edwards_point(result) == spec_projective_to_extended(*self),\n        edwards_point_as_affine(result) == projective_point_as_affine_edwards(*self),",
            "requires": [
                "is_valid_projective_point(*self),",
                "fe51_limbs_bounded(&self.X, 54),",
                "fe51_limbs_bounded(&self.Y, 54),",
                "fe51_limbs_bounded(&self.Z, 54),"
            ],
            "ensures": [
                "is_valid_edwards_point(result),",
                "spec_edwards_point(result) == spec_projective_to_extended(*self),",
                "edwards_point_as_affine(result) == projective_point_as_affine_edwards(*self),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "spec_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 489,
            "module": "backend",
            "doc_comment": "Convert this point from the \\\\( \\mathbb P\\^2 \\\\) model to the\n\\\\( \\mathbb P\\^3 \\\\) model.\n\nThis costs \\\\(3 \\mathrm M + 1 \\mathrm S\\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L489",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivepoint__as_extended"
        },
        {
            "name": "double",
            "display_name": "ProjectivePoint::double",
            "impl_type": "ProjectivePoint",
            "contract": "pub fn double(&self) -> (result: CompletedPoint)\n    requires\n        is_valid_projective_point(*self),\n        // preconditions for arithmetic traits (ProjectivePoint invariant: 52-bounded)\n        fe51_limbs_bounded(&self.X, 52),\n        fe51_limbs_bounded(&self.Y, 52),\n        fe51_limbs_bounded(&self.Z, 52),\n        sum_of_limbs_bounded(&self.X, &self.Y, u64::MAX),\n    ensures\n        is_valid_completed_point(result),\n        // The result represents the affine doubling of self\n        completed_point_as_affine_edwards(result) == ({\n            let (x, y) = projective_point_as_affine_edwards(*self);\n            edwards_double(x, y)\n        }),\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),",
            "requires": [
                "is_valid_projective_point(*self),",
                "fe51_limbs_bounded(&self.X, 52),",
                "fe51_limbs_bounded(&self.Y, 52),",
                "fe51_limbs_bounded(&self.Z, 52),",
                "sum_of_limbs_bounded(&self.X, &self.Y, u64::MAX),"
            ],
            "ensures": [
                "is_valid_completed_point(result),",
                "completed_point_as_affine_edwards(result) == ({ let (x, y) = projective_point_as_affine_edwards(*self); edwards_double(x, y) }), fe51_limbs_bounded(&result.X, 54),",
                "fe51_limbs_bounded(&result.Y, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T, 54),"
            ],
            "referenced_specs": [
                "edwards_double",
                "fe51_limbs_bounded",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 708,
            "module": "backend",
            "doc_comment": "Double this point: return self + self",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L708",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivepoint__double"
        },
        {
            "name": "is_valid",
            "display_name": "ProjectivePoint::is_valid",
            "impl_type": "ProjectivePoint",
            "contract": "fn is_valid(&self) -> (result: bool)\n    requires\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n    ensures\n        result == math_on_edwards_curve_projective(\n            fe51_as_canonical_nat(&self.X),\n            fe51_as_canonical_nat(&self.Y),\n            fe51_as_canonical_nat(&self.Z),\n        ),",
            "requires": [
                "fe51_limbs_bounded(&self.X, 54),",
                "fe51_limbs_bounded(&self.Y, 54),",
                "fe51_limbs_bounded(&self.Z, 54),"
            ],
            "ensures": [
                "result == math_on_edwards_curve_projective( fe51_as_canonical_nat(&self.X),",
                "fe51_as_canonical_nat(&self.Y),",
                "fe51_as_canonical_nat(&self.Z),",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "math_on_edwards_curve_projective",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/curve_models/mod.rs",
            "line": 325,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L325",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivepoint__is_valid"
        },
        {
            "name": "add",
            "display_name": "Scalar52::add",
            "impl_type": "Scalar52",
            "contract": "pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        scalar52_to_nat(&a) < group_order(),\n        scalar52_to_nat(&b) < group_order(),\n    ensures\n        scalar52_to_nat(&s) == (scalar52_to_nat(&a) + scalar52_to_nat(&b)) % group_order(),\n        // VERIFICATION NOTE: Result is canonical\n        scalar52_to_nat(&s) < group_order(),\n        // VERIFICATION NOTE: Result has bounded limbs (from sub)\n        limbs_bounded(&s),",
            "requires": [
                "limbs_bounded(a),",
                "limbs_bounded(b),",
                "scalar52_to_nat(&a) < group_order(),",
                "scalar52_to_nat(&b) < group_order(),"
            ],
            "ensures": [
                "scalar52_to_nat(&s) == (scalar52_to_nat(&a) + scalar52_to_nat(&b)) % group_order(),",
                "scalar52_to_nat(&s) < group_order(),",
                "limbs_bounded(&s),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 525,
            "module": "backend",
            "doc_comment": "Compute `a + b` (mod l)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L525",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__add"
        },
        {
            "name": "as_bytes",
            "display_name": "Scalar52::as_bytes",
            "impl_type": "Scalar52",
            "contract": "pub fn as_bytes(self) -> (s: [u8; 32])\n    requires\n        limbs_bounded(&self),\n    ensures\n        u8_32_as_nat(&s) == scalar52_to_nat(&self) % pow2(256),",
            "requires": [
                "limbs_bounded(&self),"
            ],
            "ensures": [
                "u8_32_as_nat(&s) == scalar52_to_nat(&self) % pow2(256),"
            ],
            "referenced_specs": [
                "u8_32_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 474,
            "module": "backend",
            "doc_comment": "Pack the limbs of this `Scalar52` into 32 bytes",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L474",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__as_bytes"
        },
        {
            "name": "as_montgomery",
            "display_name": "Scalar52::as_montgomery",
            "impl_type": "Scalar52",
            "contract": "pub fn as_montgomery(&self) -> (result: Scalar52)\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        #[trigger] (scalar52_to_nat(&result) % group_order()) == #[trigger] ((scalar52_to_nat(\n            self,\n        ) * montgomery_radix()) % group_order()),\n        // Result is canonical because RR is canonical\n        scalar52_to_nat(&result) < group_order(),",
            "requires": [],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "#[trigger] (scalar52_to_nat(&result) % group_order()) == #[trigger] ((scalar52_to_nat( self,",
                ") * montgomery_radix()) % group_order()),",
                "scalar52_to_nat(&result) < group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1292,
            "module": "backend",
            "doc_comment": "Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1292",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__as_montgomery"
        },
        {
            "name": "from_bytes",
            "display_name": "Scalar52::from_bytes",
            "impl_type": "Scalar52",
            "contract": "pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures\n        u8_32_as_nat(bytes) == scalar52_to_nat(&s),\n        limbs_bounded(&s),\n        limb_prod_bounded_u128(s.limbs, s.limbs, 5),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(bytes) == scalar52_to_nat(&s),",
                "limbs_bounded(&s),",
                "limb_prod_bounded_u128(s.limbs, s.limbs, 5),"
            ],
            "referenced_specs": [
                "u8_32_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 157,
            "module": "backend",
            "doc_comment": "Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L157",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__from_bytes"
        },
        {
            "name": "from_bytes_wide",
            "display_name": "Scalar52::from_bytes_wide",
            "impl_type": "Scalar52",
            "contract": "pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n// VERIFICATION NOTE: Result is canonical\n\n        is_canonical_scalar52(&s),\n        scalar52_to_nat(&s) == bytes_seq_as_nat(bytes@) % group_order(),",
            "requires": [],
            "ensures": [
                "is_canonical_scalar52(&s),",
                "scalar52_to_nat(&s) == bytes_seq_as_nat(bytes@) % group_order(),"
            ],
            "referenced_specs": [
                "bytes_seq_as_nat",
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 228,
            "module": "backend",
            "doc_comment": "Reduce a 64 byte / 512 bit scalar mod l",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L228",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__from_bytes_wide"
        },
        {
            "name": "from_montgomery",
            "display_name": "Scalar52::from_montgomery",
            "impl_type": "Scalar52",
            "contract": "pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limb_prod_bounded_u128(self.limbs, self.limbs, 5),\n    ensures\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == scalar52_to_nat(self)\n            % group_order(),\n        // Result is canonical (< group_order). This follows from montgomery_reduce's postcondition\n        is_canonical_scalar52(&result),",
            "requires": [
                "limb_prod_bounded_u128(self.limbs, self.limbs, 5),"
            ],
            "ensures": [
                "(scalar52_to_nat(&result) * montgomery_radix()) % group_order() == scalar52_to_nat(self) % group_order(),",
                "is_canonical_scalar52(&result),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1330,
            "module": "backend",
            "doc_comment": "Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1330",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__from_montgomery"
        },
        {
            "name": "index",
            "display_name": "Scalar52::index",
            "impl_type": "Scalar52",
            "contract": "fn index(&self, _index: usize) -> (result: &u64)\n    requires\n        _index < 5,\n    ensures\n        result == &(self.limbs[_index as int]),",
            "requires": [
                "_index < 5,"
            ],
            "ensures": [
                "result == &(self.limbs[_index as int]),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 119,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L119",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__index"
        },
        {
            "name": "montgomery_mul",
            "display_name": "Scalar52::montgomery_mul",
            "impl_type": "Scalar52",
            "contract": "pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limb_prod_bounded_u128(a.limbs, b.limbs, 5),\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat(&a)\n            * scalar52_to_nat(&b)) % group_order(),\n        // Canonicity: if either input is canonical, result is canonical\n        (scalar52_to_nat(a) < group_order() || scalar52_to_nat(b) < group_order())\n            ==> scalar52_to_nat(&result) < group_order(),",
            "requires": [
                "limb_prod_bounded_u128(a.limbs, b.limbs, 5),"
            ],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "(scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat(&a) * scalar52_to_nat(&b)) % group_order(),",
                "(scalar52_to_nat(a) < group_order() || scalar52_to_nat(b) < group_order()) ==> scalar52_to_nat(&result) < group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1243,
            "module": "backend",
            "doc_comment": "Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1243",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__montgomery_mul"
        },
        {
            "name": "montgomery_reduce",
            "display_name": "Scalar52::montgomery_reduce",
            "impl_type": "Scalar52",
            "contract": "pub(crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result:\n    Scalar52)\n// If the input is the product of 2 bounded scalars, we get 2 postconditions.\n// If the 2nd scalar is also canonical, we unlock a 3rd postcondition.\n// Not all calling code needs the 3rd postcondition.\n// Note: This spec is not yet confirmed because the function is unproved.\n// The spec is checked by prop_montgomery_reduce_two_bounded and prop_montgomery_reduce_one_canonical.\n// If you edit this spec, please update the proptests.\n// Once this function and all deps are proved, you can remove those proptests,\n// and montgomery_reduce_non_canonical_product_fails_postcondition,\n// and test_canonical_scalar_generator (if it's then unused)\n\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        is_canonical_scalar52(&result),  // Sub returns a value equal to (a - b) % L, so it's always < L and canonical\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == slice128_to_nat(\n            limbs,\n        ) % group_order(),",
            "requires": [],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "is_canonical_scalar52(&result),  // Sub returns a value equal to (a - b) % L, so it's always < L and canonical (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == slice128_to_nat( limbs,",
                ") % group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 999,
            "module": "backend",
            "doc_comment": "Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L999",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar52__montgomery_reduce"
        },
        {
            "name": "montgomery_square",
            "display_name": "Scalar52::montgomery_square",
            "impl_type": "Scalar52",
            "contract": "pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n        limb_prod_bounded_u128(self.limbs, self.limbs, 5),\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat(\n            self,\n        ) * scalar52_to_nat(self)) % group_order(),",
            "requires": [
                "limb_prod_bounded_u128(self.limbs, self.limbs, 5),"
            ],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "(scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat( self,",
                ") * scalar52_to_nat(self)) % group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1277,
            "module": "backend",
            "doc_comment": "Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1277",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__montgomery_square"
        },
        {
            "name": "mul",
            "display_name": "Scalar52::mul",
            "impl_type": "Scalar52",
            "contract": "pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limb_prod_bounded_u128(a.limbs, b.limbs, 5),\n    ensures\n        scalar52_to_nat(&result) % group_order() == (scalar52_to_nat(&a) * scalar52_to_nat(&b))\n            % group_order(),\n        // VER NOTE: Result is canonical from montgomery_reduce\n        is_canonical_scalar52(&result),",
            "requires": [
                "limb_prod_bounded_u128(a.limbs, b.limbs, 5),"
            ],
            "ensures": [
                "scalar52_to_nat(&result) % group_order() == (scalar52_to_nat(&a) * scalar52_to_nat(&b)) % group_order(),",
                "is_canonical_scalar52(&result),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1140,
            "module": "backend",
            "doc_comment": "Compute `a * b` (mod l)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1140",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__mul"
        },
        {
            "name": "mul_internal",
            "display_name": "Scalar52::mul_internal",
            "impl_type": "Scalar52",
            "contract": "pub(crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limb_prod_bounded_u128(a.limbs, b.limbs, 5),\n    ensures\n        slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&b),\n        spec_mul_internal(a, b) == z,",
            "requires": [
                "limb_prod_bounded_u128(a.limbs, b.limbs, 5),"
            ],
            "ensures": [
                "slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&b),",
                "spec_mul_internal(a, b) == z,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 871,
            "module": "backend",
            "doc_comment": "Compute `a * b`",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L871",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__mul_internal"
        },
        {
            "name": "square",
            "display_name": "Scalar52::square",
            "impl_type": "Scalar52",
            "contract": "pub fn square(&self) -> (result: Scalar52)\n    requires\n        limb_prod_bounded_u128(self.limbs, self.limbs, 5),\n    ensures\n        scalar52_to_nat(&result) == (scalar52_to_nat(self) * scalar52_to_nat(self))\n            % group_order(),",
            "requires": [
                "limb_prod_bounded_u128(self.limbs, self.limbs, 5),"
            ],
            "ensures": [
                "scalar52_to_nat(&result) == (scalar52_to_nat(self) * scalar52_to_nat(self)) % group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1189,
            "module": "backend",
            "doc_comment": "Compute `a^2` (mod l)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1189",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__square"
        },
        {
            "name": "square_internal",
            "display_name": "Scalar52::square_internal",
            "impl_type": "Scalar52",
            "contract": "fn square_internal(a: &Scalar52) -> [u128; 9] {\n    let aa = [\n        a[0] * 2,\n        a[1] * 2,\n        a[2] * 2,\n        a[3] * 2,\n    ];\n\n    [\n        m( a[0], a[0]),\n        m(aa[0], a[1]),\n        m(aa[0], a[2]) + m( a[1], a[1]),\n        m(aa[0], a[3]) + m(aa[1], a[2]),\n        m(aa[0], a[4]) + m(aa[1], a[3]) + m( a[2], a[2]),\n                         m(aa[1], a[4]) + m(aa[2], a[3]),\n                                          m(aa[2], a[4]) + m( a[3], a[3]),\n                                                           m(aa[3], a[4]),\n                                                                            m(a[4], a[4])\n    ]\n}\n</ORIGINAL CODE> */\n/* <VERIFICATION NOTE>\n-  refactored verified version of square_internal\n- slightly slower ?\n</VERIFICATION NOTE> */\n/// Compute `a^2`\n#[inline(always)]\n#[rustfmt::skip]  // keep alignment of calculations\npub(crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limb_prod_bounded_u128(a.limbs, a.limbs, 5),\n    ensures\n        slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&a),\n        spec_mul_internal(a, a) == z,\n        limbs_bounded(&a) ==> forall|i: int| 0 <= i < 9 ==> z[i] < 5 * (1u128 << 104),",
            "requires": [
                "limb_prod_bounded_u128(a.limbs, a.limbs, 5),"
            ],
            "ensures": [
                "slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&a),",
                "spec_mul_internal(a, a) == z,",
                "limbs_bounded(&a) ==> forall|i: int| 0 <= i < 9 ==> z[i] < 5 * (1u128 << 104),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 903,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L931",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__square_internal"
        },
        {
            "name": "sub",
            "display_name": "Scalar52::sub",
            "impl_type": "Scalar52",
            "contract": "pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // Without the following condition, all we can prove is something like:\n        // scalar52_to_nat(&a) >= scalar52_to_nat(&b) ==> scalar52_to_nat(&s) == scalar52_to_nat(&a) - scalar52_to_nat(&b),\n        // scalar52_to_nat(&a) < scalar52_to_nat(&b) ==> scalar52_to_nat(&s) == (scalar52_to_nat(&a) - scalar52_to_nat(&b) + pow2(260) + group_order()) % (pow2(260) as int),\n        // In the 2nd case, `sub` doesn't always do subtraction mod group_order\n        -group_order() <= scalar52_to_nat(&a) - scalar52_to_nat(&b) < group_order(),\n    ensures\n        scalar52_to_nat(&s) == (scalar52_to_nat(&a) - scalar52_to_nat(&b)) % (\n        group_order() as int),\n        // VERIFICATION NOTE: Result is in canonical form\n        is_canonical_scalar52(&s),",
            "requires": [
                "limbs_bounded(a),",
                "limbs_bounded(b),",
                "-group_order() <= scalar52_to_nat(&a) - scalar52_to_nat(&b) < group_order(),"
            ],
            "ensures": [
                "scalar52_to_nat(&s) == (scalar52_to_nat(&a) - scalar52_to_nat(&b)) % ( group_order() as int),",
                "is_canonical_scalar52(&s),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 714,
            "module": "backend",
            "doc_comment": "Compute `a - b` (mod l)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L714",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__sub"
        },
        {
            "name": "zeroize",
            "display_name": "Scalar52::zeroize",
            "impl_type": "Scalar52",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 107,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L107",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar52__zeroize"
        },
        {
            "name": "multiscalar_mul_verus",
            "display_name": "Straus::multiscalar_mul_verus",
            "impl_type": "Straus",
            "contract": "pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result: EdwardsPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<EdwardsPoint>,\n    I: Iterator<Item = S>,\n    J: Iterator<Item = P>,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>(\n            points,\n        ).len(),\n        // All input points must be well-formed\n        forall|i: int|\n            0 <= i < spec_points_from_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_points_from_iter::<P, J>(points)[i],\n            ),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        edwards_point_as_affine(result) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_points_from_iter::<P, J>(points),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>( points,",
                ").len(),",
                "forall|i: int| 0 <= i < spec_points_from_iter::<P, J>(points).len() ==> is_well_formed_edwards_point( #[trigger] spec_points_from_iter::<P, J>(points)[i],",
                "),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "spec_points_from_iter::<P, J>(points),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
            "line": 453,
            "module": "backend",
            "doc_comment": "Verus-compatible version of multiscalar_mul (constant-time).\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nComputes sum(scalars[i] * points[i]).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L453",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "straus__multiscalar_mul_verus"
        },
        {
            "name": "optional_multiscalar_mul_verus",
            "display_name": "Straus::optional_multiscalar_mul_verus",
            "impl_type": "Straus",
            "contract": "pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where S: Borrow<Scalar>, I: Iterator<Item = S>, J: Iterator<Item = Option<EdwardsPoint>>\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some if and only if all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>( points,",
                ").len(),",
                "forall|i: int| 0 <= i < spec_optional_points_from_iter::<J>(points).len() && ( #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some() ==> is_well_formed_edwards_point( spec_optional_points_from_iter::<J>(points)[i].unwrap(),",
                "),"
            ],
            "ensures": [
                "result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),",
                "result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),",
                "result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "unwrap_points(spec_optional_points_from_iter::<J>(points)),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/backend/serial/scalar_mul/straus.rs",
            "line": 269,
            "module": "backend",
            "doc_comment": "Verus-compatible version of optional_multiscalar_mul.\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nComputes sum(scalars[i] * points[i]) for all i where points[i] is Some.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L269",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "straus__optional_multiscalar_mul_verus"
        },
        {
            "name": "load8_at",
            "display_name": "load8_at",
            "impl_type": "",
            "contract": "pub(super) const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == spec_load8_at(input, i),",
            "requires": [
                "i + 7 < input.len(),"
            ],
            "ensures": [
                "r as nat == spec_load8_at(input, i),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/field.rs",
            "line": 140,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L140",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "backend__load8_at"
        },
        {
            "name": "m",
            "display_name": "m",
            "impl_type": "",
            "contract": "fn m(x: u64, y: u64) -> (z: u128)\n    ensures\n        (z as nat) == (x as nat) * (y as nat),",
            "requires": [],
            "ensures": [
                "(z as nat) == (x as nat) * (y as nat),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 141,
            "module": "backend",
            "doc_comment": "u64 * u64 = u128 multiply helper",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L141",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "backend__m"
        },
        {
            "name": "mul",
            "display_name": "mul",
            "impl_type": "",
            "contract": "pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n// as_radix_16 requires scalar.bytes[31] <= 127 (MSB clear, i.e. scalar < 2^255)\n\n        scalar.bytes[31] <= 127,\n        // Input point must be well-formed (valid coordinates with proper limb bounds)\n        is_well_formed_edwards_point(*point),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result represents scalar * point\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*point),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,",
                "is_well_formed_edwards_point(*point),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(*point),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs",
            "line": 29,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs#L29",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "backend__mul_L29"
        },
        {
            "name": "mul",
            "display_name": "mul",
            "impl_type": "",
            "contract": "pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> (out: EdwardsPoint)\n    requires\n// Input point must be well-formed\n\n        is_well_formed_edwards_point(*A),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(out),\n        // Functional correctness: out = a*A + b*B where B is the Ed25519 basepoint\n        edwards_point_as_affine(out) == {\n            let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_as_nat(a));\n            let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_as_nat(b));\n            edwards_add(aA.0, aA.1, bB.0, bB.1)\n        },",
            "requires": [
                "is_well_formed_edwards_point(*A),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(out),",
                "edwards_point_as_affine(out) == { let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_as_nat(a)); let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_as_nat(b)); edwards_add(aA.0, aA.1, bB.0, bB.1) },"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs",
            "line": 42,
            "module": "backend",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs#L42",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "backend__mul_L42"
        },
        {
            "name": "part1",
            "display_name": "part1",
            "impl_type": "",
            "contract": "fn part1(sum: u128) -> (res: (u128, u64))\n    requires\n// Bound needed to ensure no overflow and carry bounds\n\n        sum < (1u128 << 108),\n    ensures\n        ({\n            let carry = res.0;\n            let p = res.1;\n            &&& p < (1u64 << 52)  // p is bounded by 52 bits\n            &&& sum + (p as u128) * (constants::L.limbs[0] as u128) == carry << 52\n        }),",
            "requires": [
                "sum < (1u128 << 108),"
            ],
            "ensures": [
                "({ let carry = res.0; let p = res.1; &&& p < (1u64 << 52)  // p is bounded by 52 bits &&& sum + (p as u128) * (constants::L.limbs[0] as u128) == carry << 52 }),"
            ],
            "referenced_specs": [
                "p"
            ],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1050,
            "module": "backend",
            "doc_comment": "Helper function for Montgomery reduction\nComputes p such that sum + p*L[0] is divisible by 2^52, returns (carry, p).\nVER NOTE: spec validation needed concurrent with proof for montgomery_reduce",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1050",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "backend__part1"
        },
        {
            "name": "part2",
            "display_name": "part2",
            "impl_type": "",
            "contract": "fn part2(sum: u128) -> (res: (u128, u64))\n    ensures\n        ({\n            let carry = res.0;\n            let w = res.1;\n            &&& w < (1u64\n                << 52)  // VER NOTE: w is bounded by 52 bits (lower limb)\n            // VER NOTE: The sum equals w plus carry shifted left by 52 bits\n            &&& sum == (w as u128) + (carry << 52)\n        }),",
            "requires": [],
            "ensures": [
                "({ let carry = res.0; let w = res.1; &&& w < (1u64 << 52)  // VER NOTE: w is bounded by 52 bits (lower limb) // VER NOTE: The sum equals w plus carry shifted left by 52 bits &&& sum == (w as u128) + (carry << 52) }),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/backend/serial/u64/scalar.rs",
            "line": 1121,
            "module": "backend",
            "doc_comment": "Helper function for Montgomery reduction\nVER NOTE: spec validation needed concurrent with proof for montgomery_reduce",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1121",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "backend__part2"
        },
        {
            "name": "as_bytes",
            "display_name": "CompressedEdwardsY::as_bytes",
            "impl_type": "CompressedEdwardsY",
            "contract": "pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == self.0,",
            "requires": [],
            "ensures": [
                "result == self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 255,
            "module": "edwards",
            "doc_comment": "View this `CompressedEdwardsY` as an array of bytes.",
            "math_interpretation": "&CompressedEdwardsY -> &[u8; 32]",
            "informal_interpretation": "Returns the byte representation of a compressed Edwards Y point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L255",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__as_bytes"
        },
        {
            "name": "ct_eq",
            "display_name": "CompressedEdwardsY::ct_eq",
            "impl_type": "CompressedEdwardsY",
            "contract": "fn ct_eq(&self, other: &CompressedEdwardsY) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.0 == other.0),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (self.0 == other.0),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 231,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L231",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__ct_eq"
        },
        {
            "name": "decompress",
            "display_name": "CompressedEdwardsY::decompress",
            "impl_type": "CompressedEdwardsY",
            "contract": "pub fn decompress(&self) -> (result: Option<\n    EdwardsPoint,\n>)\n// The compressed point must have a valid sign bit. This is automatically\n// satisfied for points produced by `compress()`. For externally-sourced\n// bytes (e.g., from network input), callers must ensure this invariant.\n//\n// See `compressed_y_has_valid_sign_bit` in `edwards_specs.rs` for full justification.\n\n    requires\n        compressed_y_has_valid_sign_bit(&self.0),\n    ensures\n// Decompression succeeds iff the y-coordinate is valid\n\n        math_is_valid_y_coordinate(field_element_from_bytes(&self.0))\n            <==> result.is_some(),\n        // When successful, the result has these properties:\n        result.is_some() ==> (\n        // The Y coordinate matches the one from the compressed representation\n        fe51_as_canonical_nat(&result.unwrap().Y) == field_element_from_bytes(\n            &self.0,\n        )\n        // The point is valid on the Edwards curve\n         && is_valid_edwards_point(\n            result.unwrap(),\n        )\n        // The X coordinate sign bit matches the sign bit from the compressed representation\n         && fe51_as_canonical_nat_sign_bit(&result.unwrap().X) == (self.0[31] >> 7)),",
            "requires": [
                "compressed_y_has_valid_sign_bit(&self.0),"
            ],
            "ensures": [
                "math_is_valid_y_coordinate(field_element_from_bytes(&self.0)) <==> result.is_some(),",
                "result.is_some() ==> ( fe51_as_canonical_nat(&result.unwrap().Y) == field_element_from_bytes( &self.0,",
                ") && is_valid_edwards_point( result.unwrap(),",
                ") && fe51_as_canonical_nat_sign_bit(&result.unwrap().X) == (self.0[31] >> 7)),"
            ],
            "referenced_specs": [
                "compressed_y_has_valid_sign_bit",
                "is_valid_edwards_point",
                "math_is_valid_y_coordinate",
                "fe51_as_canonical_nat",
                "field_element_from_bytes",
                "fe51_as_canonical_nat_sign_bit"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 275,
            "module": "edwards",
            "doc_comment": "Attempt to decompress to an `EdwardsPoint`.\n\nReturns `None` if the input is not the \\\\(y\\\\)-coordinate of a\ncurve point.\n",
            "math_interpretation": "[u8; 32] -> Option<P in E(F_p)>",
            "informal_interpretation": "Decompresses a 32-byte encoding to an Edwards point (if valid).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L275",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__decompress"
        },
        {
            "name": "identity",
            "display_name": "CompressedEdwardsY::identity",
            "impl_type": "CompressedEdwardsY",
            "contract": "fn identity() -> (result: CompressedEdwardsY)\n    ensures\n// Identity point has y = 1 and sign bit = 0\n\n        field_element_from_bytes(&result.0) == 1,\n        (result.0[31] >> 7) == 0,",
            "requires": [],
            "ensures": [
                "field_element_from_bytes(&result.0) == 1,",
                "(result.0[31] >> 7) == 0,"
            ],
            "referenced_specs": [
                "field_element_from_bytes"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 749,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L749",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__identity"
        },
        {
            "name": "to_bytes",
            "display_name": "CompressedEdwardsY::to_bytes",
            "impl_type": "CompressedEdwardsY",
            "contract": "pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,",
            "requires": [],
            "ensures": [
                "result == self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 263,
            "module": "edwards",
            "doc_comment": "Copy this `CompressedEdwardsY` to an array of bytes.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L263",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__to_bytes"
        },
        {
            "name": "zeroize",
            "display_name": "CompressedEdwardsY::zeroize",
            "impl_type": "CompressedEdwardsY",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        self.0[0]\n            == 1u8,\n// VERIFICATION NOTE: this \"zeroize\" leaves one bit equal to 1",
            "requires": [],
            "ensures": [
                "forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,",
                "self.0[0] == 1u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 958,
            "module": "edwards",
            "doc_comment": "Reset this `CompressedEdwardsY` to the compressed form of the identity element.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L958",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "compressededwardsy__zeroize"
        },
        {
            "name": "basepoint",
            "display_name": "EdwardsBasepointTable::basepoint",
            "impl_type": "EdwardsBasepointTable",
            "contract": "fn basepoint(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result),\n        // The result is the Ed25519 basepoint B\n        edwards_point_as_affine(result) == spec_ed25519_basepoint(),",
            "requires": [
                "is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == spec_ed25519_basepoint(),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3100,
            "module": "edwards",
            "doc_comment": "Get the basepoint for this table as an `EdwardsPoint`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3100",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardsbasepointtable__basepoint"
        },
        {
            "name": "create",
            "display_name": "EdwardsBasepointTable::create",
            "impl_type": "EdwardsBasepointTable",
            "contract": "fn create(basepoint: &EdwardsPoint) -> (result: EdwardsBasepointTable)\n    requires\n        is_well_formed_edwards_point(*basepoint),\n    ensures\n        is_valid_edwards_basepoint_table(result, edwards_point_as_affine(*basepoint)),",
            "requires": [
                "is_well_formed_edwards_point(*basepoint),"
            ],
            "ensures": [
                "is_valid_edwards_basepoint_table(result, edwards_point_as_affine(*basepoint)),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2992,
            "module": "edwards",
            "doc_comment": "Create a table of precomputed multiples of `basepoint`.\n\nConstructs 32 LookupTables where table.0[i] = [1·(16²)^i·B, ..., 8·(16²)^i·B]",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2992",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardsbasepointtable__create"
        },
        {
            "name": "mul_base",
            "display_name": "EdwardsBasepointTable::mul_base",
            "impl_type": "EdwardsBasepointTable",
            "contract": "fn mul_base(&self, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n        scalar.bytes[31] <= 127,\n        is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,",
                "is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( spec_ed25519_basepoint(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3229,
            "module": "edwards",
            "doc_comment": "The computation uses Pippenger's algorithm, as described for the\nspecific case of radix-16 on page 13 of the Ed25519 paper.\n\n# Pippenger's Algorithm Generalised\n\nWrite the scalar \\\\(a\\\\) in radix-\\\\(w\\\\), where \\\\(w\\\\) is a power of\n2, with coefficients in \\\\([\\frac{-w}{2},\\frac{w}{2})\\\\), i.e.,\n$$\na = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},\n$$\nwith\n$$\n\\begin{aligned}\n\\frac{-w}{2} \\leq a_i < \\frac{w}{2}\n&&\\cdots&&\n\\frac{-w}{2} \\leq a\\_{x} \\leq \\frac{w}{2}\n\\end{aligned}\n$$\nand the number of additions, \\\\(x\\\\), is given by\n\\\\(x = \\lceil \\frac{256}{w} \\rceil\\\\). Then\n$$\na B = a\\_0 B + a\\_1 w\\^1 B + \\cdots + a\\_{x-1} w\\^{x-1} B.\n$$\nGrouping even and odd coefficients gives\n$$\n\\begin{aligned}\na B = \\quad a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B    \\\\\\\\\n+ a\\_1 w\\^1 B +& a\\_3 w\\^3 B + \\cdots + a\\_{x-1} w\\^{x-1} B    \\\\\\\\\n= \\quad(a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B)   \\\\\\\\\n+ w(a\\_1 w\\^0 B +& a\\_3 w\\^2 B + \\cdots + a\\_{x-1} w\\^{x-2} B).  \\\\\\\\\n\\end{aligned}\n$$\nFor each \\\\(i = 0 \\ldots 31\\\\), we create a lookup table of\n$$\n[w\\^{2i} B, \\ldots, \\frac{w}{2}\\cdot w\\^{2i} B],\n$$\nand use it to select \\\\( y \\cdot w\\^{2i} \\cdot B \\\\) in constant time.\n\nThe radix-\\\\(w\\\\) representation requires that the scalar is bounded\nby \\\\(2\\^{255}\\\\), which is always the case.\n\nThe above algorithm is trivially generalised to other powers-of-2 radices.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3229",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardsbasepointtable__mul_base"
        },
        {
            "name": "add",
            "display_name": "EdwardsPoint::add",
            "impl_type": "EdwardsPoint",
            "contract": "fn add(self, other: &'b EdwardsPoint) -> (result:\n    EdwardsPoint)/* requires clause in AddSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n        is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: affine addition law\n        ({\n            let (x1, y1) = edwards_point_as_affine(*self);\n            let (x2, y2) = edwards_point_as_affine(*other);\n            edwards_point_as_affine(result) == edwards_add(x1, y1, x2, y2)\n        }),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "({ let (x1, y1) = edwards_point_as_affine(*self); let (x2, y2) = edwards_point_as_affine(*other); edwards_point_as_affine(result) == edwards_add(x1, y1, x2, y2) }),"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1913,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1913",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__add_L1913"
        },
        {
            "name": "add_assign",
            "display_name": "EdwardsPoint::add_assign",
            "impl_type": "EdwardsPoint",
            "contract": "fn add_assign(&mut self, _rhs: &'b EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*old(self)),\n        is_well_formed_edwards_point(*_rhs),\n    ensures\n        is_well_formed_edwards_point(*self),\n        // Semantic correctness: result is the addition of old(self) + rhs\n        ({\n            let (x1, y1) = edwards_point_as_affine(*old(self));\n            let (x2, y2) = edwards_point_as_affine(*_rhs);\n            edwards_point_as_affine(*self) == edwards_add(x1, y1, x2, y2)\n        }),",
            "requires": [
                "is_well_formed_edwards_point(*old(self)),",
                "is_well_formed_edwards_point(*_rhs),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(*self),",
                "({ let (x1, y1) = edwards_point_as_affine(*old(self)); let (x2, y2) = edwards_point_as_affine(*_rhs); edwards_point_as_affine(*self) == edwards_add(x1, y1, x2, y2) }),"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2014,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2014",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__add_assign"
        },
        {
            "name": "as_affine_niels",
            "display_name": "EdwardsPoint::as_affine_niels",
            "impl_type": "EdwardsPoint",
            "contract": "pub(crate) fn as_affine_niels(&self) -> (result: AffineNielsPoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n    ensures\n        affine_niels_corresponds_to_edwards(result, *self),",
            "requires": [
                "edwards_point_limbs_bounded(*self),"
            ],
            "ensures": [
                "affine_niels_corresponds_to_edwards(result, *self),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1379,
            "module": "edwards",
            "doc_comment": "Dehomogenize to a AffineNielsPoint.\nMainly for testing.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1379",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__as_affine_niels"
        },
        {
            "name": "as_projective",
            "display_name": "EdwardsPoint::as_projective",
            "impl_type": "EdwardsPoint",
            "contract": "pub(crate) const fn as_projective(&self) -> (result: ProjectivePoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n    ensures\n        result.X == self.X,\n        result.Y == self.Y,\n        result.Z == self.Z,\n        // ProjectivePoint invariant: 52-bounded (from EdwardsPoint invariant)\n        fe51_limbs_bounded(&result.X, 52) && fe51_limbs_bounded(&result.Y, 52)\n            && fe51_limbs_bounded(&result.Z, 52),",
            "requires": [
                "edwards_point_limbs_bounded(*self),"
            ],
            "ensures": [
                "result.X == self.X,",
                "result.Y == self.Y,",
                "result.Z == self.Z,",
                "fe51_limbs_bounded(&result.X, 52) && fe51_limbs_bounded(&result.Y, 52) && fe51_limbs_bounded(&result.Z, 52),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1362,
            "module": "edwards",
            "doc_comment": "Convert the representation of this point from extended\ncoordinates to projective coordinates.\n\nFree.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1362",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__as_projective"
        },
        {
            "name": "as_projective_niels",
            "display_name": "EdwardsPoint::as_projective_niels",
            "impl_type": "EdwardsPoint",
            "contract": "pub(crate) fn as_projective_niels(&self) -> (result: ProjectiveNielsPoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n        sum_of_limbs_bounded(&self.Y, &self.X, u64::MAX),\n    ensures\n        projective_niels_corresponds_to_edwards(result, *self),\n        fe51_limbs_bounded(&result.Y_plus_X, 54),\n        fe51_limbs_bounded(&result.Y_minus_X, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T2d, 54),",
            "requires": [
                "edwards_point_limbs_bounded(*self),",
                "sum_of_limbs_bounded(&self.Y, &self.X, u64::MAX),"
            ],
            "ensures": [
                "projective_niels_corresponds_to_edwards(result, *self),",
                "fe51_limbs_bounded(&result.Y_plus_X, 54),",
                "fe51_limbs_bounded(&result.Y_minus_X, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T2d, 54),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1258,
            "module": "edwards",
            "doc_comment": "Convert to a ProjectiveNielsPoint",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1258",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__as_projective_niels"
        },
        {
            "name": "compress",
            "display_name": "EdwardsPoint::compress",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn compress(&self) -> (result: CompressedEdwardsY)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n        compressed_edwards_y_corresponds_to_edwards(result, *self),",
            "requires": [
                "is_well_formed_edwards_point(*self),"
            ],
            "ensures": [
                "compressed_edwards_y_corresponds_to_edwards(result, *self),"
            ],
            "referenced_specs": [
                "compressed_edwards_y_corresponds_to_edwards",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1599,
            "module": "edwards",
            "doc_comment": "Compress this point to `CompressedEdwardsY` format.",
            "math_interpretation": "P in E(F_p) -> CompressedEdwardsY",
            "informal_interpretation": "Compresses an Edwards point to its canonical 32-byte encoding.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1599",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__compress"
        },
        {
            "name": "conditional_select",
            "display_name": "EdwardsPoint::conditional_select",
            "impl_type": "EdwardsPoint",
            "contract": "fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> (result:\n    EdwardsPoint)\n    ensures\n// If choice is false (0), return a\n\n        !choice_is_true(choice) ==> result == *a,\n        // If choice is true (1), return b\n        choice_is_true(choice) ==> result == *b,\n        // Well-formedness is preserved by selection\n        is_well_formed_edwards_point(*a) && is_well_formed_edwards_point(*b)\n            ==> is_well_formed_edwards_point(result),",
            "requires": [],
            "ensures": [
                "!choice_is_true(choice) ==> result == *a,",
                "choice_is_true(choice) ==> result == *b,",
                "is_well_formed_edwards_point(*a) && is_well_formed_edwards_point(*b) ==> is_well_formed_edwards_point(result),"
            ],
            "referenced_specs": [
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1092,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1092",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__conditional_select"
        },
        {
            "name": "ct_eq",
            "display_name": "EdwardsPoint::ct_eq",
            "impl_type": "EdwardsPoint",
            "contract": "fn ct_eq(&self, other: &EdwardsPoint) -> (result:\n    Choice)/* VERIFICATION NOTE: we cannot add a \"requires\" clause to ct_eq with ConstantTimeEqSpecImpl,\n        unlike for Add trait implementations through AddSpecImpl.\n    */\n// requires self.ct_eq_req(other),\n\n    ensures\n// Two points are equal if they represent the same affine point:\n// (X/Z, Y/Z) == (X'/Z', Y'/Z')\n// This is checked by verifying X*Z' == X'*Z and Y*Z' == Y'*Z\n\n        choice_is_true(result) == (edwards_point_as_affine(*self) == edwards_point_as_affine(\n            *other,\n        )),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (edwards_point_as_affine(*self) == edwards_point_as_affine( *other,",
                ")),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1152,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1152",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__ct_eq"
        },
        {
            "name": "double",
            "display_name": "EdwardsPoint::double",
            "impl_type": "EdwardsPoint",
            "contract": "pub(crate) fn double(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_edwards_point(*self),  // self is a valid extended Edwards point\n        edwards_point_limbs_bounded(*self),\n    ensures\n        is_valid_edwards_point(result),  // result is also a valid Edwards point\n        // Result equals the affine doubling of the input.\n        edwards_point_as_affine(result) == edwards_double(\n            edwards_point_as_affine(*self).0,\n            edwards_point_as_affine(*self).1,\n        ),",
            "requires": [
                "is_valid_edwards_point(*self),  // self is a valid extended Edwards point edwards_point_limbs_bounded(*self),"
            ],
            "ensures": [
                "is_valid_edwards_point(result),  // result is also a valid Edwards point edwards_point_as_affine(result) == edwards_double( edwards_point_as_affine(*self).0,",
                "edwards_point_as_affine(*self).1,",
                "),"
            ],
            "referenced_specs": [
                "edwards_double",
                "edwards_point_as_affine",
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1841,
            "module": "edwards",
            "doc_comment": "Add this point to itself.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1841",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__double"
        },
        {
            "name": "identity",
            "display_name": "EdwardsPoint::identity",
            "impl_type": "EdwardsPoint",
            "contract": "fn identity() -> (result: EdwardsPoint)\n    ensures\n        is_identity_edwards_point(result),\n        is_well_formed_edwards_point(result),",
            "requires": [],
            "ensures": [
                "is_identity_edwards_point(result),",
                "is_well_formed_edwards_point(result),"
            ],
            "referenced_specs": [
                "is_identity_edwards_point",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 886,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L886",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__identity"
        },
        {
            "name": "is_small_order",
            "display_name": "EdwardsPoint::is_small_order",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn is_small_order(&self) -> (result: bool)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n// A point has small order iff [8]P = O (identity)\n\n        result == (edwards_scalar_mul(edwards_point_as_affine(*self), 8)\n            == math_edwards_identity()),",
            "requires": [
                "is_well_formed_edwards_point(*self),"
            ],
            "ensures": [
                "result == (edwards_scalar_mul(edwards_point_as_affine(*self), 8) == math_edwards_identity()),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "math_edwards_identity"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3727,
            "module": "edwards",
            "doc_comment": "Determine if this point is of small order.\n\n# Return\n\n* `true` if `self` is in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\);\n* `false` if `self` is not in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\).\n\n# Example\n\n```\nuse curve25519_dalek::constants;\n\n// Generator of the prime-order subgroup\nlet P = constants::ED25519_BASEPOINT_POINT;\n// Generator of the torsion subgroup\nlet Q = constants::EIGHT_TORSION[1];\n\n// P has large order\nassert_eq!(P.is_small_order(), false);\n\n// Q has small order\nassert_eq!(Q.is_small_order(), true);\n```",
            "math_interpretation": "P in E[8]? (8-torsion test)",
            "informal_interpretation": "Checks whether a point has small order (lies in the torsion subgroup).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3727",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__is_small_order"
        },
        {
            "name": "is_torsion_free",
            "display_name": "EdwardsPoint::is_torsion_free",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn is_torsion_free(&self) -> (result: bool)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n// A point is torsion-free iff [ℓ]P = O, where ℓ is the group order\n\n        result == (edwards_scalar_mul(edwards_point_as_affine(*self), group_order())\n            == math_edwards_identity()),",
            "requires": [
                "is_well_formed_edwards_point(*self),"
            ],
            "ensures": [
                "result == (edwards_scalar_mul(edwards_point_as_affine(*self), group_order()) == math_edwards_identity()),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "group_order",
                "is_well_formed_edwards_point",
                "math_edwards_identity"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3774,
            "module": "edwards",
            "doc_comment": "Determine if this point is \"torsion-free\", i.e., is contained in\nthe prime-order subgroup.\n\n# Return\n\n* `true` if `self` has zero torsion component and is in the\nprime-order subgroup;\n* `false` if `self` has a nonzero torsion component and is not\nin the prime-order subgroup.\n\n# Example\n\n```\nuse curve25519_dalek::constants;\n\n// Generator of the prime-order subgroup\nlet P = constants::ED25519_BASEPOINT_POINT;\n// Generator of the torsion subgroup\nlet Q = constants::EIGHT_TORSION[1];\n\n// P is torsion-free\nassert_eq!(P.is_torsion_free(), true);\n\n// P + Q is not torsion-free\nassert_eq!((P+Q).is_torsion_free(), false);\n```",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3774",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__is_torsion_free"
        },
        {
            "name": "is_valid",
            "display_name": "EdwardsPoint::is_valid",
            "impl_type": "EdwardsPoint",
            "contract": "fn is_valid(&self) -> (result: bool)\n    requires\n        edwards_point_limbs_bounded(*self),\n        fe51_as_canonical_nat(&self.Z) != 0,\n    ensures\n        result == is_valid_edwards_point(*self),",
            "requires": [
                "edwards_point_limbs_bounded(*self),",
                "fe51_as_canonical_nat(&self.Z) != 0,"
            ],
            "ensures": [
                "result == is_valid_edwards_point(*self),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 996,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L996",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__is_valid"
        },
        {
            "name": "mul",
            "display_name": "EdwardsPoint::mul",
            "impl_type": "EdwardsPoint",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    EdwardsPoint)/* requires clause in MulSpecImpl<&Scalar> for &EdwardsPoint in arithm_trait_specs.rs:\n        requires rhs.bytes[31] <= 127 && is_well_formed_edwards_point(*self)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(*self),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2466,
            "module": "edwards",
            "doc_comment": "Scalar multiplication: compute `scalar * self`.\n\nFor scalar multiplication of a basepoint,\n`EdwardsBasepointTable` is approximately 4x faster.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2466",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul"
        },
        {
            "name": "mul_assign",
            "display_name": "EdwardsPoint::mul_assign",
            "impl_type": "EdwardsPoint",
            "contract": "fn mul_assign(&mut self, scalar: &'b Scalar)\n    requires\n        scalar.bytes[31] <= 127,\n        is_well_formed_edwards_point(*old(self)),\n    ensures\n        is_well_formed_edwards_point(*self),\n        edwards_point_as_affine(*self) == edwards_scalar_mul(\n            edwards_point_as_affine(*old(self)),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,",
                "is_well_formed_edwards_point(*old(self)),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(*self),",
                "edwards_point_as_affine(*self) == edwards_scalar_mul( edwards_point_as_affine(*old(self)),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2433,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2433",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_assign"
        },
        {
            "name": "mul_base",
            "display_name": "EdwardsPoint::mul_base",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [scalar] * B where B is the basepoint\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( spec_ed25519_basepoint(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2510,
            "module": "edwards",
            "doc_comment": "Fixed-base scalar multiplication by the Ed25519 base point.\n\nUses precomputed basepoint tables when the `precomputed-tables` feature\nis enabled, trading off increased code size for ~4x better performance.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2510",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_base"
        },
        {
            "name": "mul_base_clamped",
            "display_name": "EdwardsPoint::mul_base_clamped",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [clamped_scalar] * B where B is the basepoint\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( spec_ed25519_basepoint(),",
                "scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }), ),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_clamp_integer",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2569,
            "module": "edwards",
            "doc_comment": "Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2569",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_base_clamped"
        },
        {
            "name": "mul_by_cofactor",
            "display_name": "EdwardsPoint::mul_by_cofactor",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn mul_by_cofactor(&self) -> (result: EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [8]P\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            8,\n        ),",
            "requires": [
                "is_well_formed_edwards_point(*self),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(*self),",
                "8,",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3604,
            "module": "edwards",
            "doc_comment": "Multiply by the cofactor: return \\\\(\\[8\\]P\\\\).",
            "math_interpretation": "P -> [8]P (cofactor clearing)",
            "informal_interpretation": "Multiplies a point by the cofactor (8) to clear the torsion component.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3604",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_by_cofactor"
        },
        {
            "name": "mul_by_pow_2",
            "display_name": "EdwardsPoint::mul_by_pow_2",
            "impl_type": "EdwardsPoint",
            "contract": "pub(crate) fn mul_by_pow_2(&self, k: u32) -> (result: EdwardsPoint)\n    requires\n        k > 0,\n        is_well_formed_edwards_point(*self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [2^k]P\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            pow2(k as nat),\n        ),",
            "requires": [
                "k > 0,",
                "is_well_formed_edwards_point(*self),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(*self),",
                "pow2(k as nat),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 3628,
            "module": "edwards",
            "doc_comment": "Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3628",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_by_pow_2"
        },
        {
            "name": "mul_clamped",
            "display_name": "EdwardsPoint::mul_clamped",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n    requires\n        is_well_formed_edwards_point(self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Result is scalar multiplication of self by the clamped scalar\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(self),\n            scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),",
            "requires": [
                "is_well_formed_edwards_point(self),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(self),",
                "scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }), ),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_clamp_integer"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2534,
            "module": "edwards",
            "doc_comment": "Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2534",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__mul_clamped"
        },
        {
            "name": "multiscalar_mul_verus",
            "display_name": "EdwardsPoint::multiscalar_mul_verus",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result: EdwardsPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<EdwardsPoint>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = P> + Clone,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>(\n            points,\n        ).len(),\n        // All input points must be well-formed\n        forall|i: int|\n            0 <= i < spec_points_from_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_points_from_iter::<P, J>(points)[i],\n            ),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        edwards_point_as_affine(result) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_points_from_iter::<P, J>(points),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>( points,",
                ").len(),",
                "forall|i: int| 0 <= i < spec_points_from_iter::<P, J>(points).len() ==> is_well_formed_edwards_point( #[trigger] spec_points_from_iter::<P, J>(points)[i],",
                "),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "spec_points_from_iter::<P, J>(points),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2858,
            "module": "edwards",
            "doc_comment": "Verus-compatible version of multiscalar_mul (constant-time).\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nDispatches to Straus algorithm (constant-time).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2858",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__multiscalar_mul_verus"
        },
        {
            "name": "neg",
            "display_name": "EdwardsPoint::neg",
            "impl_type": "EdwardsPoint",
            "contract": "fn neg(self) -> (result:\n    EdwardsPoint)\n// requires clause in NegSpecImpl for &EdwardsPoint above:\n//   is_well_formed_edwards_point(*self)\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(*self)),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(*self)),"
            ],
            "referenced_specs": [
                "edwards_neg",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2306,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "P -> -P in E(F_p)",
            "informal_interpretation": "Negates an Edwards point (group inverse).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2306",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__neg_L2306"
        },
        {
            "name": "neg",
            "display_name": "EdwardsPoint::neg",
            "impl_type": "EdwardsPoint",
            "contract": "fn neg(self) -> (result:\n    EdwardsPoint)\n// requires clause in NegSpecImpl for EdwardsPoint above:\n//   fe51_limbs_bounded(&self.X, 52) && fe51_limbs_bounded(&self.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(self)),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(self)),"
            ],
            "referenced_specs": [
                "edwards_neg",
                "edwards_point_as_affine",
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2411,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "P -> -P in E(F_p)",
            "informal_interpretation": "Negates an Edwards point (group inverse).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2411",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__neg_L2411"
        },
        {
            "name": "nonspec_map_to_curve_verus",
            "display_name": "EdwardsPoint::nonspec_map_to_curve_verus",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn nonspec_map_to_curve_verus(bytes: &[u8]) -> (result: EdwardsPoint)\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = spec applied to first 32 bytes of SHA-512(input)\n        edwards_point_as_affine(result) == spec_nonspec_map_to_curve(\n            spec_sha512(bytes@).subrange(0, 32),\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == spec_nonspec_map_to_curve( spec_sha512(bytes@).subrange(0, 32),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1753,
            "module": "edwards",
            "doc_comment": "VERIFICATION NOTE: Verus-compatible version of nonspec_map_to_curve that uses SHA-512 instead of Digest.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1753",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "edwardspoint__nonspec_map_to_curve_verus"
        },
        {
            "name": "optional_multiscalar_mul_verus",
            "display_name": "EdwardsPoint::optional_multiscalar_mul_verus",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where\n    S: Borrow<Scalar>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = Option<EdwardsPoint>> + Clone,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some if and only if all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>( points,",
                ").len(),",
                "forall|i: int| 0 <= i < spec_optional_points_from_iter::<J>(points).len() && ( #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some() ==> is_well_formed_edwards_point( spec_optional_points_from_iter::<J>(points)[i].unwrap(),",
                "),"
            ],
            "ensures": [
                "result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),",
                "result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),",
                "result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "unwrap_points(spec_optional_points_from_iter::<J>(points)),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2777,
            "module": "edwards",
            "doc_comment": "Verus-compatible version of optional_multiscalar_mul.\nUses Iterator + Clone instead of IntoIterator (Verus doesn't support I::Item projections).\nClone allows peeking at size without consuming the iterator (similar to original's size_hint).\nDispatches to Straus (size < 190) or Pippenger (size >= 190) algorithm.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2777",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__optional_multiscalar_mul_verus"
        },
        {
            "name": "sub",
            "display_name": "EdwardsPoint::sub",
            "impl_type": "EdwardsPoint",
            "contract": "fn sub(self, other: &'b EdwardsPoint) -> (result:\n    EdwardsPoint)/* requires clause in SubSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n        is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: affine subtraction law\n        ({\n            let (x1, y1) = edwards_point_as_affine(*self);\n            let (x2, y2) = edwards_point_as_affine(*other);\n            edwards_point_as_affine(result) == edwards_sub(x1, y1, x2, y2)\n        }),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "({ let (x1, y1) = edwards_point_as_affine(*self); let (x2, y2) = edwards_point_as_affine(*other); edwards_point_as_affine(result) == edwards_sub(x1, y1, x2, y2) }),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2057,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2057",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__sub_L2057"
        },
        {
            "name": "sub_assign",
            "display_name": "EdwardsPoint::sub_assign",
            "impl_type": "EdwardsPoint",
            "contract": "fn sub_assign(&mut self, _rhs: &'b EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*old(self)),\n        is_well_formed_edwards_point(*_rhs),\n    ensures\n        is_well_formed_edwards_point(*self),\n        // Semantic correctness: result is the subtraction of old(self) - rhs\n        ({\n            let (x1, y1) = edwards_point_as_affine(*old(self));\n            let (x2, y2) = edwards_point_as_affine(*_rhs);\n            edwards_point_as_affine(*self) == edwards_sub(x1, y1, x2, y2)\n        }),",
            "requires": [
                "is_well_formed_edwards_point(*old(self)),",
                "is_well_formed_edwards_point(*_rhs),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(*self),",
                "({ let (x1, y1) = edwards_point_as_affine(*old(self)); let (x2, y2) = edwards_point_as_affine(*_rhs); edwards_point_as_affine(*self) == edwards_sub(x1, y1, x2, y2) }),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2152,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2152",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__sub_assign"
        },
        {
            "name": "sum",
            "display_name": "EdwardsPoint::sum",
            "impl_type": "EdwardsPoint",
            "contract": "fn sum<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,",
            "requires": [],
            "ensures": [],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2231,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2264",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__sum"
        },
        {
            "name": "to_montgomery",
            "display_name": "EdwardsPoint::to_montgomery",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn to_montgomery(&self) -> (result: MontgomeryPoint)\n    requires\n        is_valid_edwards_point(*self),  // Gives us z != 0 for birational map\n        fe51_limbs_bounded(&self.X, 54),\n        // Y and Z need 51-bit bounds so U = Z + Y is 52-bit bounded (< 54 for mul)\n        fe51_limbs_bounded(&self.Y, 51) && fe51_limbs_bounded(&self.Z, 51),\n        sum_of_limbs_bounded(&self.Z, &self.Y, u64::MAX),\n    ensures\n        montgomery_corresponds_to_edwards(result, *self),",
            "requires": [
                "is_valid_edwards_point(*self),  // Gives us z != 0 for birational map fe51_limbs_bounded(&self.X, 54),",
                "fe51_limbs_bounded(&self.Y, 51) && fe51_limbs_bounded(&self.Z, 51),",
                "sum_of_limbs_bounded(&self.Z, &self.Y, u64::MAX),"
            ],
            "ensures": [
                "montgomery_corresponds_to_edwards(result, *self),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "montgomery_corresponds_to_edwards",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 1456,
            "module": "edwards",
            "doc_comment": "Convert this `EdwardsPoint` on the Edwards model to the\ncorresponding `MontgomeryPoint` on the Montgomery model.\n\nThis function has one exceptional case; the identity point of\nthe Edwards curve is sent to the 2-torsion point \\\\((0,0)\\\\)\non the Montgomery curve.\n\nNote that this is a one-way conversion, since the Montgomery\nmodel does not retain sign information.",
            "math_interpretation": "u = (1+y)/(1-y), birational map E -> M",
            "informal_interpretation": "Converts an Edwards point to its Montgomery u-coordinate.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1456",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__to_montgomery"
        },
        {
            "name": "vartime_double_scalar_mul_basepoint",
            "display_name": "EdwardsPoint::vartime_double_scalar_mul_basepoint",
            "impl_type": "EdwardsPoint",
            "contract": "pub fn vartime_double_scalar_mul_basepoint(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> (result:\n    EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*A),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = a*A + b*B where B is the Ed25519 basepoint\n        edwards_point_as_affine(result) == {\n            let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_as_nat(a));\n            let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_as_nat(b));\n            edwards_add(aA.0, aA.1, bB.0, bB.1)\n        },",
            "requires": [
                "is_well_formed_edwards_point(*A),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == { let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_as_nat(a)); let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_as_nat(b)); edwards_add(aA.0, aA.1, bB.0, bB.1) },"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ed25519_basepoint"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2731,
            "module": "edwards",
            "doc_comment": "Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.",
            "math_interpretation": "(a,A,b) -> [a]A + [b]B, B = Ed25519 basepoint",
            "informal_interpretation": "Computes a double scalar multiplication with the basepoint (variable-time).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2731",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__vartime_double_scalar_mul_basepoint"
        },
        {
            "name": "zeroize",
            "display_name": "EdwardsPoint::zeroize",
            "impl_type": "EdwardsPoint",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        self.0[0]\n            == 1u8,\n// VERIFICATION NOTE: this \"zeroize\" leaves one bit equal to 1",
            "requires": [],
            "ensures": [
                "forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,",
                "self.0[0] == 1u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 958,
            "module": "edwards",
            "doc_comment": "Reset this `CompressedEdwardsY` to the compressed form of the identity element.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L978",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwardspoint__zeroize"
        },
        {
            "name": "mul",
            "display_name": "Scalar::mul",
            "impl_type": "Scalar",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    EdwardsPoint)/* requires clause in MulSpecImpl<&Scalar> for &EdwardsPoint in arithm_trait_specs.rs:\n        requires rhs.bytes[31] <= 127 && is_well_formed_edwards_point(*self)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result),",
                "edwards_point_as_affine(result) == edwards_scalar_mul( edwards_point_as_affine(*self),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 2466,
            "module": "edwards",
            "doc_comment": "Scalar multiplication: compute `scalar * self`.\n\nFor scalar multiplication of a basepoint,\n`EdwardsBasepointTable` is approximately 4x faster.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2489",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_L2466"
        },
        {
            "name": "step_1",
            "display_name": "step_1",
            "impl_type": "",
            "contract": "pub(super) fn step_1(repr: &CompressedEdwardsY) -> (result: (\n    Choice,\n    FieldElement,\n    FieldElement,\n    FieldElement,\n))  // Result components: (is_valid, X, Y, Z)\n    ensures\n// The returned Y field element matches the one extracted from the compressed representation\n\n        ({\n            let (is_valid, X, Y, Z) = result;\n            fe51_as_canonical_nat(&Y) == field_element_from_bytes(&repr.0)\n                &&\n            // The returned Z field element is 1\n            fe51_as_canonical_nat(&Z) == 1\n                &&\n            // The choice is true iff the Y is valid and (X, Y) is on the curve\n            (choice_is_true(is_valid) <==> math_is_valid_y_coordinate(fe51_as_canonical_nat(&Y)))\n                && (choice_is_true(is_valid) ==> math_on_edwards_curve(\n                fe51_as_canonical_nat(&X),\n                fe51_as_canonical_nat(&Y),\n            )) &&\n            // Limb bounds for step_2\n            // X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n            fe51_limbs_bounded(&X, 52) && fe51_limbs_bounded(&Y, 51) && fe51_limbs_bounded(\n                &Z,\n                51,\n            )\n                &&\n            // X is the non-negative root (LSB = 0) - from sqrt_ratio_i\n            // This is needed in the proof of decompress\n            fe51_as_canonical_nat(&X) % 2 == 0\n        }),",
            "requires": [],
            "ensures": [
                "({ let (is_valid, X, Y, Z) = result; fe51_as_canonical_nat(&Y) == field_element_from_bytes(&repr.0) && // The returned Z field element is 1 fe51_as_canonical_nat(&Z) == 1 && // The choice is true iff the Y is valid and (X, Y) is on the curve (choice_is_true(is_valid) <==> math_is_valid_y_coordinate(fe51_as_canonical_nat(&Y))) && (choice_is_true(is_valid) ==> math_on_edwards_curve( fe51_as_canonical_nat(&X), fe51_as_canonical_nat(&Y), )) && // Limb bounds for step_2 // X is 52-bit bounded from sqrt_ratio_i (relaxed from 51) fe51_limbs_bounded(&X, 52) && fe51_limbs_bounded(&Y, 51) && fe51_limbs_bounded( &Z, 51, ) && // X is the non-negative root (LSB = 0) - from sqrt_ratio_i // This is needed in the proof of decompress fe51_as_canonical_nat(&X) % 2 == 0 }),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "math_is_valid_y_coordinate",
                "fe51_as_canonical_nat",
                "field_element_from_bytes"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 350,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L350",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwards__step_1"
        },
        {
            "name": "step_2",
            "display_name": "step_2",
            "impl_type": "",
            "contract": "pub(super) fn step_2(\n    repr: &CompressedEdwardsY,\n    mut X: FieldElement,\n    Y: FieldElement,\n    Z: FieldElement,\n) -> (result: EdwardsPoint)\n    requires\n// Limb bounds for inputs (X from sqrt_ratio_i, Y from from_bytes, Z = ONE)\n// X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n\n        fe51_limbs_bounded(&X, 52),\n        fe51_limbs_bounded(&Y, 51),\n        fe51_limbs_bounded(&Z, 51),\n    ensures\n        fe51_as_canonical_nat(&result.X)\n            ==\n        // If the sign bit is 1, negate the X field element\n        if (repr.0[31] >> 7) == 1 {\n            field_neg(fe51_as_canonical_nat(&X))\n        } else {\n            fe51_as_canonical_nat(&X)\n        },\n        // Y and Z are unchanged\n        &result.Y == &Y && &result.Z == &Z\n            &&\n        // X is conditionally negated based on the sign bit\n        // T = X * Y (after conditional negation)\n        fe51_as_canonical_nat(&result.T) == field_mul(\n            fe51_as_canonical_nat(&result.X),\n            fe51_as_canonical_nat(&result.Y),\n        ),",
            "requires": [
                "fe51_limbs_bounded(&X, 52),",
                "fe51_limbs_bounded(&Y, 51),",
                "fe51_limbs_bounded(&Z, 51),"
            ],
            "ensures": [
                "fe51_as_canonical_nat(&result.X) == if (repr.0[31] >> 7) == 1 { field_neg(fe51_as_canonical_nat(&X)) } else { fe51_as_canonical_nat(&X) }, &result.Y == &Y && &result.Z == &Z && fe51_as_canonical_nat(&result.T) == field_mul( fe51_as_canonical_nat(&result.X),",
                "fe51_as_canonical_nat(&result.Y),",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_mul",
                "field_neg",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/edwards.rs",
            "line": 505,
            "module": "edwards",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L505",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "edwards__step_2"
        },
        {
            "name": "batch_invert",
            "display_name": "FieldElement::batch_invert",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn batch_invert(\n    inputs: &mut [FieldElement],\n)/* <VERIFICATION NOTE>\n - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n - Choice type operations handled by wrappers in subtle_assumes.rs\n - PROOF BYPASSES because of trait issues and proof obligations.\n</VERIFICATION NOTE> */\n\n    requires\n        forall|i: int|\n            #![trigger old(inputs)[i]]\n            0 <= i < old(inputs).len() ==> fe51_limbs_bounded(&old(inputs)[i], 54),\n    ensures\n// Each element is replaced appropriately:\n\n        forall|i: int|\n            #![auto]\n            0 <= i < inputs.len() ==> (\n            // If input was non-zero, it's replaced with its inverse\n            ((fe51_as_canonical_nat(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                &old(inputs)[i],\n                &inputs[i],\n            )) &&\n            // If input was zero, it remains zero\n            ((fe51_as_canonical_nat(&old(inputs)[i]) == 0) ==> fe51_as_canonical_nat(&inputs[i])\n                == 0)),",
            "requires": [
                "forall|i: int| #![trigger old(inputs)[i]] 0 <= i < old(inputs).len() ==> fe51_limbs_bounded(&old(inputs)[i], 54),"
            ],
            "ensures": [
                "forall|i: int| #![auto] 0 <= i < inputs.len() ==> ( ((fe51_as_canonical_nat(&old(inputs)[i]) != 0) ==> is_inverse_field( &old(inputs)[i],",
                "&inputs[i],",
                ")) && ((fe51_as_canonical_nat(&old(inputs)[i]) == 0) ==> fe51_as_canonical_nat(&inputs[i]) == 0)),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 522,
            "module": "field",
            "doc_comment": "Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n\nWhen an input `FieldElement` is zero, its value is unchanged.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L522",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "fieldelement__batch_invert"
        },
        {
            "name": "ct_eq",
            "display_name": "FieldElement::ct_eq",
            "impl_type": "FieldElement",
            "contract": "fn ct_eq(&self, other: &FieldElement) -> (result:\n    Choice)/* <VERIFICATION NOTE>\n - Use wrapper functions for ConstantTimeEq and CtOption\n - DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n - Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes\n</VERIFICATION NOTE> */\n\n    ensures\n        choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/field.rs",
            "line": 142,
            "module": "field",
            "doc_comment": "Test equality between two `FieldElement`s.  Since the\ninternal representation is not canonical, the field elements\nare normalized to wire format before comparison.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L142",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__ct_eq"
        },
        {
            "name": "invert",
            "display_name": "FieldElement::invert",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn invert(&self) -> (result:\n    FieldElement)/* VERIFICATION NOTE:\n- Computes self^(p-2) using Fermat's Little Theorem: a^(p-1) ≡ 1 (mod p) => a^(p-2) * a ≡ 1 (mod p)\n- p-2 = 2^255 - 21 = (2^250 - 1) * 2^5 + 11\n*/\n\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n        fe51_as_canonical_nat(self) != 0 ==> (fe51_as_canonical_nat(&result) * fe51_as_canonical_nat(\n            self,\n        )) % p() == 1,\n        // If self is zero, result is zero\n        fe51_as_canonical_nat(self) == 0 ==> fe51_as_canonical_nat(&result) == 0,\n        fe51_as_canonical_nat(&result) == field_inv(fe51_as_canonical_nat(self)),\n        fe51_limbs_bounded(&result, 54),",
            "requires": [
                "fe51_limbs_bounded(self, 54),"
            ],
            "ensures": [
                "fe51_as_canonical_nat(self) != 0 ==> (fe51_as_canonical_nat(&result) * fe51_as_canonical_nat( self,",
                ")) % p() == 1,",
                "fe51_as_canonical_nat(self) == 0 ==> fe51_as_canonical_nat(&result) == 0,",
                "fe51_as_canonical_nat(&result) == field_inv(fe51_as_canonical_nat(self)),",
                "fe51_limbs_bounded(&result, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_inv",
                "p",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 733,
            "module": "field",
            "doc_comment": "Given a nonzero field element, compute its inverse.\n\nThe inverse is computed as self^(p-2), since\nx^(p-2)x = x^(p-1) = 1 (mod p).\n\nThis function returns zero on input zero.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L733",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__invert"
        },
        {
            "name": "invsqrt",
            "display_name": "FieldElement::invsqrt",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn invsqrt(&self) -> (result: (\n    Choice,\n    FieldElement,\n))\n// VERIFICATION NOTE: PROOF BYPASS\n\n    ensures\n// When self = 0: return (false, 0)\n\n        (fe51_as_canonical_nat(self) == 0) ==> (!choice_is_true(result.0) && fe51_as_canonical_nat(\n            &result.1,\n        ) == 0),\n        // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n        (choice_is_true(result.0)) ==> fe51_is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n        // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n        (!choice_is_true(result.0) && fe51_as_canonical_nat(self) != 0) ==> fe51_is_sqrt_ratio_times_i(\n            &FieldElement::ONE,\n            self,\n            &result.1,\n        ),",
            "requires": [],
            "ensures": [
                "(fe51_as_canonical_nat(self) == 0) ==> (!choice_is_true(result.0) && fe51_as_canonical_nat( &result.1,",
                ") == 0),",
                "(choice_is_true(result.0)) ==> fe51_is_sqrt_ratio(&FieldElement::ONE, self, &result.1),",
                "(!choice_is_true(result.0) && fe51_as_canonical_nat(self) != 0) ==> fe51_is_sqrt_ratio_times_i( &FieldElement::ONE,",
                "self,",
                "&result.1,",
                "),"
            ],
            "referenced_specs": [
                "p",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 974,
            "module": "field",
            "doc_comment": "Attempt to compute `sqrt(1/self)` in constant time.\n\nConvenience wrapper around `sqrt_ratio_i`.\n\nThis function always returns the nonnegative square root.\n\n# Return\n\n- `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n- `(Choice(0), zero)           ` if `self` is zero;\n- `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L974",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "fieldelement__invsqrt"
        },
        {
            "name": "is_negative",
            "display_name": "FieldElement::is_negative",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn is_negative(&self) -> (result:\n    Choice)/* VERIFICATION NOTE:\n- DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n- Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes to connect as_bytes() with spec_fe51_to_bytes()\n</VERIFICATION NOTE> */\n\n    ensures\n        choice_is_true(result) == (spec_fe51_to_bytes(self)[0] & 1 == 1),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (spec_fe51_to_bytes(self)[0] & 1 == 1),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/field.rs",
            "line": 217,
            "module": "field",
            "doc_comment": "Determine if this `FieldElement` is negative, in the sense\nused in the ed25519 paper: `x` is negative if the low bit is\nset.\n\n# Return\n\nIf negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L217",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__is_negative"
        },
        {
            "name": "is_zero",
            "display_name": "FieldElement::is_zero",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn is_zero(&self) -> (result:\n    Choice)/* VERIFICATION NOTE:\n- PROOF BYPASS AND SPEC BYPASS\n- we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\nensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n- (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n</VERIFICATION NOTE> */\n\n    ensures\n// SPEC BYPASS through placeholder spec_fe51_to_bytes\n\n        choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32]),",
            "requires": [],
            "ensures": [
                "- (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec) </VERIFICATION NOTE> */",
                "choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32]),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/field.rs",
            "line": 243,
            "module": "field",
            "doc_comment": "Determine if this `FieldElement` is zero.\n\n# Return\n\nIf zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L243",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__is_zero"
        },
        {
            "name": "pow22501",
            "display_name": "FieldElement::pow22501",
            "impl_type": "FieldElement",
            "contract": "fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// Bounded limbs (maintained by all field operations)\n\n        fe51_limbs_bounded(&result.0, 54),\n        fe51_limbs_bounded(&result.1, 54),\n        // Mathematical values\n        fe51_as_canonical_nat(&result.0) == (pow(\n            fe51_as_canonical_nat(self) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat) % p(),\n        fe51_as_canonical_nat(&result.1) == (pow(fe51_as_canonical_nat(self) as int, 11) as nat)\n            % p(),",
            "requires": [
                "fe51_limbs_bounded(self, 54),"
            ],
            "ensures": [
                "fe51_limbs_bounded(&result.0, 54),",
                "fe51_limbs_bounded(&result.1, 54),",
                "fe51_as_canonical_nat(&result.0) == (pow( fe51_as_canonical_nat(self) as int,",
                "(pow2(250) - 1) as nat,",
                ") as nat) % p(),",
                "fe51_as_canonical_nat(&result.1) == (pow(fe51_as_canonical_nat(self) as int, 11) as nat) % p(),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "p",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 289,
            "module": "field",
            "doc_comment": "Compute (self^(2^250-1), self^11), used as a helper function\nwithin invert() and pow22523().",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L289",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__pow22501"
        },
        {
            "name": "pow_p58",
            "display_name": "FieldElement::pow_p58",
            "impl_type": "FieldElement",
            "contract": "fn pow_p58(&self) -> (result: FieldElement)\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// Bounded limbs (maintained by all field operations)\n\n        fe51_limbs_bounded(&result, 54),\n        // Mathematical value\n        fe51_as_canonical_nat(&result) == (pow(\n            fe51_as_canonical_nat(self) as int,\n            (pow2(252) - 3) as nat,\n        ) as nat) % p(),",
            "requires": [
                "fe51_limbs_bounded(self, 54),"
            ],
            "ensures": [
                "fe51_limbs_bounded(&result, 54),",
                "fe51_as_canonical_nat(&result) == (pow( fe51_as_canonical_nat(self) as int,",
                "(pow2(252) - 3) as nat,",
                ") as nat) % p(),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "p",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 769,
            "module": "field",
            "doc_comment": "Raise this field element to the power (p-5)/8 = 2^252 -3.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L769",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "fieldelement__pow_p58"
        },
        {
            "name": "sqrt_ratio_i",
            "display_name": "FieldElement::sqrt_ratio_i",
            "impl_type": "FieldElement",
            "contract": "pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n    Choice,\n    FieldElement,\n))\n    requires\n// Input bounds for sqrt_ratio_i\n// u and v can be up to 54-bit bounded (from sub/add operations in decompress)\n\n        fe51_limbs_bounded(u, 54),\n        fe51_limbs_bounded(v, 54),\n    ensures\n// When u = 0: always return (true, 0)\n\n        (fe51_as_canonical_nat(u) == 0) ==> (choice_is_true(result.0) && fe51_as_canonical_nat(\n            &result.1,\n        ) == 0),\n        // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n        (fe51_as_canonical_nat(v) == 0 && fe51_as_canonical_nat(u) != 0) ==> (!choice_is_true(\n            result.0,\n        ) && fe51_as_canonical_nat(&result.1) == 0),\n        // When successful and v ≠ 0: r² * v ≡ u (mod p)\n        (choice_is_true(result.0) && fe51_as_canonical_nat(v) != 0) ==> fe51_is_sqrt_ratio(\n            u,\n            v,\n            &result.1,\n        ),\n        // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n        (!choice_is_true(result.0) && fe51_as_canonical_nat(v) != 0 && fe51_as_canonical_nat(u) != 0)\n            ==> fe51_is_sqrt_ratio_times_i(u, v, &result.1),\n        // NEW: The result is always the \"non-negative\" square root (LSB = 0)\n        // This is a fundamental property of sqrt_ratio_i that the original code\n        // relies on for decompression sign bit handling\n        fe51_as_canonical_nat(&result.1) % 2 == 0,\n        // Limb bounds: result is 52-bit bounded (from conditional_negate)\n        fe51_limbs_bounded(\n            &result.1,\n            52,\n        ),\n// VERIFICATION NOTE: PROOF BYPASS",
            "requires": [
                "fe51_limbs_bounded(u, 54),",
                "fe51_limbs_bounded(v, 54),"
            ],
            "ensures": [
                "(fe51_as_canonical_nat(u) == 0) ==> (choice_is_true(result.0) && fe51_as_canonical_nat( &result.1,",
                ") == 0),",
                "(fe51_as_canonical_nat(v) == 0 && fe51_as_canonical_nat(u) != 0) ==> (!choice_is_true( result.0,",
                ") && fe51_as_canonical_nat(&result.1) == 0),",
                "(choice_is_true(result.0) && fe51_as_canonical_nat(v) != 0) ==> fe51_is_sqrt_ratio( u,",
                "v,",
                "&result.1,",
                "),",
                "(!choice_is_true(result.0) && fe51_as_canonical_nat(v) != 0 && fe51_as_canonical_nat(u) != 0) ==> fe51_is_sqrt_ratio_times_i(u, v, &result.1),",
                "fe51_as_canonical_nat(&result.1) % 2 == 0,",
                "fe51_limbs_bounded( &result.1,",
                "52,",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "p",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/field.rs",
            "line": 852,
            "module": "field",
            "doc_comment": "Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\nor `sqrt(i*u/v)` in constant time.\n\nThis function always returns the nonnegative square root.\n\n# Return\n\n- `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n- `(Choice(1), zero)        ` if `u` is zero;\n- `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n- `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L852",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "fieldelement__sqrt_ratio_i"
        },
        {
            "name": "as_bytes",
            "display_name": "MontgomeryPoint::as_bytes",
            "impl_type": "MontgomeryPoint",
            "contract": "pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == &self.0,",
            "requires": [],
            "ensures": [
                "result == &self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 978,
            "module": "montgomery",
            "doc_comment": "View this `MontgomeryPoint` as an array of bytes.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L978",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomerypoint__as_bytes"
        },
        {
            "name": "ct_eq",
            "display_name": "MontgomeryPoint::ct_eq",
            "impl_type": "MontgomeryPoint",
            "contract": "fn ct_eq(&self, other: &MontgomeryPoint) -> (result: Choice)\n    ensures\n// Two MontgomeryPoints are equal if their u-coordinates are equal mod p\n\n        choice_is_true(result) == (field_element_from_bytes(&self.0)\n            == field_element_from_bytes(&other.0)),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (field_element_from_bytes(&self.0) == field_element_from_bytes(&other.0)),"
            ],
            "referenced_specs": [
                "p",
                "field_element_from_bytes"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 131,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L131",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__ct_eq"
        },
        {
            "name": "hash",
            "display_name": "MontgomeryPoint::hash",
            "impl_type": "MontgomeryPoint",
            "contract": "fn hash<H: Hasher>(&self, state: &mut H)\n    ensures/*  VERIFICATION NOTE:\n         (1) The actual postcondition is: *state == spec_state_after_hash_montgomery(initial_state, self)\n             where initial_state is the value of *state before this call.\n             However, Verus doesn't support old() on &mut types in ensures clauses.\n             The property is for now established via assumes in the function body (lines 192-194).\n        (2) The spec is completed by axiom_hash_is_canonical: equal field elements hash identically. */\n\n        true,",
            "requires": [],
            "ensures": [],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 200,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L200",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__hash"
        },
        {
            "name": "identity",
            "display_name": "MontgomeryPoint::identity",
            "impl_type": "MontgomeryPoint",
            "contract": "fn identity() -> (result: MontgomeryPoint)\n    ensures\n// The identity point has u-coordinate = 0\n\n        spec_montgomery(result) == 0,",
            "requires": [],
            "ensures": [
                "spec_montgomery(result) == 0,"
            ],
            "referenced_specs": [
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 230,
            "module": "montgomery",
            "doc_comment": "Return the group identity element, which has order 4.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L230",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__identity"
        },
        {
            "name": "mul",
            "display_name": "MontgomeryPoint::mul",
            "impl_type": "MontgomeryPoint",
            "contract": "fn mul(self, scalar: &Scalar) -> (result: MontgomeryPoint)\n    ensures\n// The canonical Montgomery lift point P corresponding to this u-coordinate\n// is multiplied by the unreduced scalar value\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*self));\n            let n_unreduced = scalar_as_nat(scalar);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),",
            "requires": [],
            "ensures": [
                "({ let P = canonical_montgomery_lift(spec_montgomery(*self)); let n_unreduced = scalar_as_nat(scalar); let R = montgomery_scalar_mul(P, n_unreduced); spec_montgomery(result) == spec_u_coordinate(R) }),"
            ],
            "referenced_specs": [
                "scalar_as_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 2001,
            "module": "montgomery",
            "doc_comment": "Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2001",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__mul"
        },
        {
            "name": "mul_assign",
            "display_name": "MontgomeryPoint::mul_assign",
            "impl_type": "MontgomeryPoint",
            "contract": "fn mul_assign(&mut self, scalar: &Scalar)\n    requires\n        is_valid_montgomery_point(*old(self)),\n    ensures\n// Result represents [n]old(self) where n is the UNREDUCED scalar value\n// Uses canonical Montgomery lift\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*old(self)));\n            let n_unreduced = scalar_as_nat(scalar);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(*self) == spec_u_coordinate(R)\n        }),",
            "requires": [
                "is_valid_montgomery_point(*old(self)),"
            ],
            "ensures": [
                "({ let P = canonical_montgomery_lift(spec_montgomery(*old(self))); let n_unreduced = scalar_as_nat(scalar); let R = montgomery_scalar_mul(P, n_unreduced); spec_montgomery(*self) == spec_u_coordinate(R) }),"
            ],
            "referenced_specs": [
                "scalar_as_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 2043,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2043",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomerypoint__mul_assign"
        },
        {
            "name": "mul_base",
            "display_name": "MontgomeryPoint::mul_base",
            "impl_type": "MontgomeryPoint",
            "contract": "pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_valid_montgomery_point(result),\n        // Functional correctness: result.u = [scalar] * basepoint (u-coordinate)\n        // Use scalar_as_nat (not spec_scalar) to match implementation behavior\n        spec_montgomery(result) == montgomery_scalar_mul_u(\n            spec_x25519_basepoint_u(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,"
            ],
            "ensures": [
                "is_valid_montgomery_point(result),",
                "spec_montgomery(result) == montgomery_scalar_mul_u( spec_x25519_basepoint_u(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "scalar_as_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 274,
            "module": "montgomery",
            "doc_comment": "Fixed-base scalar multiplication (i.e. multiplication by the base point).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L274",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__mul_base"
        },
        {
            "name": "mul_base_clamped",
            "display_name": "MontgomeryPoint::mul_base_clamped",
            "impl_type": "MontgomeryPoint",
            "contract": "pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n    ensures\n        is_valid_montgomery_point(result),\n        // Functional correctness: result.u = [clamp(bytes)] * basepoint (u-coordinate)\n        // Use scalar_as_nat (not spec_scalar) because clamped values are in [2^254, 2^255)\n        // which exceeds group_order ℓ ≈ 2^252, so spec_scalar would incorrectly reduce\n        spec_montgomery(result) == montgomery_scalar_mul_u(\n            spec_x25519_basepoint_u(),\n            scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),",
            "requires": [],
            "ensures": [
                "is_valid_montgomery_point(result),",
                "spec_montgomery(result) == montgomery_scalar_mul_u( spec_x25519_basepoint_u(),",
                "scalar_as_nat(&Scalar { bytes: spec_clamp_integer(bytes) }), ),"
            ],
            "referenced_specs": [
                "group_order",
                "scalar_as_nat",
                "spec_clamp_integer",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 346,
            "module": "montgomery",
            "doc_comment": "Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L346",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": false,
            "has_proof": false,
            "id": "montgomerypoint__mul_base_clamped"
        },
        {
            "name": "mul_bits_be",
            "display_name": "MontgomeryPoint::mul_bits_be",
            "impl_type": "MontgomeryPoint",
            "contract": "pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n    // Algorithm 8 of Costello-Smith 2017\n    let affine_u = FieldElement::from_bytes(&self.0);\n    let mut x0 = ProjectivePoint::identity();\n    let mut x1 = ProjectivePoint { U: affine_u, W: FieldElement::ONE };\n\n    // Go through the bits from most to least significant, using a sliding window of 2\n    let mut prev_bit = false;\n    for cur_bit in bits {\n        let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n        debug_assert!(choice == 0 || choice == 1);\n\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n        differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n        prev_bit = cur_bit;\n    }\n    // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n    ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n    // Don't leave the bit in the stack\n    #[cfg(feature = \"zeroize\")]\n    prev_bit.zeroize();\n\n    x0.as_affine()\n}\n</ORIGINAL CODE>\n*/\n/// Version of mul_bits_be that takes a slice of bits instead of an iterator.\n/// This version uses a while loop instead of for-loop to be Verus-compatible.\n///\n/// Given `self` \\\\( = u\\_0(P) \\\\), and a big-endian bit representation of an integer\n/// \\\\(n\\\\) as a slice, return \\\\( u\\_0(\\[n\\]P) \\\\).\n///\n// VERIFICATION NOTE: refactored mul_bits_be code\npub fn mul_bits_be(&self, bits: &[bool]) -> (result: MontgomeryPoint)\n    requires\n        bits.len() <= 255,\n        is_valid_montgomery_point(*self),\n    ensures\n        ({\n            // Let P be the canonical affine lift of input u-coordinate\n            let P = canonical_montgomery_lift(spec_montgomery(*self));\n            let n = bits_be_as_nat(bits, bits@.len() as int);\n            let R = montgomery_scalar_mul(P, n);\n\n            // result encodes u([n]P)\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),",
            "requires": [
                "bits.len() <= 255,",
                "is_valid_montgomery_point(*self),"
            ],
            "ensures": [
                "({ // Let P be the canonical affine lift of input u-coordinate let P = canonical_montgomery_lift(spec_montgomery(*self)); let n = bits_be_as_nat(bits, bits@.len() as int); let R = montgomery_scalar_mul(P, n);  // result encodes u([n]P) spec_montgomery(result) == spec_u_coordinate(R) }),"
            ],
            "referenced_specs": [
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 381,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L416",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomerypoint__mul_bits_be"
        },
        {
            "name": "mul_clamped",
            "display_name": "MontgomeryPoint::mul_clamped",
            "impl_type": "MontgomeryPoint",
            "contract": "pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n    requires\n        is_valid_montgomery_point(self),\n    ensures/* VERIFICATION NOTE: Result represents [n]self where n is the clamped integer value\n  The corresponding scalar is not reduced modulo the group order. */\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(self));\n            let clamped_bytes = spec_clamp_integer(bytes);\n            let n = u8_32_as_nat(&clamped_bytes);\n            let R = montgomery_scalar_mul(P, n);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),",
            "requires": [
                "is_valid_montgomery_point(self),",
                "ensures/* VERIFICATION NOTE: Result represents [n]self where n is the clamped integer value The corresponding scalar is not reduced modulo the group order. */ ({ let P = canonical_montgomery_lift(spec_montgomery(self)); let clamped_bytes = spec_clamp_integer(bytes); let n = u8_32_as_nat(&clamped_bytes); let R = montgomery_scalar_mul(P, n); spec_montgomery(result) == spec_u_coordinate(R) }),"
            ],
            "ensures": [],
            "referenced_specs": [
                "u8_32_as_nat",
                "spec_clamp_integer",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 308,
            "module": "montgomery",
            "doc_comment": "Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L308",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__mul_clamped"
        },
        {
            "name": "to_bytes",
            "display_name": "MontgomeryPoint::to_bytes",
            "impl_type": "MontgomeryPoint",
            "contract": "pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,",
            "requires": [],
            "ensures": [
                "result == self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 986,
            "module": "montgomery",
            "doc_comment": "Convert this `MontgomeryPoint` to an array of bytes.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L986",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomerypoint__to_bytes"
        },
        {
            "name": "to_edwards",
            "display_name": "MontgomeryPoint::to_edwards",
            "impl_type": "MontgomeryPoint",
            "contract": "pub fn to_edwards(&self, sign: u8) -> (result: Option<EdwardsPoint>)\n    ensures\n        match result {\n            Some(edwards) => montgomery_corresponds_to_edwards(*self, edwards),\n            None => is_equal_to_minus_one(spec_montgomery(*self)),\n        },",
            "requires": [],
            "ensures": [
                "match result { Some(edwards) => montgomery_corresponds_to_edwards(*self, edwards), None => is_equal_to_minus_one(spec_montgomery(*self)), },"
            ],
            "referenced_specs": [
                "is_equal_to_minus_one",
                "montgomery_corresponds_to_edwards",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 1009,
            "module": "montgomery",
            "doc_comment": "Attempt to convert to an `EdwardsPoint`, using the supplied\nchoice of sign for the `EdwardsPoint`.\n\n# Inputs\n\n* `sign`: a `u8` donating the desired sign of the resulting\n`EdwardsPoint`.  `0` denotes positive and `1` negative.\n\n# Return\n\n* `Some(EdwardsPoint)` if `self` is the \\\\(u\\\\)-coordinate of a\npoint on (the Montgomery form of) Curve25519;\n\n* `None` if `self` is the \\\\(u\\\\)-coordinate of a point on the\ntwist of (the Montgomery form of) Curve25519;\n",
            "math_interpretation": "u -> (x,y) in E(F_p), birational map M -> E",
            "informal_interpretation": "Converts a Montgomery point to its Edwards representation (with sign).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1009",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomerypoint__to_edwards"
        },
        {
            "name": "zeroize",
            "display_name": "MontgomeryPoint::zeroize",
            "impl_type": "MontgomeryPoint",
            "contract": "fn zeroize(&mut self)\n    ensures\n// All bytes are zero\n\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        // The u-coordinate is 0 (identity point)\n        spec_montgomery(*self) == 0,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,",
                "spec_montgomery(*self) == 0,"
            ],
            "referenced_specs": [
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 254,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L254",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomerypoint__zeroize"
        },
        {
            "name": "as_affine",
            "display_name": "ProjectivePoint::as_affine",
            "impl_type": "ProjectivePoint",
            "contract": "pub fn as_affine(&self) -> (result: MontgomeryPoint)\n    requires\n        fe51_limbs_bounded(&self.U, 54),\n        fe51_limbs_bounded(&self.W, 54),\n    ensures\n// For projective point (U:W), the affine u-coordinate is u = U/W (or 0 if W=0)\n\n        spec_montgomery(result) == {\n            let u_proj = fe51_as_canonical_nat(&self.U);\n            let w_proj = fe51_as_canonical_nat(&self.W);\n            if w_proj == 0 {\n                0\n            } else {\n                field_mul(u_proj, field_inv(w_proj))\n            }\n        },",
            "requires": [
                "fe51_limbs_bounded(&self.U, 54),",
                "fe51_limbs_bounded(&self.W, 54),"
            ],
            "ensures": [
                "spec_montgomery(result) == { let u_proj = fe51_as_canonical_nat(&self.U); let w_proj = fe51_as_canonical_nat(&self.W); if w_proj == 0 { 0 } else { field_mul(u_proj, field_inv(w_proj)) } },"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_inv",
                "field_mul",
                "fe51_as_canonical_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 1289,
            "module": "montgomery",
            "doc_comment": "Dehomogenize this point to affine coordinates.\n\n# Return\n\n* \\\\( u = U / W \\\\) if \\\\( W \\neq 0 \\\\);\n* \\\\( 0 \\\\) if \\\\( W \\eq 0 \\\\);\n\n# Specification\nThe resulting MontgomeryPoint has u-coordinate equal to U/W (or 0 if W=0)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1289",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "projectivepoint__as_affine"
        },
        {
            "name": "identity",
            "display_name": "ProjectivePoint::identity",
            "impl_type": "ProjectivePoint",
            "contract": "fn identity() -> (result: ProjectivePoint)\n    ensures\n// The identity point is (1:0) in projective coordinates\n\n        fe51_as_canonical_nat(&result.U) == 1,\n        fe51_as_canonical_nat(&result.W) == 0,\n        // Actual representation uses field constants ONE/ZERO\n        fe51_limbs_bounded(&result.U, 51),\n        fe51_limbs_bounded(&result.W, 51),\n        // Weakened bounds help SMT solver in callers\n        fe51_limbs_bounded(&result.U, 54),\n        fe51_limbs_bounded(&result.W, 54),",
            "requires": [],
            "ensures": [
                "fe51_as_canonical_nat(&result.U) == 1,",
                "fe51_as_canonical_nat(&result.W) == 0,",
                "fe51_limbs_bounded(&result.U, 51),",
                "fe51_limbs_bounded(&result.W, 51),",
                "fe51_limbs_bounded(&result.U, 54),",
                "fe51_limbs_bounded(&result.W, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 1174,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1174",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "projectivepoint__identity"
        },
        {
            "name": "mul",
            "display_name": "Scalar::mul",
            "impl_type": "Scalar",
            "contract": "fn mul(self, point: &MontgomeryPoint) -> (result: MontgomeryPoint)\n    ensures\n// Delegates to point * self, which multiplies by the unreduced scalar using canonical lift\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*point));\n            let n_unreduced = scalar_as_nat(self);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),",
            "requires": [],
            "ensures": [
                "({ let P = canonical_montgomery_lift(spec_montgomery(*point)); let n_unreduced = scalar_as_nat(self); let R = montgomery_scalar_mul(P, n_unreduced); spec_montgomery(result) == spec_u_coordinate(R) }),"
            ],
            "referenced_specs": [
                "scalar_as_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 2069,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2069",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_L2069"
        },
        {
            "name": "differential_add_and_double",
            "display_name": "differential_add_and_double",
            "impl_type": "",
            "contract": "fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n)\n    requires\n// Bounds needed for the underlying field operations\n\n        fe51_limbs_bounded(&old(P).U, 52),\n        fe51_limbs_bounded(&old(P).W, 52),\n        fe51_limbs_bounded(&old(Q).U, 52),\n        fe51_limbs_bounded(&old(Q).W, 52),\n        // This matches the invariant maintained by the caller (mul_bits_be)\n        fe51_limbs_bounded(affine_PmQ, 51),\n        is_valid_u_coordinate(fe51_as_canonical_nat(affine_PmQ)),\n    ensures\n// === Bounds preserved for callers ===\n\n        fe51_limbs_bounded(&P.U, 52),\n        fe51_limbs_bounded(&P.W, 52),\n        fe51_limbs_bounded(&Q.U, 52),\n        fe51_limbs_bounded(&Q.W, 52),\n        // Degenerate case: if u(P-Q)=0 and both inputs have u=0, outputs preserve u=0.\n        (fe51_as_canonical_nat(affine_PmQ) == 0 && spec_projective_u_coordinate(*old(P)) == 0\n            && spec_projective_u_coordinate(*old(Q)) == 0) ==> (spec_projective_u_coordinate(*P)\n            == 0 && spec_projective_u_coordinate(*Q) == 0),\n        // Montgomery ladder step: P' = [2]P (xDBL), Q' = P + Q (xADD).\n        // Case 1: P = [k]B, Q = [k+1]B  ==>  P' = [2k]B, Q' = [2k+1]B\n        ({\n            let B = canonical_montgomery_lift(fe51_as_canonical_nat(affine_PmQ));\n            forall|k: nat|\n                fe51_as_canonical_nat(affine_PmQ) != 0\n                    && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(P),\n                    montgomery_scalar_mul(B, k),\n                ) && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(Q),\n                    montgomery_scalar_mul(B, k + 1),\n                ) ==> {\n                    &&& projective_represents_montgomery_or_infinity(\n                        *P,\n                        montgomery_scalar_mul(B, 2 * k),\n                    )\n                    &&& projective_represents_montgomery_or_infinity(\n                        *Q,\n                        montgomery_scalar_mul(B, 2 * k + 1),\n                    )\n                }\n        }),\n        // Case 2 (swapped): P = [k+1]B, Q = [k]B  ==>  P' = [2k+2]B, Q' = [2k+1]B\n        ({\n            let B = canonical_montgomery_lift(fe51_as_canonical_nat(affine_PmQ));\n            forall|k: nat|\n                fe51_as_canonical_nat(affine_PmQ) != 0\n                    && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(P),\n                    montgomery_scalar_mul(B, k + 1),\n                ) && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(Q),\n                    montgomery_scalar_mul(B, k),\n                ) ==> {\n                    &&& projective_represents_montgomery_or_infinity(\n                        *P,\n                        montgomery_scalar_mul(B, 2 * k + 2),\n                    )\n                    &&& projective_represents_montgomery_or_infinity(\n                        *Q,\n                        montgomery_scalar_mul(B, 2 * k + 1),\n                    )\n                }\n        }),",
            "requires": [
                "fe51_limbs_bounded(&old(P).U, 52),",
                "fe51_limbs_bounded(&old(P).W, 52),",
                "fe51_limbs_bounded(&old(Q).U, 52),",
                "fe51_limbs_bounded(&old(Q).W, 52),",
                "fe51_limbs_bounded(affine_PmQ, 51),",
                "is_valid_u_coordinate(fe51_as_canonical_nat(affine_PmQ)),"
            ],
            "ensures": [
                "fe51_limbs_bounded(&P.U, 52),",
                "fe51_limbs_bounded(&P.W, 52),",
                "fe51_limbs_bounded(&Q.U, 52),",
                "fe51_limbs_bounded(&Q.W, 52),",
                "(fe51_as_canonical_nat(affine_PmQ) == 0 && spec_projective_u_coordinate(*old(P)) == 0 && spec_projective_u_coordinate(*old(Q)) == 0) ==> (spec_projective_u_coordinate(*P) == 0 && spec_projective_u_coordinate(*Q) == 0),",
                "({ let B = canonical_montgomery_lift(fe51_as_canonical_nat(affine_PmQ)); forall|k: nat| fe51_as_canonical_nat(affine_PmQ) != 0 && #[trigger] projective_represents_montgomery_or_infinity( *old(P), montgomery_scalar_mul(B, k), ) && #[trigger] projective_represents_montgomery_or_infinity( *old(Q), montgomery_scalar_mul(B, k + 1), ) ==> { &&& projective_represents_montgomery_or_infinity( *P, montgomery_scalar_mul(B, 2 * k), ) &&& projective_represents_montgomery_or_infinity( *Q, montgomery_scalar_mul(B, 2 * k + 1), ) } }), ({ let B = canonical_montgomery_lift(fe51_as_canonical_nat(affine_PmQ)); forall|k: nat| fe51_as_canonical_nat(affine_PmQ) != 0 && #[trigger] projective_represents_montgomery_or_infinity( *old(P), montgomery_scalar_mul(B, k + 1), ) && #[trigger] projective_represents_montgomery_or_infinity( *old(Q), montgomery_scalar_mul(B, k), ) ==> { &&& projective_represents_montgomery_or_infinity( *P, montgomery_scalar_mul(B, 2 * k + 2), ) &&& projective_represents_montgomery_or_infinity( *Q, montgomery_scalar_mul(B, 2 * k + 1), ) } }),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 1338,
            "module": "montgomery",
            "doc_comment": "Perform the double-and-add step of the Montgomery ladder.\n\nGiven projective points\n\\\\( (U\\_P : W\\_P) = u(P) \\\\),\n\\\\( (U\\_Q : W\\_Q) = u(Q) \\\\),\nand the affine difference\n\\\\(      u\\_{P-Q} = u(P-Q) \\\\), set\n$$\n(U\\_P : W\\_P) \\gets u(\\[2\\]P)\n$$\nand\n$$\n(U\\_Q : W\\_Q) \\gets u(P + Q).\n$$",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1338",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "montgomery__differential_add_and_double"
        },
        {
            "name": "elligator_encode",
            "display_name": "elligator_encode",
            "impl_type": "",
            "contract": "pub(crate) fn elligator_encode(r_0: &FieldElement) -> (result: MontgomeryPoint)\n    requires\n        fe51_limbs_bounded(r_0, 51),\n    ensures\n        spec_montgomery(result) == spec_elligator_encode(fe51_as_canonical_nat(r_0)),\n        spec_montgomery(result) < p(),",
            "requires": [
                "fe51_limbs_bounded(r_0, 51),"
            ],
            "ensures": [
                "spec_montgomery(result) == spec_elligator_encode(fe51_as_canonical_nat(r_0)),",
                "spec_montgomery(result) < p(),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "p",
                "fe51_as_canonical_nat",
                "spec_montgomery"
            ],
            "file": "curve25519-dalek/src/montgomery.rs",
            "line": 1073,
            "module": "montgomery",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1073",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "montgomery__elligator_encode"
        },
        {
            "name": "efgh",
            "display_name": "BatchCompressState::efgh",
            "impl_type": "BatchCompressState",
            "contract": "fn efgh(&self) -> (result: FieldElement)\n    requires\n        fe51_limbs_bounded(&self.eg, 54),\n        fe51_limbs_bounded(&self.fh, 54),\n    ensures\n        fe51_limbs_bounded(&result, 54),\n        fe51_as_canonical_nat(&result) == field_mul(\n            fe51_as_canonical_nat(&self.eg),\n            fe51_as_canonical_nat(&self.fh),\n        ),",
            "requires": [
                "fe51_limbs_bounded(&self.eg, 54),",
                "fe51_limbs_bounded(&self.fh, 54),"
            ],
            "ensures": [
                "fe51_limbs_bounded(&result, 54),",
                "fe51_as_canonical_nat(&result) == field_mul( fe51_as_canonical_nat(&self.eg),",
                "fe51_as_canonical_nat(&self.fh),",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "field_mul",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 731,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L731",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "batchcompressstate__efgh"
        },
        {
            "name": "from",
            "display_name": "BatchCompressState::from",
            "impl_type": "BatchCompressState",
            "contract": "fn from(P: &'a RistrettoPoint) -> (result:\n    BatchCompressState)/* Expected requires (if Verus supported from_req):\n        is_well_formed_edwards_point(P.0),\n    */\n\n    ensures\n        fe51_limbs_bounded(&result.eg, 54),\n        fe51_limbs_bounded(&result.fh, 54),\n        // e = 2*X*Y\n        fe51_as_canonical_nat(&result.e) == field_mul(\n            2,\n            field_mul(fe51_as_canonical_nat(&P.0.X), fe51_as_canonical_nat(&P.0.Y)),\n        ),\n        // f = Z^2 + d*T^2\n        fe51_as_canonical_nat(&result.f) == field_add(\n            field_square(fe51_as_canonical_nat(&P.0.Z)),\n            field_mul(\n                fe51_as_canonical_nat(&constants::EDWARDS_D),\n                field_square(fe51_as_canonical_nat(&P.0.T)),\n            ),\n        ),\n        // g = Y^2 + X^2 (a = -1)\n        fe51_as_canonical_nat(&result.g) == field_add(\n            field_square(fe51_as_canonical_nat(&P.0.Y)),\n            field_square(fe51_as_canonical_nat(&P.0.X)),\n        ),\n        // h = Z^2 - d*T^2\n        fe51_as_canonical_nat(&result.h) == field_sub(\n            field_square(fe51_as_canonical_nat(&P.0.Z)),\n            field_mul(\n                fe51_as_canonical_nat(&constants::EDWARDS_D),\n                field_square(fe51_as_canonical_nat(&P.0.T)),\n            ),\n        ),\n        // eg = e * g, fh = f * h\n        fe51_as_canonical_nat(&result.eg) == field_mul(\n            fe51_as_canonical_nat(&result.e),\n            fe51_as_canonical_nat(&result.g),\n        ),\n        fe51_as_canonical_nat(&result.fh) == field_mul(\n            fe51_as_canonical_nat(&result.f),\n            fe51_as_canonical_nat(&result.h),\n        ),",
            "requires": [],
            "ensures": [
                "fe51_limbs_bounded(&result.eg, 54),",
                "fe51_limbs_bounded(&result.fh, 54),",
                "fe51_as_canonical_nat(&result.e) == field_mul( 2,",
                "field_mul(fe51_as_canonical_nat(&P.0.X), fe51_as_canonical_nat(&P.0.Y)),",
                "),",
                "fe51_as_canonical_nat(&result.f) == field_add( field_square(fe51_as_canonical_nat(&P.0.Z)),",
                "field_mul( fe51_as_canonical_nat(&constants::EDWARDS_D),",
                "field_square(fe51_as_canonical_nat(&P.0.T)),",
                "),",
                "),",
                "fe51_as_canonical_nat(&result.g) == field_add( field_square(fe51_as_canonical_nat(&P.0.Y)),",
                "field_square(fe51_as_canonical_nat(&P.0.X)),",
                "),",
                "fe51_as_canonical_nat(&result.h) == field_sub( field_square(fe51_as_canonical_nat(&P.0.Z)),",
                "field_mul( fe51_as_canonical_nat(&constants::EDWARDS_D),",
                "field_square(fe51_as_canonical_nat(&P.0.T)),",
                "),",
                "),",
                "fe51_as_canonical_nat(&result.eg) == field_mul( fe51_as_canonical_nat(&result.e),",
                "fe51_as_canonical_nat(&result.g),",
                "),",
                "fe51_as_canonical_nat(&result.fh) == field_mul( fe51_as_canonical_nat(&result.f),",
                "fe51_as_canonical_nat(&result.h),",
                "),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point",
                "field_add",
                "field_mul",
                "field_square",
                "field_sub",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 749,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L749",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "batchcompressstate__from"
        },
        {
            "name": "as_bytes",
            "display_name": "CompressedRistretto::as_bytes",
            "impl_type": "CompressedRistretto",
            "contract": "pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        *result == self.0,",
            "requires": [],
            "ensures": [
                "*result == self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 274,
            "module": "ristretto",
            "doc_comment": "View this `CompressedRistretto` as an array of bytes.",
            "math_interpretation": "&CompressedRistretto -> &[u8; 32]",
            "informal_interpretation": "Returns the byte representation of a compressed Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L274",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressedristretto__as_bytes"
        },
        {
            "name": "ct_eq",
            "display_name": "CompressedRistretto::ct_eq",
            "impl_type": "CompressedRistretto",
            "contract": "fn ct_eq(&self, other: &CompressedRistretto) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.0 == other.0),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (self.0 == other.0),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 254,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "a =? b (constant-time byte comparison)",
            "informal_interpretation": "Constant-time equality comparison of two compressed Ristretto points.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L254",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressedristretto__ct_eq"
        },
        {
            "name": "decompress",
            "display_name": "CompressedRistretto::decompress",
            "impl_type": "CompressedRistretto",
            "contract": "pub fn decompress(&self) -> (result: Option<RistrettoPoint>)\n    ensures\n// Spec alignment: result matches spec-level decoding\n\n        result == spec_ristretto_decompress(self.0),\n        // If decompression succeeds, the result is a well-formed Edwards point\n        // (well-formed includes: valid on curve, limbs bounded, sum bounded)\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),\n        // On success, the decoded point lies in the even subgroup\n        result.is_some() ==> is_in_even_subgroup(result.unwrap().0),",
            "requires": [],
            "ensures": [
                "result == spec_ristretto_decompress(self.0),",
                "result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),",
                "result.is_some() ==> is_in_even_subgroup(result.unwrap().0),"
            ],
            "referenced_specs": [
                "is_in_even_subgroup",
                "is_well_formed_edwards_point",
                "spec_ristretto_decompress"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 332,
            "module": "ristretto",
            "doc_comment": "Attempt to decompress to an `RistrettoPoint`.\n\n# Return\n\n- `Some(RistrettoPoint)` if `self` was the canonical encoding of a point;\n\n- `None` if `self` was not the canonical encoding of a point.",
            "math_interpretation": "[u8; 32] -> Option<P in E/~>, Ristretto decoding",
            "informal_interpretation": "Decompresses a Ristretto encoding to a point (if valid).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L332",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "compressedristretto__decompress"
        },
        {
            "name": "from_slice",
            "display_name": "CompressedRistretto::from_slice",
            "impl_type": "CompressedRistretto",
            "contract": "pub fn from_slice(bytes: &[u8]) -> (result: Result<CompressedRistretto, TryFromSliceError>)\n    ensures\n        bytes@.len() == 32 ==> matches!(result, Ok(_)),\n        bytes@.len() != 32 ==> matches!(result, Err(_)),\n        match result {\n            Ok(point) => point.0@ == bytes@,\n            Err(_) => true,\n        },",
            "requires": [],
            "ensures": [
                "bytes@.len() == 32 ==> matches!(result, Ok(_)),",
                "bytes@.len() != 32 ==> matches!(result, Err(_)),",
                "match result { Ok(point) => point.0@ == bytes@, Err(_) => true, },"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 288,
            "module": "ristretto",
            "doc_comment": "Construct a `CompressedRistretto` from a slice of bytes.\n\n# Errors\n\nReturns [`TryFromSliceError`] if the input `bytes` slice does not have\na length of 32.",
            "math_interpretation": "&[u8] -> CompressedRistretto",
            "informal_interpretation": "Constructs a compressed Ristretto point from a byte slice.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L288",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "compressedristretto__from_slice"
        },
        {
            "name": "identity",
            "display_name": "CompressedRistretto::identity",
            "impl_type": "CompressedRistretto",
            "contract": "fn identity() -> (result: CompressedRistretto)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> result.0[i] == 0u8,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 32 ==> result.0[i] == 0u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 316,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "Encode(O) -> CompressedRistretto",
            "informal_interpretation": "Returns the compressed identity Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L316",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressedristretto__identity"
        },
        {
            "name": "to_bytes",
            "display_name": "CompressedRistretto::to_bytes",
            "impl_type": "CompressedRistretto",
            "contract": "pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,",
            "requires": [],
            "ensures": [
                "result == self.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 266,
            "module": "ristretto",
            "doc_comment": "Copy the bytes of this `CompressedRistretto`.",
            "math_interpretation": "CompressedRistretto -> [u8; 32]",
            "informal_interpretation": "Returns the byte array of a compressed Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L266",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "compressedristretto__to_bytes"
        },
        {
            "name": "zeroize",
            "display_name": "CompressedRistretto::zeroize",
            "impl_type": "CompressedRistretto",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2397,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2397",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "compressedristretto__zeroize"
        },
        {
            "name": "basepoint",
            "display_name": "RistrettoBasepointTable::basepoint",
            "impl_type": "RistrettoBasepointTable",
            "contract": "pub fn basepoint(&self) -> (result: RistrettoPoint)\n    requires\n        is_valid_edwards_basepoint_table(self.0, spec_ristretto_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // The result is the Ristretto basepoint B\n        edwards_point_as_affine(result.0) == spec_ristretto_basepoint(),",
            "requires": [
                "is_valid_edwards_basepoint_table(self.0, spec_ristretto_basepoint()),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == spec_ristretto_basepoint(),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point",
                "spec_ristretto_basepoint"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2233,
            "module": "ristretto",
            "doc_comment": "Get the basepoint for this table as a `RistrettoPoint`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2233",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettobasepointtable__basepoint"
        },
        {
            "name": "create",
            "display_name": "RistrettoBasepointTable::create",
            "impl_type": "RistrettoBasepointTable",
            "contract": "pub fn create(basepoint: &RistrettoPoint) -> (result: RistrettoBasepointTable)\n    requires\n        is_well_formed_edwards_point(basepoint.0),\n    ensures\n        is_valid_edwards_basepoint_table(result.0, edwards_point_as_affine(basepoint.0)),",
            "requires": [
                "is_well_formed_edwards_point(basepoint.0),"
            ],
            "ensures": [
                "is_valid_edwards_basepoint_table(result.0, edwards_point_as_affine(basepoint.0)),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2223,
            "module": "ristretto",
            "doc_comment": "Create a precomputed table of multiples of the given `basepoint`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2223",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettobasepointtable__create"
        },
        {
            "name": "mul",
            "display_name": "RistrettoBasepointTable::mul",
            "impl_type": "RistrettoBasepointTable",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)/* requires clause in MulSpecImpl<&Scalar> for &RistrettoBasepointTable in arithm_trait_specs.rs:\n    requires scalar.bytes[31] <= 127\n*/\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_scalar_mul( spec_ristretto_basepoint(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ristretto_basepoint"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2176,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2176",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettobasepointtable__mul"
        },
        {
            "name": "add",
            "display_name": "RistrettoPoint::add",
            "impl_type": "RistrettoPoint",
            "contract": "fn add(self, other: &'b RistrettoPoint) -> (result:\n    RistrettoPoint)\n// requires (from AddSpecImpl::add_req): is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_add(\n            edwards_point_as_affine(self.0).0,\n            edwards_point_as_affine(self.0).1,\n            edwards_point_as_affine(other.0).0,\n            edwards_point_as_affine(other.0).1,\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_add( edwards_point_as_affine(self.0).0,",
                "edwards_point_as_affine(self.0).1,",
                "edwards_point_as_affine(other.0).0,",
                "edwards_point_as_affine(other.0).1,",
                "),"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1504,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1504",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__add"
        },
        {
            "name": "add_assign",
            "display_name": "RistrettoPoint::add_assign",
            "impl_type": "RistrettoPoint",
            "contract": "fn add_assign(&mut self, _rhs: &RistrettoPoint)\n    requires\n        is_well_formed_edwards_point(old(self).0),\n        is_well_formed_edwards_point(_rhs.0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = old(self) + rhs\n        edwards_point_as_affine(self.0) == edwards_add(\n            edwards_point_as_affine(old(self).0).0,\n            edwards_point_as_affine(old(self).0).1,\n            edwards_point_as_affine(_rhs.0).0,\n            edwards_point_as_affine(_rhs.0).1,\n        ),",
            "requires": [
                "is_well_formed_edwards_point(old(self).0),",
                "is_well_formed_edwards_point(_rhs.0),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(self.0),",
                "edwards_point_as_affine(self.0) == edwards_add( edwards_point_as_affine(old(self).0).0,",
                "edwards_point_as_affine(old(self).0).1,",
                "edwards_point_as_affine(_rhs.0).0,",
                "edwards_point_as_affine(_rhs.0).1,",
                "),"
            ],
            "referenced_specs": [
                "edwards_add",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1529,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1529",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__add_assign"
        },
        {
            "name": "compress",
            "display_name": "RistrettoPoint::compress",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn compress(&self) -> (result: CompressedRistretto)\n    ensures\n        result.0 == spec_ristretto_compress(*self),",
            "requires": [],
            "ensures": [
                "result.0 == spec_ristretto_compress(*self),"
            ],
            "referenced_specs": [
                "spec_ristretto_compress"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 654,
            "module": "ristretto",
            "doc_comment": "Compress this point using the Ristretto encoding.",
            "math_interpretation": "P in E/~ -> [u8; 32], Ristretto encoding",
            "informal_interpretation": "Compresses a Ristretto point to its canonical 32-byte encoding.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L654",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristrettopoint__compress"
        },
        {
            "name": "conditional_select",
            "display_name": "RistrettoPoint::conditional_select",
            "impl_type": "RistrettoPoint",
            "contract": "fn conditional_select(a: &RistrettoPoint, b: &RistrettoPoint, choice: Choice) -> (result:\n    RistrettoPoint)\n    ensures\n// If choice is false (0), return a\n\n        !choice_is_true(choice) ==> result.0 == a.0,\n        // If choice is true (1), return b\n        choice_is_true(choice) ==> result.0 == b.0,",
            "requires": [],
            "ensures": [
                "!choice_is_true(choice) ==> result.0 == a.0,",
                "choice_is_true(choice) ==> result.0 == b.0,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2275,
            "module": "ristretto",
            "doc_comment": "Conditionally select between `self` and `other`.\n\n# Example\n\n```\nuse subtle::ConditionallySelectable;\nuse subtle::Choice;\n#\n# use curve25519_dalek::traits::Identity;\n# use curve25519_dalek::ristretto::RistrettoPoint;\n# use curve25519_dalek::constants;\n# fn main() {\n\nlet A = RistrettoPoint::identity();\nlet B = constants::RISTRETTO_BASEPOINT_POINT;\n\nlet mut P = A;\n\nP = RistrettoPoint::conditional_select(&A, &B, Choice::from(0));\nassert_eq!(P, A);\nP = RistrettoPoint::conditional_select(&A, &B, Choice::from(1));\nassert_eq!(P, B);\n# }\n```",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2275",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__conditional_select"
        },
        {
            "name": "ct_eq",
            "display_name": "RistrettoPoint::ct_eq",
            "impl_type": "RistrettoPoint",
            "contract": "fn ct_eq(&self, other: &RistrettoPoint) -> (result:\n    Choice)/* requires clause in ConstantTimeEqSpecImplRistretto:\n       is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0) */\n\n    ensures\n// Two Ristretto points are equal iff they are in the same equivalence class\n\n        choice_is_true(result) == ristretto_equivalent(self.0, other.0),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == ristretto_equivalent(self.0, other.0),"
            ],
            "referenced_specs": [
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1455,
            "module": "ristretto",
            "doc_comment": "Test equality between two `RistrettoPoint`s.\n\n# Returns\n\n* `Choice(1)` if the two `RistrettoPoint`s are equal;\n* `Choice(0)` otherwise.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1455",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristrettopoint__ct_eq"
        },
        {
            "name": "default",
            "display_name": "RistrettoPoint::default",
            "impl_type": "RistrettoPoint",
            "contract": "fn default() -> (result: RistrettoPoint)\n    ensures\n        is_identity_edwards_point(result.0),\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),",
            "requires": [],
            "ensures": [
                "is_identity_edwards_point(result.0),",
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),"
            ],
            "referenced_specs": [
                "is_identity_edwards_point",
                "is_in_even_subgroup",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1412,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "O (identity in E/~)",
            "informal_interpretation": "Returns the default (identity) Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1412",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__default"
        },
        {
            "name": "double_and_compress_batch_verus",
            "display_name": "RistrettoPoint::double_and_compress_batch_verus",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn double_and_compress_batch_verus(points: &[RistrettoPoint]) -> (result: Vec<\n    CompressedRistretto,\n>)\n    requires\n        forall|i: int|\n            0 <= i < points@.len() ==> is_well_formed_edwards_point(#[trigger] points@[i].0),\n    ensures\n        result@.len() == points@.len(),\n        // Functional correctness: each result[i] = compress(2 * points[i])\n        forall|i: int|\n            0 <= i < result@.len() ==> {\n                let point_affine = edwards_point_as_affine(#[trigger] points@[i].0);\n                let doubled_affine = edwards_double(point_affine.0, point_affine.1);\n                #[trigger] result@[i].0@ == spec_ristretto_compress_affine(\n                    doubled_affine.0,\n                    doubled_affine.1,\n                )@\n            },",
            "requires": [
                "forall|i: int| 0 <= i < points@.len() ==> is_well_formed_edwards_point(#[trigger] points@[i].0),"
            ],
            "ensures": [
                "result@.len() == points@.len(),",
                "forall|i: int| 0 <= i < result@.len() ==> { let point_affine = edwards_point_as_affine(#[trigger] points@[i].0); let doubled_affine = edwards_double(point_affine.0, point_affine.1); #[trigger] result@[i].0@ == spec_ristretto_compress_affine( doubled_affine.0, doubled_affine.1, )@ },"
            ],
            "referenced_specs": [
                "edwards_double",
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 925,
            "module": "ristretto",
            "doc_comment": "Verus-compatible version that takes a slice instead of IntoIterator.\nUse this for verification; the original double_and_compress_batch API is external_body.\n\nREFACTORING FOR VERUS:\n- Iterator patterns (.map().collect()) replaced with explicit while loops\n- IntoIterator trait replaced with concrete slice type\n- Vec to slice conversion wrapped in external_body helper (batch_invert_vec)\n- Closures replaced with inline code using Verus-compatible wrappers\n(conditional_assign_generic, conditional_negate_field_element, negate_field)\n\nSpec: each output[i] = compress(2 * points[i])",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L925",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristrettopoint__double_and_compress_batch_verus"
        },
        {
            "name": "from_hash_verus",
            "display_name": "RistrettoPoint::from_hash_verus",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(&hash_bytes),\n        // Uniform hash output produces uniformly distributed point\n        is_uniform_bytes(&hash_bytes) ==> is_uniform_ristretto_point(&result),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),",
                "edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(&hash_bytes),",
                "is_uniform_bytes(&hash_bytes) ==> is_uniform_ristretto_point(&result),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_in_even_subgroup",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1308,
            "module": "ristretto",
            "doc_comment": "Verus-compatible version of from_hash that takes finalized hash bytes directly.\n\nThis function is designed for Verus verification. It takes the 64-byte\nhash output directly, avoiding GenericArray complexity.\n\n# Inputs\n\n* `hash_bytes`: 64-byte hash output (e.g., from SHA-512)\n\n# Returns\n\nA RistrettoPoint derived from the hash",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1308",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__from_hash_verus"
        },
        {
            "name": "hash_from_bytes_verus",
            "display_name": "RistrettoPoint::hash_from_bytes_verus",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn hash_from_bytes_verus(input: &[u8]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        // Uniform input bytes produce uniformly distributed point\n        is_uniform_bytes(input) ==> is_uniform_ristretto_point(&result),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),",
                "is_uniform_bytes(input) ==> is_uniform_ristretto_point(&result),"
            ],
            "referenced_specs": [
                "is_in_even_subgroup",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1259,
            "module": "ristretto",
            "doc_comment": "Verus-compatible version of hash_from_bytes that uses SHA-512.\n\nThis function is designed for Verus verification and directly computes\na SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n\n# Inputs\n\n* `input`: a byte slice to hash\n\n# Returns\n\nA RistrettoPoint derived from the hash",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1259",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__hash_from_bytes_verus"
        },
        {
            "name": "identity",
            "display_name": "RistrettoPoint::identity",
            "impl_type": "RistrettoPoint",
            "contract": "fn identity() -> (result: RistrettoPoint)\n    ensures\n        is_identity_edwards_point(result.0),\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),",
            "requires": [],
            "ensures": [
                "is_identity_edwards_point(result.0),",
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),"
            ],
            "referenced_specs": [
                "is_identity_edwards_point",
                "is_in_even_subgroup",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1398,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1398",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristrettopoint__identity"
        },
        {
            "name": "mul",
            "display_name": "RistrettoPoint::mul",
            "impl_type": "RistrettoPoint",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)\n// requires clause inherited from MulSpecImpl::mul_req:\n//   scalar.bytes[31] <= 127 && is_well_formed_edwards_point(self.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            edwards_point_as_affine(self.0),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_scalar_mul( edwards_point_as_affine(self.0),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1825,
            "module": "ristretto",
            "doc_comment": "Scalar multiplication: compute `scalar * self`.",
            "math_interpretation": "(n,P) -> [n]P in E/~, scalar mult",
            "informal_interpretation": "Scalar multiplication of a Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1825",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__mul"
        },
        {
            "name": "mul_assign",
            "display_name": "RistrettoPoint::mul_assign",
            "impl_type": "RistrettoPoint",
            "contract": "fn mul_assign(&mut self, scalar: &'b Scalar)\n    requires\n        scalar.bytes[31] <= 127,\n        is_well_formed_edwards_point(old(self).0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = [scalar] * old(self)\n        edwards_point_as_affine(self.0) == edwards_scalar_mul(\n            edwards_point_as_affine(old(self).0),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,",
                "is_well_formed_edwards_point(old(self).0),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(self.0),",
                "edwards_point_as_affine(self.0) == edwards_scalar_mul( edwards_point_as_affine(old(self).0),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1801,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1801",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__mul_assign"
        },
        {
            "name": "mul_base",
            "display_name": "RistrettoPoint::mul_base",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B where B is the Ristretto basepoint\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "scalar.bytes[31] <= 127,"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_scalar_mul( spec_ristretto_basepoint(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ristretto_basepoint"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1868,
            "module": "ristretto",
            "doc_comment": "Fixed-base scalar multiplication by the Ristretto base point.\n\nUses precomputed basepoint tables when the `precomputed-tables` feature\nis enabled, trading off increased code size for ~4x better performance.",
            "math_interpretation": "n -> [n]B, B = Ristretto basepoint",
            "informal_interpretation": "Scalar multiplication of the Ristretto basepoint.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1868",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristrettopoint__mul_base"
        },
        {
            "name": "multiscalar_mul_verus",
            "display_name": "RistrettoPoint::multiscalar_mul_verus",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result:\n    RistrettoPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<RistrettoPoint>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = P> + Clone,\n\n    requires\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_edwards_from_ristretto_iter::<\n            P,\n            J,\n        >(points).len(),\n        forall|i: int|\n            0 <= i < spec_edwards_from_ristretto_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_edwards_from_ristretto_iter::<P, J>(points)[i],\n            ),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_edwards_from_ristretto_iter::<P, J>(points),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_edwards_from_ristretto_iter::< P,",
                "J,",
                ">(points).len(),",
                "forall|i: int| 0 <= i < spec_edwards_from_ristretto_iter::<P, J>(points).len() ==> is_well_formed_edwards_point( #[trigger] spec_edwards_from_ristretto_iter::<P, J>(points)[i],",
                "),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "spec_edwards_from_ristretto_iter::<P, J>(points),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1971,
            "module": "ristretto",
            "doc_comment": "Verus-compatible version of multiscalar_mul (constant-time).\nDelegates to EdwardsPoint::multiscalar_mul_verus.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1971",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__multiscalar_mul_verus"
        },
        {
            "name": "neg",
            "display_name": "RistrettoPoint::neg",
            "impl_type": "RistrettoPoint",
            "contract": "fn neg(self) -> (result:\n    RistrettoPoint)\n// requires clause inherited from NegSpecImpl::neg_req:\n//   fe51_limbs_bounded(&self.0.X, 52) && fe51_limbs_bounded(&self.0.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),"
            ],
            "referenced_specs": [
                "edwards_neg",
                "edwards_point_as_affine",
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1767,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "P -> -P in E/~",
            "informal_interpretation": "Negates a Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1767",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__neg_L1767"
        },
        {
            "name": "neg",
            "display_name": "RistrettoPoint::neg",
            "impl_type": "RistrettoPoint",
            "contract": "fn neg(self) -> (result:\n    RistrettoPoint)\n// requires clause inherited from NegSpecImpl::neg_req:\n//   fe51_limbs_bounded(&self.0.X, 52) && fe51_limbs_bounded(&self.0.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),"
            ],
            "referenced_specs": [
                "edwards_neg",
                "edwards_point_as_affine",
                "fe51_limbs_bounded",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1767,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "P -> -P in E/~",
            "informal_interpretation": "Negates a Ristretto point.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1785",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__neg_L1767"
        },
        {
            "name": "optional_multiscalar_mul_verus",
            "display_name": "RistrettoPoint::optional_multiscalar_mul_verus",
            "impl_type": "RistrettoPoint",
            "contract": "pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    RistrettoPoint,\n>) where\n    S: Borrow<Scalar>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = Option<RistrettoPoint>> + Clone,\n\n    requires\n        spec_scalars_from_iter::<S, I>(scalars).len()\n            == spec_optional_edwards_from_ristretto_iter::<J>(points).len(),\n        forall|i: int|\n            0 <= i < spec_optional_edwards_from_ristretto_iter::<J>(points).len() && (\n            #[trigger] spec_optional_edwards_from_ristretto_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_edwards_from_ristretto_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n        result.is_some() <==> all_points_some(\n            spec_optional_edwards_from_ristretto_iter::<J>(points),\n        ),\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),\n        result.is_some() ==> edwards_point_as_affine(result.unwrap().0) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_edwards_from_ristretto_iter::<J>(points)),\n        ),",
            "requires": [
                "spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_edwards_from_ristretto_iter::<J>(points).len(),",
                "forall|i: int| 0 <= i < spec_optional_edwards_from_ristretto_iter::<J>(points).len() && ( #[trigger] spec_optional_edwards_from_ristretto_iter::<J>(points)[i]).is_some() ==> is_well_formed_edwards_point( spec_optional_edwards_from_ristretto_iter::<J>(points)[i].unwrap(),",
                "),"
            ],
            "ensures": [
                "result.is_some() <==> all_points_some( spec_optional_edwards_from_ristretto_iter::<J>(points),",
                "),",
                "result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),",
                "result.is_some() ==> edwards_point_as_affine(result.unwrap().0) == sum_of_scalar_muls( spec_scalars_from_iter::<S, I>(scalars),",
                "unwrap_points(spec_optional_edwards_from_ristretto_iter::<J>(points)),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2025,
            "module": "ristretto",
            "doc_comment": "Verus-compatible version of optional_multiscalar_mul.\nDelegates to EdwardsPoint::optional_multiscalar_mul_verus.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2025",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__optional_multiscalar_mul_verus"
        },
        {
            "name": "sub",
            "display_name": "RistrettoPoint::sub",
            "impl_type": "RistrettoPoint",
            "contract": "fn sub(self, other: &'b RistrettoPoint) -> (result:\n    RistrettoPoint)\n// requires (from SubSpecImpl::sub_req): is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_sub(\n            edwards_point_as_affine(self.0).0,\n            edwards_point_as_affine(self.0).1,\n            edwards_point_as_affine(other.0).0,\n            edwards_point_as_affine(other.0).1,\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_sub( edwards_point_as_affine(self.0).0,",
                "edwards_point_as_affine(self.0).1,",
                "edwards_point_as_affine(other.0).0,",
                "edwards_point_as_affine(other.0).1,",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1558,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "(P,Q) -> P - Q in E/~",
            "informal_interpretation": "Subtracts two Ristretto points.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1558",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__sub"
        },
        {
            "name": "sub_assign",
            "display_name": "RistrettoPoint::sub_assign",
            "impl_type": "RistrettoPoint",
            "contract": "fn sub_assign(&mut self, _rhs: &RistrettoPoint)\n    requires\n        is_well_formed_edwards_point(old(self).0),\n        is_well_formed_edwards_point(_rhs.0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = old(self) - rhs\n        edwards_point_as_affine(self.0) == edwards_sub(\n            edwards_point_as_affine(old(self).0).0,\n            edwards_point_as_affine(old(self).0).1,\n            edwards_point_as_affine(_rhs.0).0,\n            edwards_point_as_affine(_rhs.0).1,\n        ),",
            "requires": [
                "is_well_formed_edwards_point(old(self).0),",
                "is_well_formed_edwards_point(_rhs.0),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(self.0),",
                "edwards_point_as_affine(self.0) == edwards_sub( edwards_point_as_affine(old(self).0).0,",
                "edwards_point_as_affine(old(self).0).1,",
                "edwards_point_as_affine(_rhs.0).0,",
                "edwards_point_as_affine(_rhs.0).1,",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_sub",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1583,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1583",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__sub_assign"
        },
        {
            "name": "sum",
            "display_name": "RistrettoPoint::sum",
            "impl_type": "RistrettoPoint",
            "contract": "fn sum<I>(iter: I) -> (result: Self) where I: Iterator<Item = T>\n    requires\n        forall|i: int|\n            0 <= i < spec_edwards_from_ristretto_iter::<T, I>(iter).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_edwards_from_ristretto_iter::<T, I>(iter)[i],\n            ),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == sum_of_points(\n            spec_edwards_from_ristretto_iter::<T, I>(iter),\n        ),",
            "requires": [
                "forall|i: int| 0 <= i < spec_edwards_from_ristretto_iter::<T, I>(iter).len() ==> is_well_formed_edwards_point( #[trigger] spec_edwards_from_ristretto_iter::<T, I>(iter)[i],",
                "),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == sum_of_points( spec_edwards_from_ristretto_iter::<T, I>(iter),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1686,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1686",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__sum"
        },
        {
            "name": "zeroize",
            "display_name": "RistrettoPoint::zeroize",
            "impl_type": "RistrettoPoint",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2397,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2407",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristrettopoint__zeroize"
        },
        {
            "name": "mul",
            "display_name": "Scalar::mul",
            "impl_type": "Scalar",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)\n// requires clause inherited from MulSpecImpl::mul_req:\n//   scalar.bytes[31] <= 127 && is_well_formed_edwards_point(self.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            edwards_point_as_affine(self.0),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_scalar_mul( edwards_point_as_affine(self.0),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1825,
            "module": "ristretto",
            "doc_comment": "Scalar multiplication: compute `scalar * self`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1846",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_L1825"
        },
        {
            "name": "mul",
            "display_name": "Scalar::mul",
            "impl_type": "Scalar",
            "contract": "fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)/* requires clause in MulSpecImpl<&Scalar> for &RistrettoBasepointTable in arithm_trait_specs.rs:\n    requires scalar.bytes[31] <= 127\n*/\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_as_nat(scalar),\n        ),",
            "requires": [
                "*/"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "edwards_point_as_affine(result.0) == edwards_scalar_mul( spec_ristretto_basepoint(),",
                "scalar_as_nat(scalar),",
                "),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "edwards_scalar_mul",
                "is_well_formed_edwards_point",
                "scalar_as_nat",
                "spec_ristretto_basepoint"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 2176,
            "module": "ristretto",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2200",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_L2176"
        },
        {
            "name": "coset4",
            "display_name": "coset4",
            "impl_type": "",
            "contract": "fn coset4(&self) -> (result: [EdwardsPoint; 4])\n    requires\n        is_well_formed_edwards_point(self.0),\n    ensures\n        is_well_formed_edwards_point(result[0]),\n        is_well_formed_edwards_point(result[1]),\n        is_well_formed_edwards_point(result[2]),\n        is_well_formed_edwards_point(result[3]),\n        is_ristretto_coset(result, self.0),",
            "requires": [
                "is_well_formed_edwards_point(self.0),"
            ],
            "ensures": [
                "is_well_formed_edwards_point(result[0]),",
                "is_well_formed_edwards_point(result[1]),",
                "is_well_formed_edwards_point(result[2]),",
                "is_well_formed_edwards_point(result[3]),",
                "is_ristretto_coset(result, self.0),"
            ],
            "referenced_specs": [
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1085,
            "module": "ristretto",
            "doc_comment": "Return the coset self + E\\[4\\], for debugging.\n\nThe result represents the Ristretto equivalence class of self -\nall 4 points map to the same Ristretto point.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1085",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "ristretto__coset4"
        },
        {
            "name": "elligator_ristretto_flavor",
            "display_name": "elligator_ristretto_flavor",
            "impl_type": "",
            "contract": "pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> (result: RistrettoPoint)\n    ensures\n// The result is the Elligator map applied to r_0\n\n        edwards_point_as_affine(result.0) == spec_elligator_ristretto_flavor(\n            fe51_as_canonical_nat(r_0),\n        ),\n        // The result is a valid Ristretto point: well-formed and in the even subgroup\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),",
            "requires": [],
            "ensures": [
                "edwards_point_as_affine(result.0) == spec_elligator_ristretto_flavor( fe51_as_canonical_nat(r_0),",
                "),",
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_in_even_subgroup",
                "is_well_formed_edwards_point",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1115,
            "module": "ristretto",
            "doc_comment": "Computes the Ristretto Elligator map. This is the\n[`MAP`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4)\nfunction defined in the Ristretto spec.\n\n# Note\n\nThis method is not public because it's just used for hashing\nto a point -- proper elligator support is deferred for now.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1115",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "ristretto__elligator_ristretto_flavor"
        },
        {
            "name": "from_uniform_bytes",
            "display_name": "from_uniform_bytes",
            "impl_type": "",
            "contract": "pub fn from_uniform_bytes(bytes: &[u8; 64]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(bytes),\n        // Uniform input bytes produce uniformly distributed point\n        is_uniform_bytes(bytes) ==> is_uniform_ristretto_point(&result),",
            "requires": [],
            "ensures": [
                "is_well_formed_edwards_point(result.0),",
                "is_in_even_subgroup(result.0),",
                "edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(bytes),",
                "is_uniform_bytes(bytes) ==> is_uniform_ristretto_point(&result),"
            ],
            "referenced_specs": [
                "edwards_point_as_affine",
                "is_in_even_subgroup",
                "is_well_formed_edwards_point"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 1331,
            "module": "ristretto",
            "doc_comment": "Construct a `RistrettoPoint` from 64 bytes of data.\n\nIf the input bytes are uniformly distributed, the resulting\npoint will be uniformly distributed over the group, and its\ndiscrete log with respect to other points should be unknown.\n\n# Implementation\n\nThis function splits the input array into two 32-byte halves,\ntakes the low 255 bits of each half mod p, applies the\nRistretto-flavored Elligator map to each, and adds the results.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1331",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "ristretto__from_uniform_bytes"
        },
        {
            "name": "step_1",
            "display_name": "step_1",
            "impl_type": "",
            "contract": "pub(super) fn step_1(repr: &CompressedRistretto) -> (result: (Choice, Choice, FieldElement))\n    ensures\n// s has 51-bit limb bounds (ensured by from_bytes)\n\n        fe51_limbs_bounded(&result.2, 51),\n        // Parsed value matches the bytes-to-field-element spec\n        fe51_as_canonical_nat(&result.2) == field_element_from_bytes(&repr.0),\n        // s_encoding_is_canonical: true iff re-encoding s gives the original bytes\n        choice_is_true(result.0) == (spec_fe51_to_bytes(&result.2) == repr.0@),\n        // s_is_negative: true iff low bit of canonical encoding is 1\n        choice_is_true(result.1) == (spec_fe51_to_bytes(&result.2)[0] & 1 == 1),\n        // s_is_negative matches the math-level sign bit of the decoded value\n        choice_is_true(result.1) == is_negative(field_element_from_bytes(&repr.0)),",
            "requires": [],
            "ensures": [
                "fe51_limbs_bounded(&result.2, 51),",
                "fe51_as_canonical_nat(&result.2) == field_element_from_bytes(&repr.0),",
                "choice_is_true(result.0) == (spec_fe51_to_bytes(&result.2) == repr.0@),",
                "choice_is_true(result.1) == (spec_fe51_to_bytes(&result.2)[0] & 1 == 1),",
                "choice_is_true(result.1) == is_negative(field_element_from_bytes(&repr.0)),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded",
                "is_negative",
                "fe51_as_canonical_nat",
                "field_element_from_bytes"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 385,
            "module": "ristretto",
            "doc_comment": "Decompress step 1: Parse and validate the Ristretto encoding.\n\nReturns (s_encoding_is_canonical, s_is_negative, s) where:\n- s_encoding_is_canonical: true iff input bytes are canonical (< p)\n- s_is_negative: true iff s has its low bit set\n- s: the field element decoded from the compressed representation",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L385",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "ristretto__step_1"
        },
        {
            "name": "step_2",
            "display_name": "step_2",
            "impl_type": "",
            "contract": "pub(super) fn step_2(s: FieldElement) -> (result: (Choice, Choice, Choice, RistrettoPoint))\n    ensures\n// Z is set to ONE by construction\n\n        fe51_as_canonical_nat(&result.3.0.Z) == 1,\n        // T is the product of X and Y in affine form (Z = 1)\n        fe51_as_canonical_nat(&result.3.0.T) == field_mul(\n            fe51_as_canonical_nat(&result.3.0.X),\n            fe51_as_canonical_nat(&result.3.0.Y),\n        ),\n        // If decoding succeeds, the output point is well-formed and in the even subgroup\n        choice_is_true(result.0) ==> is_well_formed_edwards_point(result.3.0),\n        choice_is_true(result.0) ==> is_in_even_subgroup(result.3.0),\n        // t_is_negative reflects the sign bit of T\n        choice_is_true(result.1) == is_negative(fe51_as_canonical_nat(&result.3.0.T)),\n        // y_is_zero reflects whether Y is zero\n        choice_is_true(result.2) == (fe51_as_canonical_nat(&result.3.0.Y) == 0),",
            "requires": [],
            "ensures": [
                "fe51_as_canonical_nat(&result.3.0.Z) == 1,",
                "fe51_as_canonical_nat(&result.3.0.T) == field_mul( fe51_as_canonical_nat(&result.3.0.X),",
                "fe51_as_canonical_nat(&result.3.0.Y),",
                "),",
                "choice_is_true(result.0) ==> is_well_formed_edwards_point(result.3.0),",
                "choice_is_true(result.0) ==> is_in_even_subgroup(result.3.0),",
                "choice_is_true(result.1) == is_negative(fe51_as_canonical_nat(&result.3.0.T)),",
                "choice_is_true(result.2) == (fe51_as_canonical_nat(&result.3.0.Y) == 0),"
            ],
            "referenced_specs": [
                "is_in_even_subgroup",
                "is_well_formed_edwards_point",
                "field_mul",
                "is_negative",
                "fe51_as_canonical_nat"
            ],
            "file": "curve25519-dalek/src/ristretto.rs",
            "line": 435,
            "module": "ristretto",
            "doc_comment": "Decompress step 2: Compute the Edwards point from the field element s.\n\nReturns (ok, t_is_negative, y_is_zero, point) where:\n- ok: true iff the sqrt_ratio succeeded (s encodes a valid point)\n- t_is_negative: true iff T coordinate has low bit set\n- y_is_zero: true iff Y coordinate is zero\n- point: the computed RistrettoPoint",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L435",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "ristretto__step_2"
        },
        {
            "name": "add",
            "display_name": "Scalar::add",
            "impl_type": "Scalar",
            "contract": "fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n    ensures\n        u8_32_as_nat(&result.bytes) == (u8_32_as_nat(&self.bytes) + u8_32_as_nat(\n            &_rhs.bytes,\n        )) % group_order(),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&result.bytes) == (u8_32_as_nat(&self.bytes) + u8_32_as_nat( &_rhs.bytes,",
                ")) % group_order(),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 662,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L662",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__add"
        },
        {
            "name": "add_assign",
            "display_name": "Scalar::add_assign",
            "impl_type": "Scalar",
            "contract": "fn add_assign(&mut self, _rhs: &'a Scalar)\n    ensures\n        u8_32_as_nat(&self.bytes) == (u8_32_as_nat(&old(self).bytes) + u8_32_as_nat(\n            &_rhs.bytes,\n        )) % group_order(),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&self.bytes) == (u8_32_as_nat(&old(self).bytes) + u8_32_as_nat( &_rhs.bytes,",
                ")) % group_order(),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 728,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L728",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__add_assign"
        },
        {
            "name": "as_bytes",
            "display_name": "Scalar::as_bytes",
            "impl_type": "Scalar",
            "contract": "pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == &self.bytes,\n        scalar_as_nat(self) == u8_32_as_nat(&result),",
            "requires": [],
            "ensures": [
                "result == &self.bytes,",
                "scalar_as_nat(self) == u8_32_as_nat(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1619,
            "module": "scalar",
            "doc_comment": "View the little-endian byte encoding of the integer representing this Scalar.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet s: Scalar = Scalar::ZERO;\n\nassert!(s.as_bytes() == &[0u8; 32]);\n```",
            "math_interpretation": "&Scalar -> &[u8; 32]",
            "informal_interpretation": "Returns a reference to the scalar's byte representation.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1619",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__as_bytes"
        },
        {
            "name": "as_radix_16",
            "display_name": "Scalar::as_radix_16",
            "impl_type": "Scalar",
            "contract": "pub(crate) fn as_radix_16(&self) -> (result:\n    [i8; 64])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n// Top bit must be clear (scalar < 2^255)\n\n        self.bytes[31] <= 127,\n    ensures\n// Result digits are in valid range\n\n        is_valid_radix_16(&result),\n        // Simple bounds: all digits in [-8, 8] for easy access\n        radix_16_all_bounded(&result),\n        // Reconstruction property: digits reconstruct the scalar value\n        reconstruct_radix_16(result@) == scalar_as_nat(self) as int,",
            "requires": [
                "self.bytes[31] <= 127,"
            ],
            "ensures": [
                "is_valid_radix_16(&result),",
                "radix_16_all_bounded(&result),",
                "reconstruct_radix_16(result@) == scalar_as_nat(self) as int,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2456,
            "module": "scalar",
            "doc_comment": "Write this scalar in radix 16, with coefficients in \\\\([-8,8)\\\\),\ni.e., compute \\\\(a\\_i\\\\) such that\n$$\na = a\\_0 + a\\_1 16\\^1 + \\cdots + a_{63} 16\\^{63},\n$$\nwith \\\\(-8 \\leq a_i < 8\\\\) for \\\\(0 \\leq i < 63\\\\) and \\\\(-8 \\leq a_{63} \\leq 8\\\\).\n\nThe largest value that can be decomposed like this is just over \\\\(2^{255}\\\\). Thus, in\norder to not error, the top bit MUST NOT be set, i.e., `Self` MUST be less than\n\\\\(2^{255}\\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2456",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__as_radix_16"
        },
        {
            "name": "as_radix_2w",
            "display_name": "Scalar::as_radix_2w",
            "impl_type": "Scalar",
            "contract": "pub(crate) fn as_radix_2w(&self, w: usize) -> (result:\n    [i8; 64])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        4 <= w <= 8,\n        // For w=4 (radix 16), top bit must be clear\n        w == 4 ==> self.bytes[31] <= 127,\n    ensures\n        ({\n            let digits_count = if w < 8 {\n                (256 + (w as int) - 1) / (w as int)\n            } else {\n                (256 + (w as int) - 1) / (w as int) + 1\n            };\n            // Result digits are in valid range for the given window size\n            is_valid_radix_2w(&result, w as nat, digits_count as nat)\n                &&\n            // Reconstruction property: digits reconstruct the scalar value\n            reconstruct_radix_2w(result@.take(digits_count), w as nat) == scalar_as_nat(\n                self,\n            ) as int\n        }),",
            "requires": [
                "4 <= w <= 8,",
                "w == 4 ==> self.bytes[31] <= 127,"
            ],
            "ensures": [
                "({ let digits_count = if w < 8 { (256 + (w as int) - 1) / (w as int) } else { (256 + (w as int) - 1) / (w as int) + 1 }; // Result digits are in valid range for the given window size is_valid_radix_2w(&result, w as nat, digits_count as nat) && // Reconstruction property: digits reconstruct the scalar value reconstruct_radix_2w(result@.take(digits_count), w as nat) == scalar_as_nat( self, ) as int }),"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2590,
            "module": "scalar",
            "doc_comment": "Creates a representation of a Scalar in radix \\\\( 2^w \\\\) with \\\\(w = 4, 5, 6, 7, 8\\\\) for\nuse with the Pippenger algorithm. Higher radixes are not supported to save cache space.\nRadix 256 is near-optimal even for very large inputs.\n\nRadix below 16 or above 256 is prohibited.\nThis method returns digits in a fixed-sized array, excess digits are zeroes.\n\nFor radix 16, `Self` must be less than \\\\(2^{255}\\\\). This is because most integers larger\nthan \\\\(2^{255}\\\\) are unrepresentable in the form described below for \\\\(w = 4\\\\). This\nwould be true for \\\\(w = 8\\\\) as well, but it is compensated for by increasing the size\nhint by 1.\n\n## Scalar representation\n\nRadix \\\\(2\\^w\\\\), with \\\\(n = ceil(256/w)\\\\) coefficients in \\\\([-(2\\^w)/2,(2\\^w)/2)\\\\),\ni.e., scalar is represented using digits \\\\(a\\_i\\\\) such that\n$$\na = a\\_0 + a\\_1 2\\^1w + \\cdots + a_{n-1} 2\\^{w*(n-1)},\n$$\nwith \\\\(-2\\^w/2 \\leq a_i < 2\\^w/2\\\\) for \\\\(0 \\leq i < (n-1)\\\\) and \\\\(-2\\^w/2 \\leq a_{n-1} \\leq 2\\^w/2\\\\).\n",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2590",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__as_radix_2w"
        },
        {
            "name": "batch_invert",
            "display_name": "Scalar::batch_invert",
            "impl_type": "Scalar",
            "contract": "pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n    Scalar)/* <VERIFICATION NOTE>\n Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the modular inverse of the product of all original inputs\n\n        is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n        // Each input is replaced with its inverse\n        forall|i: int|\n            0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                &(#[trigger] old(inputs)[i]),\n                &(#[trigger] inputs[i]),\n            ),",
            "requires": [],
            "ensures": [
                "is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),",
                "forall|i: int| 0 <= i < inputs.len() ==> #[trigger] is_inverse( &(#[trigger] old(inputs)[i]),",
                "&(#[trigger] inputs[i]),",
                "),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1739,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1739",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__batch_invert"
        },
        {
            "name": "bits_le",
            "display_name": "Scalar::bits_le",
            "impl_type": "Scalar",
            "contract": "pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n    /* <VERIFICATION NOTE>\n    - Opaque types like Iterator not supported in Verus yet\n    - see bits_le_verus below for a Verus-compatible version\n    </VERIFICATION NOTE> */\n    (0..256).map(|i| {\n        // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n        // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n        // little-endian on the bit level\n        ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n    })\n}\n</ORIGINAL CODE> */\n/// Get the bits of the scalar as an array, in little-endian order\n/* <VERIFICATION NOTE>\n     This is a Verus-compatible version of bits_le from above that returns an array instead of an iterator\n    </VERIFICATION NOTE> */\n#[allow(dead_code)]\npub(crate) fn bits_le(&self) -> (result: [bool; 256])\n    ensures\n        bits_as_nat(&result) == u8_32_as_nat(&self.bytes),",
            "requires": [],
            "ensures": [
                "bits_as_nat(&result) == u8_32_as_nat(&self.bytes),"
            ],
            "referenced_specs": [
                "u8_32_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2180,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2198",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__bits_le"
        },
        {
            "name": "ct_eq",
            "display_name": "Scalar::ct_eq",
            "impl_type": "Scalar",
            "contract": "fn ct_eq(&self, other: &Self) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.bytes == other.bytes),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == (self.bytes == other.bytes),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 457,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "a =? b in Z/LZ (constant-time)",
            "informal_interpretation": "Constant-time equality comparison of two scalars.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L457",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__ct_eq"
        },
        {
            "name": "from",
            "display_name": "Scalar::from",
            "impl_type": "Scalar",
            "contract": "fn from(x: u8) -> (result: Scalar)\n    ensures\n        scalar_as_nat(&result) == x as nat,",
            "requires": [],
            "ensures": [
                "scalar_as_nat(&result) == x as nat,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1139,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "n: u64 -> Scalar(n mod L)",
            "informal_interpretation": "Converts a u64 integer to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1139",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_L1139"
        },
        {
            "name": "from",
            "display_name": "Scalar::from",
            "impl_type": "Scalar",
            "contract": "fn from(x: u8) -> (result: Scalar)\n    ensures\n        scalar_as_nat(&result) == x as nat,",
            "requires": [],
            "ensures": [
                "scalar_as_nat(&result) == x as nat,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1139,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "n: u64 -> Scalar(n mod L)",
            "informal_interpretation": "Converts a u64 integer to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1159",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_L1139"
        },
        {
            "name": "from",
            "display_name": "Scalar::from",
            "impl_type": "Scalar",
            "contract": "fn from(x: u16) -> (result: Scalar)\n    ensures\n        scalar_as_nat(&result) == x as nat,",
            "requires": [],
            "ensures": [
                "scalar_as_nat(&result) == x as nat,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1159,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "n: u64 -> Scalar(n mod L)",
            "informal_interpretation": "Converts a u64 integer to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1195",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_L1159"
        },
        {
            "name": "from",
            "display_name": "Scalar::from",
            "impl_type": "Scalar",
            "contract": "fn from(x: u64) -> (result: Scalar)\n    ensures\n        scalar_as_nat(&result) == x as nat,",
            "requires": [],
            "ensures": [
                "scalar_as_nat(&result) == x as nat,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1249,
            "module": "scalar",
            "doc_comment": "Construct a scalar from the given `u64`.\n\n# Inputs\n\nAn `u64` to convert to a `Scalar`.\n\n# Returns\n\nA `Scalar` corresponding to the input `u64`.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet fourtytwo = Scalar::from(42u64);\nlet six = Scalar::from(6u64);\nlet seven = Scalar::from(7u64);\n\nassert!(fourtytwo == six * seven);\n```",
            "math_interpretation": "n: u64 -> Scalar(n mod L)",
            "informal_interpretation": "Converts a u64 integer to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1249",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_L1249"
        },
        {
            "name": "from",
            "display_name": "Scalar::from",
            "impl_type": "Scalar",
            "contract": "fn from(x: u64) -> (result: Scalar)\n    ensures\n        scalar_as_nat(&result) == x as nat,",
            "requires": [],
            "ensures": [
                "scalar_as_nat(&result) == x as nat,"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1249,
            "module": "scalar",
            "doc_comment": "Construct a scalar from the given `u64`.\n\n# Inputs\n\nAn `u64` to convert to a `Scalar`.\n\n# Returns\n\nA `Scalar` corresponding to the input `u64`.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet fourtytwo = Scalar::from(42u64);\nlet six = Scalar::from(6u64);\nlet seven = Scalar::from(7u64);\n\nassert!(fourtytwo == six * seven);\n```",
            "math_interpretation": "n: u64 -> Scalar(n mod L)",
            "informal_interpretation": "Converts a u64 integer to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1281",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_L1249"
        },
        {
            "name": "from_bytes_mod_order",
            "display_name": "Scalar::from_bytes_mod_order",
            "impl_type": "Scalar",
            "contract": "pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n    ensures\n// Result is equivalent to input modulo the group order\n\n        u8_32_as_nat(&result.bytes) % group_order() == u8_32_as_nat(&bytes) % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&result.bytes) % group_order() == u8_32_as_nat(&bytes) % group_order(),",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 258,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "b -> LE(b) mod L, L = group order",
            "informal_interpretation": "Constructs a Scalar by reducing a 256-bit integer modulo the group order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L258",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_bytes_mod_order"
        },
        {
            "name": "from_bytes_mod_order_wide",
            "display_name": "Scalar::from_bytes_mod_order_wide",
            "impl_type": "Scalar",
            "contract": "pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n    ensures\n        u8_32_as_nat(&result.bytes) % group_order() == bytes_seq_as_nat(input@)\n            % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),\n        // Uniformity: reducing 512 uniform bits mod L (≈2^253) produces nearly uniform scalar.\n        // Bias: at most L/2^512 ≈ 2^-259 statistical distance from uniform (cryptographically negligible).\n        is_uniform_bytes(input) ==> is_uniform_scalar(&result),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&result.bytes) % group_order() == bytes_seq_as_nat(input@) % group_order(),",
                "is_canonical_scalar(&result),",
                "is_uniform_bytes(input) ==> is_uniform_scalar(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "bytes_seq_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 287,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "b: [u8;64] -> LE(b) mod L",
            "informal_interpretation": "Constructs a Scalar by reducing a 512-bit integer modulo the group order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L287",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_bytes_mod_order_wide"
        },
        {
            "name": "from_canonical_bytes",
            "display_name": "Scalar::from_canonical_bytes",
            "impl_type": "Scalar",
            "contract": "pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n    ensures\n        u8_32_as_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n        u8_32_as_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n        ct_option_has_value(result) ==> u8_32_as_nat(&ct_option_value(result).bytes)\n            % group_order() == u8_32_as_nat(&bytes) % group_order(),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&bytes) < group_order() ==> ct_option_has_value(result),",
                "u8_32_as_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),",
                "ct_option_has_value(result) ==> u8_32_as_nat(&ct_option_value(result).bytes) % group_order() == u8_32_as_nat(&bytes) % group_order(),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 350,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "b -> Some(s) if LE(b) < L else None",
            "informal_interpretation": "Constructs a Scalar from canonical bytes (rejects non-canonical).",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L350",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__from_canonical_bytes"
        },
        {
            "name": "from_hash_verus",
            "display_name": "Scalar::from_hash_verus",
            "impl_type": "Scalar",
            "contract": "pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n    ensures\n        is_uniform_bytes(&hash_bytes) ==> is_uniform_scalar(&result),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),",
            "requires": [],
            "ensures": [
                "is_uniform_bytes(&hash_bytes) ==> is_uniform_scalar(&result),",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1578,
            "module": "scalar",
            "doc_comment": "Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n\nThis function is designed for Verus verification and takes a byte array directly\ninstead of a generic Digest type. For regular code, use `from_hash` instead.\n\n# Inputs\n\n* `hash_bytes`: a 64-byte array representing the output of a hash function\n\n# Returns\n\nA scalar reduced modulo the group order",
            "math_interpretation": "h: [u8;64] -> LE(h) mod L",
            "informal_interpretation": "Constructs a Scalar from a 64-byte hash output reduced mod L.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1578",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__from_hash_verus"
        },
        {
            "name": "hash_from_bytes_verus",
            "display_name": "Scalar::hash_from_bytes_verus",
            "impl_type": "Scalar",
            "contract": "pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n    ensures\n        is_uniform_bytes(input) ==> is_uniform_scalar(&result),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),",
            "requires": [],
            "ensures": [
                "is_uniform_bytes(input) ==> is_uniform_scalar(&result),",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1503,
            "module": "scalar",
            "doc_comment": "Verus-compatible version of hash_from_bytes that uses SHA-512.\n\nThis function is designed for Verus verification and directly computes\na SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n\n# Inputs\n\n* `input`: a byte slice to hash\n\n# Returns\n\nA scalar reduced modulo the group order",
            "math_interpretation": "input -> SHA-512(input) mod L",
            "informal_interpretation": "Hashes input bytes with SHA-512 and reduces to a Scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1503",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__hash_from_bytes_verus"
        },
        {
            "name": "index",
            "display_name": "Scalar::index",
            "impl_type": "Scalar",
            "contract": "fn index(&self, _index: usize) -> (result: &u8)\n    requires\n        _index < 32,\n    ensures\n        result == &self.bytes[_index as int],",
            "requires": [
                "_index < 32,"
            ],
            "ensures": [
                "result == &self.bytes[_index as int],"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 475,
            "module": "scalar",
            "doc_comment": "Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L475",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__index"
        },
        {
            "name": "invert",
            "display_name": "Scalar::invert",
            "impl_type": "Scalar",
            "contract": "pub fn invert(&self) -> (result: Scalar)\n    requires\n        is_canonical_scalar(self),\n    ensures\n// Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n        (scalar_as_nat(&result) * scalar_as_nat(self)) % group_order() == 1,\n        is_canonical_scalar(&result),",
            "requires": [
                "is_canonical_scalar(self),"
            ],
            "ensures": [
                "(scalar_as_nat(&result) * scalar_as_nat(self)) % group_order() == 1,",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "group_order",
                "is_canonical_scalar",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1667,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "s -> s^(-1) mod L, multiplicative inverse",
            "informal_interpretation": "Computes the multiplicative inverse of a scalar modulo the group order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1667",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__invert"
        },
        {
            "name": "is_canonical",
            "display_name": "Scalar::is_canonical",
            "impl_type": "Scalar",
            "contract": "fn is_canonical(&self) -> (result: Choice)\n    ensures\n// Result is true iff the scalar satisfies Scalar invariants #1 and #2\n\n        choice_is_true(result) == is_canonical_scalar(self),",
            "requires": [],
            "ensures": [
                "choice_is_true(result) == is_canonical_scalar(self),"
            ],
            "referenced_specs": [
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2877,
            "module": "scalar",
            "doc_comment": "Check whether this `Scalar` is the canonical representative mod \\\\(\\ell\\\\). This is not\npublic because any `Scalar` that is publicly observed is reduced, by scalar invariant #2.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2877",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__is_canonical"
        },
        {
            "name": "mul",
            "display_name": "Scalar::mul",
            "impl_type": "Scalar",
            "contract": "fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n    ensures\n        u8_32_as_nat(&result.bytes) % group_order() == (u8_32_as_nat(&self.bytes)\n            * u8_32_as_nat(&_rhs.bytes)) % group_order(),\n        is_canonical_scalar(&result),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&result.bytes) % group_order() == (u8_32_as_nat(&self.bytes) * u8_32_as_nat(&_rhs.bytes)) % group_order(),",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 578,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L578",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_L578"
        },
        {
            "name": "mul_assign",
            "display_name": "Scalar::mul_assign",
            "impl_type": "Scalar",
            "contract": "fn mul_assign(&mut self, _rhs: &'a Scalar)\n    requires\n        is_canonical_scalar(old(self)),\n        is_canonical_scalar(_rhs),\n    ensures\n        u8_32_as_nat(&self.bytes) % group_order() == (u8_32_as_nat(&old(self).bytes)\n            * u8_32_as_nat(&_rhs.bytes)) % group_order(),\n        is_canonical_scalar(self),",
            "requires": [
                "is_canonical_scalar(old(self)),",
                "is_canonical_scalar(_rhs),"
            ],
            "ensures": [
                "u8_32_as_nat(&self.bytes) % group_order() == (u8_32_as_nat(&old(self).bytes) * u8_32_as_nat(&_rhs.bytes)) % group_order(),",
                "is_canonical_scalar(self),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 495,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L495",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__mul_assign"
        },
        {
            "name": "neg",
            "display_name": "Scalar::neg",
            "impl_type": "Scalar",
            "contract": "fn neg(self) -> (result: Scalar)\n    ensures\n        (scalar_as_nat(self) + scalar_as_nat(&result)) % group_order() == 0,",
            "requires": [],
            "ensures": [
                "(scalar_as_nat(self) + scalar_as_nat(&result)) % group_order() == 0,"
            ],
            "referenced_specs": [
                "group_order",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 884,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "s -> -s mod L",
            "informal_interpretation": "Negates a scalar modulo the group order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L884",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__neg_L884"
        },
        {
            "name": "neg",
            "display_name": "Scalar::neg",
            "impl_type": "Scalar",
            "contract": "fn neg(self) -> (result: Scalar)\n    ensures\n        (scalar_as_nat(&self) + scalar_as_nat(&result)) % group_order() == 0,",
            "requires": [],
            "ensures": [
                "(scalar_as_nat(&self) + scalar_as_nat(&result)) % group_order() == 0,"
            ],
            "referenced_specs": [
                "group_order",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 975,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "s -> -s mod L",
            "informal_interpretation": "Negates a scalar modulo the group order.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L975",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__neg_L975"
        },
        {
            "name": "non_adjacent_form",
            "display_name": "Scalar::non_adjacent_form",
            "impl_type": "Scalar",
            "contract": "pub(crate) fn non_adjacent_form(&self, w: usize) -> (result:\n    [i8; 256])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        2 <= w <= 8,\n    ensures\n// result encodes the same integer\n\n        reconstruct(result@) == scalar_as_nat(self) as int,\n        // result digits follow NAF rules\n        is_valid_naf(result@, w as nat),",
            "requires": [
                "2 <= w <= 8,"
            ],
            "ensures": [
                "reconstruct(result@) == scalar_as_nat(self) as int,",
                "is_valid_naf(result@, w as nat),"
            ],
            "referenced_specs": [
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2318,
            "module": "scalar",
            "doc_comment": "Compute a width-\\\\(w\\\\) \"Non-Adjacent Form\" of this scalar.\n\nA width-\\\\(w\\\\) NAF of a positive integer \\\\(k\\\\) is an expression\n$$\nk = \\sum_{i=0}\\^m n\\_i 2\\^i,\n$$\nwhere each nonzero\ncoefficient \\\\(n\\_i\\\\) is odd and bounded by \\\\(|n\\_i| < 2\\^{w-1}\\\\),\n\\\\(n\\_{m-1}\\\\) is nonzero, and at most one of any \\\\(w\\\\) consecutive\ncoefficients is nonzero.  (Hankerson, Menezes, Vanstone; def 3.32).\n\nThe length of the NAF is at most one more than the length of\nthe binary representation of \\\\(k\\\\).  This is why the\n`Scalar` type maintains an invariant (invariant #1) that the top bit is\n\\\\(0\\\\), so that the NAF of a scalar has at most 256 digits.\n\nIntuitively, this is like a binary expansion, except that we\nallow some coefficients to grow in magnitude up to\n\\\\(2\\^{w-1}\\\\) so that the nonzero coefficients are as sparse\nas possible.\n\nWhen doing scalar multiplication, we can then use a lookup\ntable of precomputed multiples of a point to add the nonzero\nterms \\\\( k_i P \\\\).  Using signed digits cuts the table size\nin half, and using odd digits cuts the table size in half\nagain.\n\nTo compute a \\\\(w\\\\)-NAF, we use a modification of Algorithm 3.35 of HMV:\n\n1. \\\\( i \\gets 0 \\\\)\n2. While \\\\( k \\ge 1 \\\\):\n1. If \\\\(k\\\\) is odd, \\\\( n_i \\gets k \\operatorname{mods} 2^w \\\\), \\\\( k \\gets k - n_i \\\\).\n2. If \\\\(k\\\\) is even, \\\\( n_i \\gets 0 \\\\).\n3. \\\\( k \\gets k / 2 \\\\), \\\\( i \\gets i + 1 \\\\).\n3. Return \\\\( n_0, n_1, ... , \\\\)\n\nHere \\\\( \\bar x = x \\operatorname{mods} 2^w \\\\) means the\n\\\\( \\bar x \\\\) with \\\\( \\bar x \\equiv x \\pmod{2^w} \\\\) and\n\\\\( -2^{w-1} \\leq \\bar x < 2^{w-1} \\\\).\n\nWe implement this by scanning across the bits of \\\\(k\\\\) from\nleast-significant bit to most-significant-bit.\nWrite the bits of \\\\(k\\\\) as\n$$\nk = \\sum\\_{i=0}\\^m k\\_i 2^i,\n$$\nand split the sum as\n$$\nk = \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n$$\nwhere the first part is \\\\( k \\mod 2^w \\\\).\n\nIf \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w < 2^{w-1} \\\\), then we emit\n\\\\( n_0 = k \\mod 2^w \\\\).  Instead of computing\n\\\\( k - n_0 \\\\), we just advance \\\\(w\\\\) bits and reindex.\n\nIf \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w \\ge 2^{w-1} \\\\), then\n\\\\( n_0 = k \\operatorname{mods} 2^w = k \\mod 2^w - 2^w \\\\).\nThe quantity \\\\( k - n_0 \\\\) is\n$$\n\\begin{aligned}\nk - n_0 &= \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n- \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\\\\\\\\n&= 2^w + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n\\end{aligned}\n$$\nso instead of computing the subtraction, we can set a carry\nbit, advance \\\\(w\\\\) bits, and reindex.\n\nIf \\\\( k \\mod 2^w\\\\) is even, we emit \\\\(0\\\\), advance 1 bit\nand reindex.  In fact, by setting all digits to \\\\(0\\\\)\ninitially, we don't need to emit anything.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2318",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__non_adjacent_form"
        },
        {
            "name": "reduce",
            "display_name": "Scalar::reduce",
            "impl_type": "Scalar",
            "contract": "fn reduce(&self) -> (result: Scalar)\n    ensures\n// Result is equivalent to input modulo the group order\n\n        u8_32_as_nat(&result.bytes) % group_order() == u8_32_as_nat(&self.bytes)\n            % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),",
            "requires": [],
            "ensures": [
                "u8_32_as_nat(&result.bytes) % group_order() == u8_32_as_nat(&self.bytes) % group_order(),",
                "is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2805,
            "module": "scalar",
            "doc_comment": "Reduce this `Scalar` modulo \\\\(\\ell\\\\).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2805",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__reduce"
        },
        {
            "name": "sub",
            "display_name": "Scalar::sub",
            "impl_type": "Scalar",
            "contract": "fn sub(self, _rhs: &'b Scalar) -> (result:\n    Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n        is_canonical_scalar(self),\n        is_canonical_scalar(rhs)\n    */\n\n    ensures\n        u8_32_as_nat(&result.bytes) % group_order() == (u8_32_as_nat(&self.bytes)\n            - u8_32_as_nat(&_rhs.bytes)) % (group_order() as int),",
            "requires": [
                "is_canonical_scalar(self),",
                "is_canonical_scalar(rhs) */"
            ],
            "ensures": [
                "u8_32_as_nat(&result.bytes) % group_order() == (u8_32_as_nat(&self.bytes) - u8_32_as_nat(&_rhs.bytes)) % (group_order() as int),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 763,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L763",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__sub"
        },
        {
            "name": "sub_assign",
            "display_name": "Scalar::sub_assign",
            "impl_type": "Scalar",
            "contract": "fn sub_assign(&mut self, _rhs: &'a Scalar)\n    requires\n        is_canonical_scalar(old(self)),\n        is_canonical_scalar(_rhs),\n    ensures\n        u8_32_as_nat(&self.bytes) % group_order() == (u8_32_as_nat(&old(self).bytes)\n            - u8_32_as_nat(&_rhs.bytes)) % (group_order() as int),",
            "requires": [
                "is_canonical_scalar(old(self)),",
                "is_canonical_scalar(_rhs),"
            ],
            "ensures": [
                "u8_32_as_nat(&self.bytes) % group_order() == (u8_32_as_nat(&old(self).bytes) - u8_32_as_nat(&_rhs.bytes)) % (group_order() as int),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 848,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L848",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__sub_assign"
        },
        {
            "name": "sum",
            "display_name": "Scalar::sum",
            "impl_type": "Scalar",
            "contract": "fn sum<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,",
            "requires": [],
            "ensures": [],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1044,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1059",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__sum"
        },
        {
            "name": "to_bytes",
            "display_name": "Scalar::to_bytes",
            "impl_type": "Scalar",
            "contract": "pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.bytes,\n        scalar_as_nat(self) == u8_32_as_nat(&result),",
            "requires": [],
            "ensures": [
                "result == self.bytes,",
                "scalar_as_nat(self) == u8_32_as_nat(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "scalar_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1600,
            "module": "scalar",
            "doc_comment": "Convert this `Scalar` to its underlying sequence of bytes.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet s: Scalar = Scalar::ZERO;\n\nassert!(s.to_bytes() == [0u8; 32]);\n```",
            "math_interpretation": "s in Z/LZ -> [u8; 32] little-endian",
            "informal_interpretation": "Returns the canonical byte encoding of a scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1600",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__to_bytes"
        },
        {
            "name": "to_radix_2w_size_hint",
            "display_name": "Scalar::to_radix_2w_size_hint",
            "impl_type": "Scalar",
            "contract": "pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize\n    requires\n        4 <= w <= 8,\n    returns\n        if w < 8 {\n            (256 + w - 1) / (w as int)\n        } else {\n            (256 + w - 1) / (w as int) + 1\n        } as usize,",
            "requires": [
                "4 <= w <= 8,",
                "returns if w < 8 { (256 + w - 1) / (w as int) } else { (256 + w - 1) / (w as int) + 1 } as usize,"
            ],
            "ensures": [],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2531,
            "module": "scalar",
            "doc_comment": "Returns a size hint indicating how many entries of the return\nvalue of `to_radix_2w` are nonzero.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2531",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__to_radix_2w_size_hint"
        },
        {
            "name": "unpack",
            "display_name": "Scalar::unpack",
            "impl_type": "Scalar",
            "contract": "pub fn unpack(&self) -> (result:\n    UnpackedScalar)\n// VERIFICATION NOTE: VERIFIED (changed pub(crate) to pub)\n\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        scalar52_to_nat(&result) == u8_32_as_nat(&self.bytes),",
            "requires": [],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "scalar52_to_nat(&result) == u8_32_as_nat(&self.bytes),"
            ],
            "referenced_specs": [
                "u8_32_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2791,
            "module": "scalar",
            "doc_comment": "Unpack this `Scalar` to an `UnpackedScalar` for faster arithmetic.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2791",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__unpack"
        },
        {
            "name": "zeroize",
            "display_name": "Scalar::zeroize",
            "impl_type": "Scalar",
            "contract": "fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.bytes[i] == 0u8,",
            "requires": [],
            "ensures": [
                "forall|i: int| 0 <= i < 32 ==> #[trigger] self.bytes[i] == 0u8,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1317,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1317",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__zeroize"
        },
        {
            "name": "invert",
            "display_name": "UnpackedScalar::invert",
            "impl_type": "UnpackedScalar",
            "contract": "pub fn invert(&self) -> (result: UnpackedScalar)\n    requires\n        limbs_bounded(self),\n    ensures\n// Postcondition: result * self ≡ 1 (mod group_order)\n\n        scalar52_to_nat(&result) * scalar52_to_nat(self) % group_order() == 1,\n        // Result is canonical (< group_order) - needed for pack() to produce canonical Scalar\n        is_canonical_scalar52(&result),",
            "requires": [
                "limbs_bounded(self),"
            ],
            "ensures": [
                "scalar52_to_nat(&result) * scalar52_to_nat(self) % group_order() == 1,",
                "is_canonical_scalar52(&result),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 3180,
            "module": "scalar",
            "doc_comment": "Inverts an UnpackedScalar not in Montgomery form.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3180",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": true,
            "id": "unpackedscalar__invert"
        },
        {
            "name": "montgomery_invert",
            "display_name": "UnpackedScalar::montgomery_invert",
            "impl_type": "UnpackedScalar",
            "contract": "pub fn montgomery_invert(&self) -> (result:\n    UnpackedScalar)/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n        limb_prod_bounded_u128(self.limbs, self.limbs, 5),\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        (scalar52_to_nat(&result) * scalar52_to_nat(self)) % group_order() == (\n        montgomery_radix() * montgomery_radix())\n            % group_order(),\n// Equivalent to: from_montgomery(result) * from_montgomery(self) ≡ 1 (mod L)\n// Expressed in Montgomery form: (result/R) * (self/R) ≡ 1, i.e., result * self ≡ R² (mod L)",
            "requires": [
                "limb_prod_bounded_u128(self.limbs, self.limbs, 5),"
            ],
            "ensures": [
                "limbs_bounded(&result),",
                "limb_prod_bounded_u128(result.limbs, result.limbs, 5),",
                "(scalar52_to_nat(&result) * scalar52_to_nat(self)) % group_order() == ( montgomery_radix() * montgomery_radix()) % group_order(),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 3090,
            "module": "scalar",
            "doc_comment": "Inverts an UnpackedScalar in Montgomery form.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3090",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "unpackedscalar__montgomery_invert"
        },
        {
            "name": "pack",
            "display_name": "UnpackedScalar::pack",
            "impl_type": "UnpackedScalar",
            "contract": "fn pack(&self) -> (result: Scalar)\n    requires\n        limbs_bounded(self),\n    ensures\n        u8_32_as_nat(&result.bytes) == scalar52_to_nat(self) % pow2(256),\n        // VERIFICATION NOTE: If input is canonical (< group order), output satisfies Scalar invariants\n        scalar52_to_nat(self) < group_order() ==> is_canonical_scalar(&result),",
            "requires": [
                "limbs_bounded(self),"
            ],
            "ensures": [
                "u8_32_as_nat(&result.bytes) == scalar52_to_nat(self) % pow2(256),",
                "scalar52_to_nat(self) < group_order() ==> is_canonical_scalar(&result),"
            ],
            "referenced_specs": [
                "u8_32_as_nat",
                "group_order",
                "is_canonical_scalar"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 3010,
            "module": "scalar",
            "doc_comment": "Pack the limbs of this `UnpackedScalar` into a `Scalar`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3010",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "unpackedscalar__pack"
        },
        {
            "name": "bot_half",
            "display_name": "bot_half",
            "impl_type": "",
            "contract": "fn bot_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the lower 4 bits (lower nibble) of x\n\n        result == x % 16,\n        // Result is in range [0, 15]\n        result <= 15,",
            "requires": [],
            "ensures": [
                "result == x % 16,",
                "result <= 15,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2137,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2137",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__bot_half"
        },
        {
            "name": "clamp_integer",
            "display_name": "clamp_integer",
            "impl_type": "",
            "contract": "pub const fn clamp_integer(bytes: [u8; 32]) -> (result: [u8; 32])\n    ensures\n// Result is a valid clamped integer for X25519\n\n        is_clamped_integer(&result),\n        // The result matches the spec function\n        result == spec_clamp_integer(bytes),\n        // All bytes except 0 and 31 remain unchanged\n        forall|i: int| 1 <= i < 31 ==> #[trigger] result[i] == bytes[i],\n        // Low byte preserves bits 3-7\n        result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000,\n        // High byte preserves bits 0-5\n        result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111,",
            "requires": [],
            "ensures": [
                "is_clamped_integer(&result),",
                "result == spec_clamp_integer(bytes),",
                "forall|i: int| 1 <= i < 31 ==> #[trigger] result[i] == bytes[i],",
                "result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000,",
                "result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111,"
            ],
            "referenced_specs": [
                "is_clamped_integer",
                "spec_clamp_integer"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 3439,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "clamp: clear bits 0-2 and 255, set bit 254",
            "informal_interpretation": "Clamps a 32-byte integer for use as an X25519 scalar.",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3439",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": true,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__clamp_integer"
        },
        {
            "name": "product",
            "display_name": "product",
            "impl_type": "",
            "contract": "fn product<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,",
            "requires": [],
            "ensures": [],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 1016,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1028",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__product"
        },
        {
            "name": "read_le_u64_into",
            "display_name": "read_le_u64_into",
            "impl_type": "",
            "contract": "fn read_le_u64_into(src: &[u8], dst: &mut [u64])/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n        src.len() == 8 * old(dst).len(),\n    ensures\n        dst.len() == old(dst).len(),\n        forall|i: int|\n            0 <= i < dst.len() ==> {\n                let byte_seq = Seq::new(8, |j: int| src[i * 8 + j] as u8);\n                #[trigger] dst[i] as nat == bytes_seq_as_nat(byte_seq)\n            },",
            "requires": [
                "src.len() == 8 * old(dst).len(),"
            ],
            "ensures": [
                "dst.len() == old(dst).len(),",
                "forall|i: int| 0 <= i < dst.len() ==> { let byte_seq = Seq::new(8, |j: int| src[i * 8 + j] as u8); #[trigger] dst[i] as nat == bytes_seq_as_nat(byte_seq) },"
            ],
            "referenced_specs": [
                "bytes_seq_as_nat"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 3359,
            "module": "scalar",
            "doc_comment": "Read one or more u64s stored as little endian bytes.\n\n## Panics\nPanics if `src.len() != 8 * dst.len()`.",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3359",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "scalar__read_le_u64_into"
        },
        {
            "name": "square_multiply",
            "display_name": "square_multiply",
            "impl_type": "",
            "contract": "fn square_multiply(\n    y: &mut UnpackedScalar,\n    squarings: usize,\n    x: &UnpackedScalar,\n)/*  VERIFICATION NOTE:\n- This function was initially inside the body of montgomery_invert, but was moved outside for Verus\n*/\n\n    requires\n        limb_prod_bounded_u128(old(y).limbs, old(y).limbs, 5),\n        limbs_bounded(x),\n    ensures\n        limbs_bounded(y),\n        limb_prod_bounded_u128(y.limbs, y.limbs, 5),\n        // VERIFICATION NOTE: Changed postcondition from the original incorrect version\n        // which used `montgomery_radix()` instead of `pow(montgomery_radix(), pow2(squarings))`\n        (scalar52_to_nat(y) * pow(montgomery_radix() as int, pow2(squarings as nat)) as nat)\n            % group_order() == (pow(scalar52_to_nat(old(y)) as int, pow2(squarings as nat))\n            * scalar52_to_nat(x)) % (group_order() as int),",
            "requires": [
                "limb_prod_bounded_u128(old(y).limbs, old(y).limbs, 5),",
                "limbs_bounded(x),"
            ],
            "ensures": [
                "limbs_bounded(y),",
                "limb_prod_bounded_u128(y.limbs, y.limbs, 5),",
                "(scalar52_to_nat(y) * pow(montgomery_radix() as int, pow2(squarings as nat)) as nat) % group_order() == (pow(scalar52_to_nat(old(y)) as int, pow2(squarings as nat)) * scalar52_to_nat(x)) % (group_order() as int),"
            ],
            "referenced_specs": [
                "group_order"
            ],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2899,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2899",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__square_multiply"
        },
        {
            "name": "top_half",
            "display_name": "top_half",
            "impl_type": "",
            "contract": "fn top_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the upper 4 bits (upper nibble) of x\n\n        result == x / 16,\n        // Result is in range [0, 15]\n        result <= 15,",
            "requires": [],
            "ensures": [
                "result == x / 16,",
                "result <= 15,"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/scalar.rs",
            "line": 2157,
            "module": "scalar",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2157",
            "category": "tracked",
            "is_public": false,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "scalar__top_half"
        },
        {
            "name": "from",
            "display_name": "LookupTable<AffineNielsPoint>::from",
            "impl_type": "LookupTable<AffineNielsPoint>",
            "contract": "fn from(P: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*P),\n    */\n\n    ensures\n        is_valid_lookup_table_affine(result.0, *P, 8 as nat),\n        // All entries have bounded limbs\n        lookup_table_affine_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_lookup_table_affine(result.0, *P, 8 as nat),",
                "lookup_table_affine_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 360,
            "module": "window",
            "doc_comment": "Create a lookup table from an EdwardsPoint (affine version)\nConstructs [P, 2P, 3P, ..., Size*P]",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L360",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "lookuptable_affinenielspoint__from"
        },
        {
            "name": "select",
            "display_name": "LookupTable<AffineNielsPoint>::select",
            "impl_type": "LookupTable<AffineNielsPoint>",
            "contract": "pub fn select(&self, x: i8) -> (result: T)\n    ensures\n        (x > 0 ==> result == self.0[(x - 1) as int]),\n        // Generic T prevented type-specific specs for x == 0 and x < 0",
            "requires": [],
            "ensures": [
                "(x > 0 ==> result == self.0[(x - 1) as int]),"
            ],
            "referenced_specs": [],
            "file": "curve25519-dalek/src/window.rs",
            "line": 86,
            "module": "window",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L103",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "lookuptable_affinenielspoint__select"
        },
        {
            "name": "from",
            "display_name": "LookupTable<ProjectiveNielsPoint>::from",
            "impl_type": "LookupTable<ProjectiveNielsPoint>",
            "contract": "fn from(P: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*P),\n        sum_of_limbs_bounded(&P.Y, &P.X, u64::MAX),\n    */\n\n    ensures\n        is_valid_lookup_table_projective(result.0, *P, 8 as nat),\n        // All table entries have bounded limbs for subsequent arithmetic\n        lookup_table_projective_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_lookup_table_projective(result.0, *P, 8 as nat),",
                "lookup_table_projective_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 291,
            "module": "window",
            "doc_comment": "Create a lookup table from an EdwardsPoint\nConstructs [P, 2P, 3P, ..., Size*P]",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L291",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "lookuptable_projectivenielspoint__from"
        },
        {
            "name": "select",
            "display_name": "LookupTable<ProjectiveNielsPoint>::select",
            "impl_type": "LookupTable<ProjectiveNielsPoint>",
            "contract": "pub fn select(&self, x: i8) -> (result: ProjectiveNielsPoint)\n    requires\n        -8 <= x,\n        x <= 8,\n        // Table entries must have bounded limbs\n        lookup_table_projective_limbs_bounded(self.0),\n    ensures\n// Formal specification for all cases:\n\n        (x > 0 ==> result == self.0[(x - 1) as int]),\n        (x == 0 ==> result == identity_projective_niels()),\n        (x < 0 ==> result == negate_projective_niels(self.0[((-x) - 1) as int])),\n        // Limb bounds for the result (derived from table bounds)\n        fe51_limbs_bounded(&result.Y_plus_X, 54),\n        fe51_limbs_bounded(&result.Y_minus_X, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T2d, 54),",
            "requires": [
                "-8 <= x,",
                "x <= 8,",
                "lookup_table_projective_limbs_bounded(self.0),"
            ],
            "ensures": [
                "(x > 0 ==> result == self.0[(x - 1) as int]),",
                "(x == 0 ==> result == identity_projective_niels()),",
                "(x < 0 ==> result == negate_projective_niels(self.0[((-x) - 1) as int])),",
                "fe51_limbs_bounded(&result.Y_plus_X, 54),",
                "fe51_limbs_bounded(&result.Y_minus_X, 54),",
                "fe51_limbs_bounded(&result.Z, 54),",
                "fe51_limbs_bounded(&result.T2d, 54),"
            ],
            "referenced_specs": [
                "fe51_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 158,
            "module": "window",
            "doc_comment": "Given \\\\(-8 \\leq x \\leq 8\\\\), return \\\\(xP\\\\) in constant time.\n\nWhere P is the base point that was used to create this lookup table.\nThis table stores [P, 2P, 3P, ..., 8P] (for radix-16).",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L158",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "lookuptable_projectivenielspoint__select"
        },
        {
            "name": "from",
            "display_name": "NafLookupTable5::from",
            "impl_type": "NafLookupTable5",
            "contract": "fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table5_projective(result.0, *A),\n        naf_lookup_table5_projective_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_naf_lookup_table5_projective(result.0, *A),",
                "naf_lookup_table5_projective_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 540,
            "module": "window",
            "doc_comment": "Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L540",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "naflookuptable5__from_L540"
        },
        {
            "name": "from",
            "display_name": "NafLookupTable5::from",
            "impl_type": "NafLookupTable5",
            "contract": "fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table5_affine(result.0, *A),\n        naf_lookup_table5_affine_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_naf_lookup_table5_affine(result.0, *A),",
                "naf_lookup_table5_affine_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 598,
            "module": "window",
            "doc_comment": "Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L598",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "naflookuptable5__from_L598"
        },
        {
            "name": "select",
            "display_name": "NafLookupTable5<AffineNielsPoint>::select",
            "impl_type": "NafLookupTable5<AffineNielsPoint>",
            "contract": "pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 16);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable5<ProjectiveNielsPoint>\nimpl NafLookupTable5<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable5<AffineNielsPoint>\nimpl NafLookupTable5<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\nimpl<T: Copy> Clone for NafLookupTable5<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nverus! {\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_projective(result.0, *A),\n     naf_lookup_table5_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_projective(result.0, *A));\n     assume(naf_lookup_table5_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_affine(result.0, *A),\n     naf_lookup_table5_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_affine(result.0, *A));\n     assume(naf_lookup_table5_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!\nverus! {\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n/* VERIFICATION NOTE:\n   - Changed from pub(crate) to pub to allow Verus verification\n     of requires/ensures clauses that reference self.0.\n   - Removed Clone from #[derive(Copy, Clone)] because Verus does not support\n     autoderive Clone for arrays. Manual Clone impl provided outside verus! macro.\n\n   ORIGINAL CODE:\n   #[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n   #[derive(Copy, Clone)]\n   pub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n*/\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy)]\npub struct NafLookupTable8<T>(pub [T; 64]);\n\n/* VERIFICATION NOTE: Replaced generic NafLookupTable8<T>::select with concrete implementations\n   to allow type-specific specs.\n\n   ORIGINAL CODE:\n   impl<T: Copy> NafLookupTable8<T> {\npub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!",
            "requires": [],
            "ensures": [],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 464,
            "module": "window",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L501",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "naflookuptable5_affinenielspoint__select"
        },
        {
            "name": "select",
            "display_name": "NafLookupTable5<ProjectiveNielsPoint>::select",
            "impl_type": "NafLookupTable5<ProjectiveNielsPoint>",
            "contract": "pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 16);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable5<ProjectiveNielsPoint>\nimpl NafLookupTable5<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable5<AffineNielsPoint>\nimpl NafLookupTable5<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\nimpl<T: Copy> Clone for NafLookupTable5<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nverus! {\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_projective(result.0, *A),\n     naf_lookup_table5_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_projective(result.0, *A));\n     assume(naf_lookup_table5_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_affine(result.0, *A),\n     naf_lookup_table5_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_affine(result.0, *A));\n     assume(naf_lookup_table5_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!\nverus! {\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n/* VERIFICATION NOTE:\n   - Changed from pub(crate) to pub to allow Verus verification\n     of requires/ensures clauses that reference self.0.\n   - Removed Clone from #[derive(Copy, Clone)] because Verus does not support\n     autoderive Clone for arrays. Manual Clone impl provided outside verus! macro.\n\n   ORIGINAL CODE:\n   #[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n   #[derive(Copy, Clone)]\n   pub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n*/\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy)]\npub struct NafLookupTable8<T>(pub [T; 64]);\n\n/* VERIFICATION NOTE: Replaced generic NafLookupTable8<T>::select with concrete implementations\n   to allow type-specific specs.\n\n   ORIGINAL CODE:\n   impl<T: Copy> NafLookupTable8<T> {\npub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!",
            "requires": [],
            "ensures": [],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 464,
            "module": "window",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L476",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "naflookuptable5_projectivenielspoint__select"
        },
        {
            "name": "from",
            "display_name": "NafLookupTable8::from",
            "impl_type": "NafLookupTable8",
            "contract": "fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table8_projective(result.0, *A),\n        naf_lookup_table8_projective_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_naf_lookup_table8_projective(result.0, *A),",
                "naf_lookup_table8_projective_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 764,
            "module": "window",
            "doc_comment": "Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L764",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "naflookuptable8__from_L764"
        },
        {
            "name": "from",
            "display_name": "NafLookupTable8::from",
            "impl_type": "NafLookupTable8",
            "contract": "fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table8_affine(result.0, *A),\n        naf_lookup_table8_affine_limbs_bounded(result.0),",
            "requires": [],
            "ensures": [
                "is_valid_naf_lookup_table8_affine(result.0, *A),",
                "naf_lookup_table8_affine_limbs_bounded(result.0),"
            ],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "is_valid_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 823,
            "module": "window",
            "doc_comment": "Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L823",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": false,
            "id": "naflookuptable8__from_L823"
        },
        {
            "name": "select",
            "display_name": "NafLookupTable8<AffineNielsPoint>::select",
            "impl_type": "NafLookupTable8<AffineNielsPoint>",
            "contract": "pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!",
            "requires": [],
            "ensures": [],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 679,
            "module": "window",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L718",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "naflookuptable8_affinenielspoint__select"
        },
        {
            "name": "select",
            "display_name": "NafLookupTable8<ProjectiveNielsPoint>::select",
            "impl_type": "NafLookupTable8<ProjectiveNielsPoint>",
            "contract": "pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!",
            "requires": [],
            "ensures": [],
            "referenced_specs": [
                "edwards_point_limbs_bounded",
                "fe51_limbs_bounded",
                "is_valid_edwards_point",
                "is_well_formed_edwards_point",
                "sum_of_limbs_bounded"
            ],
            "file": "curve25519-dalek/src/window.rs",
            "line": 679,
            "module": "window",
            "doc_comment": "",
            "math_interpretation": "",
            "informal_interpretation": "",
            "github_link": "https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L692",
            "category": "tracked",
            "is_public": true,
            "is_libsignal": false,
            "has_spec": true,
            "has_proof": true,
            "id": "naflookuptable8_projectivenielspoint__select"
        }
    ]
}