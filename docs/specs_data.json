{"spec_functions":[{"id":"backend__serial__curve_models__add_req","name":"add_req","signature":"open spec fn add_req(self, rhs: &ProjectiveNielsPoint) -> bool","body":"open spec fn add_req(self, rhs: &ProjectiveNielsPoint) -> bool {\n    // Preconditions needed for field operations\n    is_well_formed_edwards_point(*self) && fe51_limbs_bounded(&rhs.Y_plus_X, 54)\n        && fe51_limbs_bounded(&rhs.Y_minus_X, 54) && fe51_limbs_bounded(&rhs.Z, 54)\n        && fe51_limbs_bounded(&rhs.T2d, 54)\n}","file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":835,"module":"backend::serial::curve_models","visibility":"open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L835","category":"spec","referenced_specs":["fe51_limbs_bounded","is_well_formed_edwards_point"]},{"id":"backend__serial__curve_models__neg_req","name":"neg_req","signature":"open spec fn neg_req(self) -> bool","body":"open spec fn neg_req(self) -> bool {\n    // Preconditions: limbs must be bounded for field element negation\n    fe51_limbs_bounded(&self.T2d, 51)\n}","file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":1240,"module":"backend::serial::curve_models","visibility":"open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1240","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"backend__serial__curve_models__sub_req","name":"sub_req","signature":"open spec fn sub_req(self, rhs: &ProjectiveNielsPoint) -> bool","body":"open spec fn sub_req(self, rhs: &ProjectiveNielsPoint) -> bool {\n    // Preconditions needed for field operations\n    is_well_formed_edwards_point(*self) && fe51_limbs_bounded(&rhs.Y_plus_X, 54)\n        && fe51_limbs_bounded(&rhs.Y_minus_X, 54) && fe51_limbs_bounded(&rhs.Z, 54)\n        && fe51_limbs_bounded(&rhs.T2d, 54)\n}","file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":938,"module":"backend::serial::curve_models","visibility":"open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L938","category":"spec","referenced_specs":["fe51_limbs_bounded","is_well_formed_edwards_point"]},{"id":"backend__serial__u64__field__mul_req","name":"mul_req","signature":"open spec fn mul_req(self, rhs: &FieldElement51) -> bool","body":"open spec fn mul_req(self, rhs: &FieldElement51) -> bool {\n    fe51_limbs_bounded(self, 54) && fe51_limbs_bounded(rhs, 54)\n}","file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":473,"module":"backend::serial::u64::field","visibility":"open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L473","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"backend__serial__u64__subtle_assumes__choice_is_true","name":"choice_is_true","signature":"pub uninterp spec fn choice_is_true(c: Choice) -> bool; pub assume_specification[ Choice::from ](u: u8) -> (c: Choice) ensures (u == 1) == choice_is_true(c), ; pub assume_specification[ Choice::unwrap_u8 ](c: &Choice) -> (u: u8) ensures choice_is_true(*c) ==> u == 1u8, !choice_is_true(*c) ==> u == 0u8, ; // VERIFICATION NOTE: For other external functions, we use wrapper functions because: // - Generic functions don't work well with assume_specification // - Trait implementations on arrays have issues with assume_specification /// Wrapper for conditional_select on u64 #[verifier::external_body] pub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64) ensures !choice_is_true(c) ==> res == *a, choice_is_true(c) ==> res == *b,","body":"pub uninterp spec fn choice_is_true(c: Choice) -> bool;\n\npub assume_specification[ Choice::from ](u: u8) -> (c: Choice)\n    ensures\n        (u == 1) == choice_is_true(c),\n;\n\npub assume_specification[ Choice::unwrap_u8 ](c: &Choice) -> (u: u8)\n    ensures\n        choice_is_true(*c) ==> u == 1u8,\n        !choice_is_true(*c) ==> u == 0u8,\n;\n\n// VERIFICATION NOTE: For other external functions, we use wrapper functions because:\n// - Generic functions don't work well with assume_specification\n// - Trait implementations on arrays have issues with assume_specification\n/// Wrapper for conditional_select on u64\n#[verifier::external_body]\npub fn select(a: &u64, b: &u64, c: Choice) -> (res: u64)\n    ensures\n        !choice_is_true(c) ==> res == *a,\n        choice_is_true(c) ==> res == *b,\n{\n    u64::conditional_select(a, b, c)\n}","file":"curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs","line":38,"module":"backend::serial::u64::subtle_assumes","visibility":"pub uninterp spec fn","doc_comment":"Spec-level view of Choice as a boolean\ntrue = Choice(1), false = Choice(0)","math_interpretation":"true = Choice(1), false = Choice(0)","informal_interpretation":"Spec-level view of Choice as a boolean","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs#L38","category":"spec","referenced_specs":[]},{"id":"backend__serial__u64__subtle_assumes__ct_option_has_value","name":"ct_option_has_value","signature":"pub uninterp spec fn ct_option_has_value<T>(opt: CtOption<T>) -> bool; /// Spec-level view of CtOption::unwrap - what value it contains pub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T; /// Wrapper function for CtOption::new #[verifier::external_body] pub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>) ensures ct_option_has_value(result) == choice_is_true(choice), ct_option_value(result) == value,","body":"pub uninterp spec fn ct_option_has_value<T>(opt: CtOption<T>) -> bool;\n\n/// Spec-level view of CtOption::unwrap - what value it contains\npub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T;\n\n/// Wrapper function for CtOption::new\n#[verifier::external_body]\npub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>)\n    ensures\n        ct_option_has_value(result) == choice_is_true(choice),\n        ct_option_value(result) == value,\n{\n    CtOption::new(value, choice)\n}","file":"curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs","line":152,"module":"backend::serial::u64::subtle_assumes","visibility":"pub uninterp spec fn","doc_comment":"Spec-level view of CtOption::is_some","math_interpretation":"","informal_interpretation":"Spec-level view of CtOption::is_some","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs#L152","category":"spec","referenced_specs":["choice_is_true","ct_option_value"]},{"id":"backend__serial__u64__subtle_assumes__ct_option_value","name":"ct_option_value","signature":"pub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T; /// Wrapper function for CtOption::new #[verifier::external_body] pub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>) ensures ct_option_has_value(result) == choice_is_true(choice), ct_option_value(result) == value,","body":"pub uninterp spec fn ct_option_value<T>(opt: CtOption<T>) -> T;\n\n/// Wrapper function for CtOption::new\n#[verifier::external_body]\npub fn ct_option_new<T>(value: T, choice: Choice) -> (result: CtOption<T>)\n    ensures\n        ct_option_has_value(result) == choice_is_true(choice),\n        ct_option_value(result) == value,\n{\n    CtOption::new(value, choice)\n}","file":"curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs","line":155,"module":"backend::serial::u64::subtle_assumes","visibility":"pub uninterp spec fn","doc_comment":"Spec-level view of CtOption::unwrap - what value it contains","math_interpretation":"","informal_interpretation":"Spec-level view of CtOption::unwrap - what value it contains","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/subtle_assumes.rs#L155","category":"spec","referenced_specs":["choice_is_true","ct_option_has_value"]},{"id":"core_assumes__seq_to_array_32","name":"seq_to_array_32","signature":"pub open spec fn seq_to_array_32(s: Seq<u8>) -> [u8; 32]","body":"pub open spec fn seq_to_array_32(s: Seq<u8>) -> [u8; 32] {\n    [\n        s[0],\n        s[1],\n        s[2],\n        s[3],\n        s[4],\n        s[5],\n        s[6],\n        s[7],\n        s[8],\n        s[9],\n        s[10],\n        s[11],\n        s[12],\n        s[13],\n        s[14],\n        s[15],\n        s[16],\n        s[17],\n        s[18],\n        s[19],\n        s[20],\n        s[21],\n        s[22],\n        s[23],\n        s[24],\n        s[25],\n        s[26],\n        s[27],\n        s[28],\n        s[29],\n        s[30],\n        s[31],\n    ]\n}","file":"curve25519-dalek/src/core_assumes.rs","line":263,"module":"core_assumes","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L263","category":"spec","referenced_specs":[]},{"id":"core_assumes__spec_sha512","name":"spec_sha512","signature":"pub uninterp spec fn spec_sha512(input: Seq<u8>) -> Seq<u8>; #[cfg(all(feature = \"digest\", verus_keep_ghost))] /// Axiom: SHA-512 always produces exactly 64 bytes of output. pub proof fn axiom_sha512_output_length(input: Seq<u8>) ensures spec_sha512(input).len() == 64,","body":"pub uninterp spec fn spec_sha512(input: Seq<u8>) -> Seq<u8>;\n\n#[cfg(all(feature = \"digest\", verus_keep_ghost))]\n/// Axiom: SHA-512 always produces exactly 64 bytes of output.\npub proof fn axiom_sha512_output_length(input: Seq<u8>)\n    ensures\n        spec_sha512(input).len() == 64,\n{\n    admit();\n}","file":"curve25519-dalek/src/core_assumes.rs","line":370,"module":"core_assumes","visibility":"pub uninterp spec fn","doc_comment":"Uninterpreted spec function for SHA-512 hash.\nModels the SHA-512 hash as a function from input bytes to 64 output bytes.","math_interpretation":"","informal_interpretation":"Uninterpreted spec function for SHA-512 hash.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L370","category":"spec","referenced_specs":[]},{"id":"core_assumes__spec_state_after_hash","name":"spec_state_after_hash","signature":"pub spec fn spec_state_after_hash<H, T, const N: usize>(initial_state: H, bytes: &[T; N]) -> H; /// Spec function: the hash state after hashing a MontgomeryPoint /// This is defined as the hash state of its canonical byte representation pub open spec fn spec_state_after_hash_montgomery<H>( initial_state: H, point: &MontgomeryPoint, ) -> H","body":"pub spec fn spec_state_after_hash<H, T, const N: usize>(initial_state: H, bytes: &[T; N]) -> H;\n\n/// Spec function: the hash state after hashing a MontgomeryPoint\n/// This is defined as the hash state of its canonical byte representation\npub open spec fn spec_state_after_hash_montgomery<H>(\n    initial_state: H,\n    point: &MontgomeryPoint,\n) -> H {\n    // The hash state of a MontgomeryPoint is determined by its canonical bytes\n    // Canonical bytes are: spec_fe51_to_bytes(spec_fe51_from_bytes(point.0))\n    let canonical_seq = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point.0));\n    let canonical_bytes = seq_to_array_32(canonical_seq);\n    spec_state_after_hash(initial_state, &canonical_bytes)\n}","file":"curve25519-dalek/src/core_assumes.rs","line":226,"module":"core_assumes","visibility":"pub spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L226","category":"spec","referenced_specs":["seq_to_array_32","spec_fe51_from_bytes","spec_fe51_to_bytes","spec_state_after_hash_montgomery"]},{"id":"core_assumes__spec_state_after_hash_montgomery","name":"spec_state_after_hash_montgomery","signature":"pub open spec fn spec_state_after_hash_montgomery<H>( initial_state: H, point: &MontgomeryPoint, ) -> H","body":"pub open spec fn spec_state_after_hash_montgomery<H>(\n    initial_state: H,\n    point: &MontgomeryPoint,\n) -> H {\n    // The hash state of a MontgomeryPoint is determined by its canonical bytes\n    // Canonical bytes are: spec_fe51_to_bytes(spec_fe51_from_bytes(point.0))\n    let canonical_seq = spec_fe51_to_bytes(&spec_fe51_from_bytes(&point.0));\n    let canonical_bytes = seq_to_array_32(canonical_seq);\n    spec_state_after_hash(initial_state, &canonical_bytes)\n}","file":"curve25519-dalek/src/core_assumes.rs","line":230,"module":"core_assumes","visibility":"pub open spec fn","doc_comment":"Spec function: the hash state after hashing a MontgomeryPoint\nThis is defined as the hash state of its canonical byte representation","math_interpretation":"","informal_interpretation":"Spec function: the hash state after hashing a MontgomeryPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L230","category":"spec","referenced_specs":["seq_to_array_32","spec_fe51_from_bytes","spec_fe51_to_bytes","spec_state_after_hash"]},{"id":"edwards__ct_eq_req","name":"ct_eq_req","signature":"spec fn ct_eq_req(&self, other: &Self) -> bool; } #[cfg(verus_keep_ghost)] impl ConstantTimeEqSpecImpl for EdwardsPoint","body":"spec fn ct_eq_req(&self, other: &Self) -> bool;\n}\n\n#[cfg(verus_keep_ghost)]\nimpl ConstantTimeEqSpecImpl for EdwardsPoint {","file":"curve25519-dalek/src/edwards.rs","line":1153,"module":"edwards","visibility":"spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1153","category":"spec","referenced_specs":[]},{"id":"lemmas__common_lemmas__number_theory_lemmas__binomial","name":"binomial","signature":"pub open spec fn binomial(n: nat, k: nat) -> nat decreases n,","body":"pub open spec fn binomial(n: nat, k: nat) -> nat\n    decreases n,\n{\n    if k > n {\n        0\n    } else if k == 0 || k == n {\n        1\n    } else {\n        binomial((n - 1) as nat, (k - 1) as nat) + binomial((n - 1) as nat, k)\n    }\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":300,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"pub open spec fn","doc_comment":"C(n,k) = n! / (k!(n-k)!) using Pascal's identity","math_interpretation":"C(n,k) = n! / (k!(n-k)!) using Pascal's identity","informal_interpretation":"C(n,k) = n! / (k!(n-k)!) using Pascal's identity","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L300","category":"spec","referenced_specs":[]},{"id":"lemmas__common_lemmas__number_theory_lemmas__binomial_sum","name":"binomial_sum","signature":"spec fn binomial_sum(a: nat, n: nat, max_k: nat) -> nat decreases max_k,","body":"spec fn binomial_sum(a: nat, n: nat, max_k: nat) -> nat\n    decreases max_k,\n{\n    if max_k == 0 {\n        binomial(n, 0) * pow(a as int, 0) as nat\n    } else {\n        binomial_sum(a, n, (max_k - 1) as nat) + binomial(n, max_k) * pow(a as int, max_k) as nat\n    }\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":574,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"spec fn","doc_comment":"Σ_{k=0}^{max_k} C(n,k) * a^k","math_interpretation":"Σ_{k=0}^{max_k} C(n,k) * a^k","informal_interpretation":"Σ_{k=0}^{max_k} C(n,k) * a^k","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L574","category":"spec","referenced_specs":["binomial"]},{"id":"lemmas__common_lemmas__number_theory_lemmas__spec_extended_gcd","name":"spec_extended_gcd","signature":"pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult decreases b,","body":"pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult\n    decreases b,\n{\n    if b == 0 {\n        ExtGcdResult { gcd: a, x: 1, y: 0 }\n    } else {\n        let r = spec_extended_gcd(b, a % b);\n        ExtGcdResult { gcd: r.gcd, x: r.y, y: r.x - (a / b) as int * r.y }\n    }\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":960,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"pub open spec fn","doc_comment":"Spec function: Extended Euclidean Algorithm\n\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\n\nThis is a constructive algorithm that produces the Bezout coefficients.\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\n= a*y' + b*(x' - (a/b)*y')\nso (gcd, y', x' - (a/b)*y')","math_interpretation":"gcd(a,b) = ax + by (Bezout coefficients)","informal_interpretation":"Spec function: Extended Euclidean Algorithm\\n\\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\\n\\nThis is a constructive algorithm that produces the Bezout coefficients.\\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\\n= a*y' + b*(x' - (a/b)*y')\\nso (gcd, y', x' - (a/b)*y')","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L960","category":"spec","referenced_specs":[]},{"id":"lemmas__common_lemmas__number_theory_lemmas__spec_gcd","name":"spec_gcd","signature":"pub open spec fn spec_gcd(a: nat, b: nat) -> nat decreases b,","body":"pub open spec fn spec_gcd(a: nat, b: nat) -> nat\n    decreases b,\n{\n    if b == 0 {\n        a\n    } else {\n        spec_gcd(b, a % b)\n    }\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":27,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"pub open spec fn","doc_comment":"Spec function: Greatest Common Divisor using Euclidean algorithm\n\nThis is a constructive definition that computes gcd(a, b) recursively.\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0","math_interpretation":"gcd(a, b) via Euclidean algorithm","informal_interpretation":"Spec function: Greatest Common Divisor using Euclidean algorithm\\n\\nThis is a constructive definition that computes gcd(a, b) recursively.\\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L27","category":"spec","referenced_specs":[]},{"id":"lemmas__common_lemmas__number_theory_lemmas__spec_mod_inverse","name":"spec_mod_inverse","signature":"pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat recommends m > 1, spec_gcd(a % m, m) == 1,","body":"pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat\n    recommends\n        m > 1,\n        spec_gcd(a % m, m) == 1,\n{\n    if m <= 1 || spec_gcd(a % m, m) != 1 {\n        0  // Undefined case - return 0 by convention\n\n    } else {\n        let r = spec_extended_gcd(a % m, m);\n        // r.x might be negative, so normalize to [0, m)\n        (((r.x % (m as int)) + (m as int)) % (m as int)) as nat\n    }\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":1032,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"pub open spec fn","doc_comment":"Spec function: Compute modular inverse using extended Euclidean algorithm\n\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\na * x ≡ 1 (mod m).\n\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\nTaking mod m: (a*x) % m = 1\n\nWe normalize the result to be in [0, m) by computing x % m (handling negative x).","math_interpretation":"a^(-1) mod m, via extended GCD","informal_interpretation":"Spec function: Compute modular inverse using extended Euclidean algorithm\\n\\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\\na * x ≡ 1 (mod m).\\n\\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\\nTaking mod m: (a*x) % m = 1\\n\\nWe normalize the result to be in [0, m) by computing x % m (handling negative x).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L1032","category":"spec","referenced_specs":["spec_extended_gcd","spec_gcd"]},{"id":"lemmas__common_lemmas__sum_lemmas__add","name":"add","signature":"pub open spec fn add(a: nat, b: nat) -> nat","body":"pub open spec fn add(a: nat, b: nat) -> nat {\n    a + b\n}","file":"curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs","line":14,"module":"lemmas::common_lemmas::sum_lemmas","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/sum_lemmas.rs#L14","category":"spec","referenced_specs":[]},{"id":"lemmas__montgomery_curve_lemmas__spec_xadd_projective","name":"spec_xadd_projective","signature":"pub(crate) open spec fn spec_xadd_projective( U_P: nat, W_P: nat, U_Q: nat, W_Q: nat, affine_PmQ: nat, // u(P-Q) in affine coordinates ) -> (nat, nat)","body":"pub(crate) open spec fn spec_xadd_projective(\n    U_P: nat,\n    W_P: nat,\n    U_Q: nat,\n    W_Q: nat,\n    affine_PmQ: nat,  // u(P-Q) in affine coordinates\n) -> (nat, nat) {\n    let t0 = math_field_add(U_P, W_P);  // t0 = U_P + W_P\n    let t1 = math_field_sub(U_P, W_P);  // t1 = U_P - W_P\n    let t2 = math_field_add(U_Q, W_Q);  // t2 = U_Q + W_Q\n    let t3 = math_field_sub(U_Q, W_Q);  // t3 = U_Q - W_Q\n    let t7 = math_field_mul(t0, t3);  // t7 = (U_P + W_P)(U_Q - W_Q)\n    let t8 = math_field_mul(t1, t2);  // t8 = (U_P - W_P)(U_Q + W_Q)\n    let t9 = math_field_add(t7, t8);  // t7 + t8\n    let t10 = math_field_sub(t7, t8);  // t7 - t8\n    let U_PpQ = math_field_square(t9);  // U' = (t7 + t8)²\n    let W_PpQ = math_field_mul(affine_PmQ, math_field_square(t10));  // W' = u(P-Q) · (t7 - t8)²\n    (U_PpQ, W_PpQ)\n}","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":219,"module":"lemmas::montgomery_curve_lemmas","visibility":"pub(crate) open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L219","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_square","math_field_sub"]},{"id":"lemmas__montgomery_curve_lemmas__spec_xdbl_projective","name":"spec_xdbl_projective","signature":"pub(crate) open spec fn spec_xdbl_projective(U: nat, W: nat) -> (nat, nat)","body":"pub(crate) open spec fn spec_xdbl_projective(U: nat, W: nat) -> (nat, nat) {\n    let t0 = math_field_add(U, W);  // t0 = U + W\n    let t1 = math_field_sub(U, W);  // t1 = U - W\n    let t4 = math_field_square(t0);  // t4 = (U + W)²\n    let t5 = math_field_square(t1);  // t5 = (U - W)²\n    let t6 = math_field_sub(t4, t5);  // t6 = (U + W)² - (U - W)² = 4·U·W\n    let a24 = spec_field_element(&APLUS2_OVER_FOUR);  // a24 = (A+2)/4\n    let t13 = math_field_mul(a24, t6);  // t13 = ((A+2)/4) · 4·U·W\n    let t15 = math_field_add(t13, t5);  // t15 = (U - W)² + ((A+2)/4) · 4·U·W\n    let U2 = math_field_mul(t4, t5);  // U' = (U + W)² · (U - W)²\n    let W2 = math_field_mul(t6, t15);  // W' = 4·U·W · ((U - W)² + ((A+2)/4) · 4·U·W)\n    (U2, W2)\n}","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":107,"module":"lemmas::montgomery_curve_lemmas","visibility":"pub(crate) open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L107","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_square","math_field_sub","spec_field_element"]},{"id":"lemmas__scalar_lemmas___montgomery_reduce_part1_chain_lemmas__l0","name":"l0","signature":"pub(crate) open spec fn l0() -> nat","body":"pub(crate) open spec fn l0() -> nat {\n    constants::L.limbs[0] as nat\n}","file":"curve25519-dalek/src/lemmas/scalar_lemmas_/montgomery_reduce_part1_chain_lemmas.rs","line":35,"module":"lemmas::scalar_lemmas_::montgomery_reduce_part1_chain_lemmas","visibility":"pub(crate) open spec fn","doc_comment":"Returns L[0] = constants::L.limbs[0] as nat","math_interpretation":"Returns L[0] = constants::L.limbs[0] as nat","informal_interpretation":"Returns L[0] = constants::L.limbs[0] as nat","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/scalar_lemmas_/montgomery_reduce_part1_chain_lemmas.rs#L35","category":"spec","referenced_specs":[]},{"id":"specs__core_specs__bits_be_to_nat","name":"bits_be_to_nat","signature":"pub open spec fn bits_be_to_nat(bits: &[bool], len: int) -> nat recommends 0 <= len <= bits.len(), decreases len,","body":"pub open spec fn bits_be_to_nat(bits: &[bool], len: int) -> nat\n    recommends\n        0 <= len <= bits.len(),\n    decreases len,\n{\n    if len <= 0 {\n        0\n    } else {\n        let bit_value = if bits[len - 1] {\n            1nat\n        } else {\n            0nat\n        };\n        bit_value + 2 * bits_be_to_nat(bits, len - 1)\n    }\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":285,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Convert a boolean slice (bits in big-endian order) to a natural number.\nbits[0] is the most significant bit.\nUsed for scalar multiplication where bits are processed MSB first.","math_interpretation":"","informal_interpretation":"Convert a boolean slice (bits in big-endian order) to a natural number.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L285","category":"spec","referenced_specs":[]},{"id":"specs__core_specs__bits_to_nat","name":"bits_to_nat","signature":"pub open spec fn bits_to_nat(bits: &[bool; 256]) -> nat","body":"pub open spec fn bits_to_nat(bits: &[bool; 256]) -> nat {\n    bits_to_nat_rec(bits, 0)\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":262,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Convert a boolean array (bits in little-endian order) to a natural number.\nbits[0] is the least significant bit.\nComputes: sum_{i=0}^{255} bits[i] * 2^i","math_interpretation":"Computes: sum_{i=0}^{255} bits[i] * 2^i","informal_interpretation":"Convert a boolean array (bits in little-endian order) to a natural number.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L262","category":"spec","referenced_specs":["bits_to_nat_rec"]},{"id":"specs__core_specs__bits_to_nat_rec","name":"bits_to_nat_rec","signature":"pub open spec fn bits_to_nat_rec(bits: &[bool; 256], index: int) -> nat decreases 256 - index,","body":"pub open spec fn bits_to_nat_rec(bits: &[bool; 256], index: int) -> nat\n    decreases 256 - index,\n{\n    if index >= 256 {\n        0\n    } else {\n        let bit_value = if bits[index] {\n            1nat\n        } else {\n            0nat\n        };\n        bit_value * pow2(index as nat) + bits_to_nat_rec(bits, index + 1)\n    }\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":267,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Recursive helper for bits_to_nat.","math_interpretation":"","informal_interpretation":"Recursive helper for bits_to_nat.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L267","category":"spec","referenced_specs":[]},{"id":"specs__core_specs__bytes32_to_nat","name":"bytes32_to_nat","signature":"pub open spec fn bytes32_to_nat(bytes: &[u8; 32]) -> nat","body":"pub open spec fn bytes32_to_nat(bytes: &[u8; 32]) -> nat {\n    (bytes[ 0] as nat) * pow2( 0 * 8) +\n    (bytes[ 1] as nat) * pow2( 1 * 8) +\n    (bytes[ 2] as nat) * pow2( 2 * 8) +\n    (bytes[ 3] as nat) * pow2( 3 * 8) +\n    (bytes[ 4] as nat) * pow2( 4 * 8) +\n    (bytes[ 5] as nat) * pow2( 5 * 8) +\n    (bytes[ 6] as nat) * pow2( 6 * 8) +\n    (bytes[ 7] as nat) * pow2( 7 * 8) +\n    (bytes[ 8] as nat) * pow2( 8 * 8) +\n    (bytes[ 9] as nat) * pow2( 9 * 8) +\n    (bytes[10] as nat) * pow2(10 * 8) +\n    (bytes[11] as nat) * pow2(11 * 8) +\n    (bytes[12] as nat) * pow2(12 * 8) +\n    (bytes[13] as nat) * pow2(13 * 8) +\n    (bytes[14] as nat) * pow2(14 * 8) +\n    (bytes[15] as nat) * pow2(15 * 8) +\n    (bytes[16] as nat) * pow2(16 * 8) +\n    (bytes[17] as nat) * pow2(17 * 8) +\n    (bytes[18] as nat) * pow2(18 * 8) +\n    (bytes[19] as nat) * pow2(19 * 8) +\n    (bytes[20] as nat) * pow2(20 * 8) +\n    (bytes[21] as nat) * pow2(21 * 8) +\n    (bytes[22] as nat) * pow2(22 * 8) +\n    (bytes[23] as nat) * pow2(23 * 8) +\n    (bytes[24] as nat) * pow2(24 * 8) +\n    (bytes[25] as nat) * pow2(25 * 8) +\n    (bytes[26] as nat) * pow2(26 * 8) +\n    (bytes[27] as nat) * pow2(27 * 8) +\n    (bytes[28] as nat) * pow2(28 * 8) +\n    (bytes[29] as nat) * pow2(29 * 8) +\n    (bytes[30] as nat) * pow2(30 * 8) +\n    (bytes[31] as nat) * pow2(31 * 8)\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":20,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Convert a 32-byte array to its natural number representation (little-endian).\n\nThis function interprets a byte array as a 256-bit little-endian integer:\nbytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ... + bytes[31] * 2^248\n\nIMPORTANT: This explicit 32-term form is kept for SMT solver efficiency.\nFor generic arrays, use `bytes_seq_to_nat(bytes@)` directly.","math_interpretation":"sum_i b[i] * 2^(8i), little-endian 256-bit","informal_interpretation":"Interprets a 32-byte little-endian array as a natural number.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L20","category":"spec","referenced_specs":[]},{"id":"specs__core_specs__bytes_seq_to_nat","name":"bytes_seq_to_nat","signature":"pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat decreases bytes.len(),","body":"pub open spec fn bytes_seq_to_nat(bytes: Seq<u8>) -> nat\n    decreases bytes.len(),\n{\n    if bytes.len() == 0 {\n        0\n    } else {\n        (bytes[0] as nat) + pow2(8) * bytes_seq_to_nat(bytes.skip(1))\n    }\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":118,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Little-endian natural value of an arbitrary-length byte sequence.\nComputes: bytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ...","math_interpretation":"sum_i b[i] * 2^(8i), variable-length","informal_interpretation":"Interprets a sequence of bytes as a natural number in little-endian order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L118","category":"spec","referenced_specs":[]},{"id":"specs__core_specs__spec_load8_at","name":"spec_load8_at","signature":"pub open spec fn spec_load8_at(input: &[u8], i: usize) -> nat","body":"pub open spec fn spec_load8_at(input: &[u8], i: usize) -> nat {\n    (pow2(0 * 8) * input[i + 0] +\n     pow2(1 * 8) * input[i + 1] +\n     pow2(2 * 8) * input[i + 2] +\n     pow2(3 * 8) * input[i + 3] +\n     pow2(4 * 8) * input[i + 4] +\n     pow2(5 * 8) * input[i + 5] +\n     pow2(6 * 8) * input[i + 6] +\n     pow2(7 * 8) * input[i + 7]) as nat\n}","file":"curve25519-dalek/src/specs/core_specs.rs","line":91,"module":"specs::core_specs","visibility":"pub open spec fn","doc_comment":"Load 8 consecutive bytes from a byte array and interpret as a little-endian u64.\n\nReturns: bytes[i] + bytes[i+1] * 2^8 + ... + bytes[i+7] * 2^56\n\nThis is commonly used when unpacking byte arrays into larger word-sized limbs.","math_interpretation":"","informal_interpretation":"Load 8 consecutive bytes from a byte array and interpret as a little-endian u64.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/core_specs.rs#L91","category":"spec","referenced_specs":[]},{"id":"specs__edwards_specs__affine_niels_corresponds_to_edwards","name":"affine_niels_corresponds_to_edwards","signature":"pub open spec fn affine_niels_corresponds_to_edwards( niels: AffineNielsPoint, point: EdwardsPoint, ) -> bool","body":"pub open spec fn affine_niels_corresponds_to_edwards(\n    niels: AffineNielsPoint,\n    point: EdwardsPoint,\n) -> bool {\n    let x_proj = spec_field_element(&point.X);\n    let y_proj = spec_field_element(&point.Y);\n    let z_proj = spec_field_element(&point.Z);\n    let d = spec_field_element(&EDWARDS_D);\n\n    // Compute affine coordinates x = X/Z, y = Y/Z\n    let z_inv = math_field_inv(z_proj);\n    let x = math_field_mul(x_proj, z_inv);\n    let y = math_field_mul(y_proj, z_inv);\n\n    let y_plus_x_niels = spec_field_element(&niels.y_plus_x);\n    let y_minus_x_niels = spec_field_element(&niels.y_minus_x);\n    let xy2d_niels = spec_field_element(&niels.xy2d);\n\n    // Check the relationships\n    &&& y_plus_x_niels == math_field_add(y, x)\n    &&& y_minus_x_niels == math_field_sub(y, x)\n    &&& xy2d_niels == math_field_mul(math_field_mul(math_field_mul(x, y), 2), d)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":581,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if an AffineNielsPoint corresponds to an EdwardsPoint\nAn AffineNielsPoint (y_plus_x, y_minus_x, xy2d) corresponds to EdwardsPoint (X:Y:Z:T) if:\n1. y_plus_x = y + x (mod p) where x = X/Z, y = Y/Z (affine coordinates)\n2. y_minus_x = y - x (mod p)\n3. xy2d = x * y * 2d (mod p)","math_interpretation":"1. y_plus_x = y + x (mod p) where x = X/Z, y = Y/Z (affine coordinates)","informal_interpretation":"Check if an AffineNielsPoint corresponds to an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L581","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__affine_niels_point_as_affine_edwards","name":"affine_niels_point_as_affine_edwards","signature":"pub open spec fn affine_niels_point_as_affine_edwards(niels: AffineNielsPoint) -> (nat, nat)","body":"pub open spec fn affine_niels_point_as_affine_edwards(niels: AffineNielsPoint) -> (nat, nat) {\n    let y_plus_x = spec_field_element(&niels.y_plus_x);\n    let y_minus_x = spec_field_element(&niels.y_minus_x);\n\n    let x = math_field_mul(math_field_sub(y_plus_x, y_minus_x), math_field_inv(2));\n    let y = math_field_mul(math_field_add(y_plus_x, y_minus_x), math_field_inv(2));\n\n    (x, y)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":618,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Extract affine coordinates (x, y) from an AffineNielsPoint\nGiven: y_plus_x = y + x and y_minus_x = y - x\nSolve for: x = (y_plus_x - y_minus_x) / 2, y = (y_plus_x + y_minus_x) / 2","math_interpretation":"Given: y_plus_x = y + x and y_minus_x = y - x","informal_interpretation":"Extract affine coordinates (x, y) from an AffineNielsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L618","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__completed_point_as_affine_edwards","name":"completed_point_as_affine_edwards","signature":"pub open spec fn completed_point_as_affine_edwards( point: crate::backend::serial::curve_models::CompletedPoint, ) -> (nat, nat)","body":"pub open spec fn completed_point_as_affine_edwards(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat) {\n    let (x_abs, y_abs, z_abs, t_abs) = spec_completed_point(point);\n    let z_inv = math_field_inv(z_abs);\n    let t_inv = math_field_inv(t_abs);\n    (math_field_mul(x_abs, z_inv), math_field_mul(y_abs, t_inv))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":414,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the abstract affine coordinates (x, y) from a CompletedPoint.\nA CompletedPoint ((X:Z), (Y:T)) in P¹ × P¹ represents affine point (X/Z, Y/T).","math_interpretation":"","informal_interpretation":"Returns the abstract affine coordinates (x, y) from a CompletedPoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L414","category":"spec","referenced_specs":["math_field_inv","math_field_mul","spec_completed_point"]},{"id":"specs__edwards_specs__compressed_edwards_y_corresponds_to_edwards","name":"compressed_edwards_y_corresponds_to_edwards","signature":"pub open spec fn compressed_edwards_y_corresponds_to_edwards( compressed: CompressedEdwardsY, point: EdwardsPoint, ) -> bool","body":"pub open spec fn compressed_edwards_y_corresponds_to_edwards(\n    compressed: CompressedEdwardsY,\n    point: EdwardsPoint,\n) -> bool {\n    let (x_affine, y_affine) = edwards_point_as_affine(point);\n    // The y-coordinate in the compressed form matches the affine y-coordinate\n    spec_field_element_from_bytes(&compressed.0)\n        == y_affine\n    // The sign bit matches the sign of the affine x-coordinate\n     && (compressed.0[31] >> 7) == (((x_affine % crate::specs::field_specs_u64::p()) % 2) as u8)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":480,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec function: check if a CompressedEdwardsY corresponds to an EdwardsPoint\nThe compressed form should match the affine y-coordinate and x sign bit","math_interpretation":"Compressed(y,sign) matches (X:Y:Z:T) in E(F_p)","informal_interpretation":"Relates a `CompressedEdwardsY` encoding to an `EdwardsPoint` (y-coordinate matches; sign bit matches x).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L480","category":"spec","referenced_specs":["edwards_point_as_affine","p","spec_field_element_from_bytes"]},{"id":"specs__edwards_specs__compressed_y_has_valid_sign_bit","name":"compressed_y_has_valid_sign_bit","signature":"pub open spec fn compressed_y_has_valid_sign_bit(bytes: &[u8; 32]) -> bool","body":"pub open spec fn compressed_y_has_valid_sign_bit(bytes: &[u8; 32]) -> bool {\n    let y = spec_field_element_from_bytes(bytes);\n    let sign_bit = bytes[31] >> 7;\n    // If y² ≡ 1 (mod p), then x = 0, so sign_bit must be 0\n    // Equivalently: sign_bit == 1 implies y² ≢ 1\n    math_field_square(y) == 1 ==> sign_bit == 0\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":503,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if a CompressedEdwardsY has a valid sign bit.\n\n## Mathematical basis\n\nFor points with x = 0 on the Edwards curve, the curve equation gives y² = 1,\nso y = ±1. These special points (the identity (0,1) and the point (0,-1))\nhave only one valid sign bit: 0, since sign_bit = x % 2 = 0.\n\n## Definition\n\nIf the Y coordinate yields x = 0 (i.e., y² ≡ 1 mod p), the sign bit must be 0.","math_interpretation":"y^2 = 1 mod p => sign_bit = 0","informal_interpretation":"Predicate capturing when the sign bit in a compressed Edwards-Y encoding is valid for decoding.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L503","category":"spec","referenced_specs":["math_field_square","p","spec_field_element_from_bytes"]},{"id":"specs__edwards_specs__edwards_add","name":"edwards_add","signature":"pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat)","body":"pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    let d = spec_field_element(&EDWARDS_D);\n    let x1x2 = math_field_mul(x1, x2);\n    let y1y2 = math_field_mul(y1, y2);\n    let x1y2 = math_field_mul(x1, y2);\n    let y1x2 = math_field_mul(y1, x2);\n    let t = math_field_mul(d, math_field_mul(x1x2, y1y2));\n    let denom_x = math_field_add(1, t);\n    let denom_y = math_field_sub(1, t);\n    let x3 = math_field_mul(math_field_add(x1y2, y1x2), math_field_inv(denom_x));\n    let y3 = math_field_mul(math_field_add(y1y2, x1x2), math_field_inv(denom_y));\n    (x3, y3)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":706,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Affine Edwards addition for a = -1 twisted Edwards curves (Ed25519).\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) + (x2,y2).\nFormulas:\nx3 = (x1*y2 + y1*x2) / (1 + d*x1*x2*y1*y2)\ny3 = (y1*y2 + x1*x2) / (1 - d*x1*x2*y1*y2)\n\nThese are the unified addition formulas for twisted Edwards curves with a = -1.\nReference: [BBJLP2008] Section 3.1, [RFC8032] Section 5.1.4","math_interpretation":"(x1,y1) + (x2,y2) on -x^2+y^2=1+dx^2y^2","informal_interpretation":"Adds two affine Edwards points (group law).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L706","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__edwards_double","name":"edwards_double","signature":"pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat)","body":"pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat) {\n    edwards_add(x, y, x, y)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":721,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Affine Edwards doubling defined as addition with itself.","math_interpretation":"2P = P + P on twisted Edwards","informal_interpretation":"Affine Edwards doubling defined as addition with itself.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L721","category":"spec","referenced_specs":["edwards_add"]},{"id":"specs__edwards_specs__edwards_neg","name":"edwards_neg","signature":"pub open spec fn edwards_neg(point: (nat, nat)) -> (nat, nat)","body":"pub open spec fn edwards_neg(point: (nat, nat)) -> (nat, nat) {\n    (math_field_neg(point.0), point.1)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":749,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Affine Edwards negation for twisted Edwards curves with a=-1.\nThe negation of point (x, y) is (-x, y).","math_interpretation":"(x,y) -> (-x,y) on twisted Edwards","informal_interpretation":"Negates an affine Edwards point (group inverse).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L749","category":"spec","referenced_specs":["math_field_neg"]},{"id":"specs__edwards_specs__edwards_point_as_affine","name":"edwards_point_as_affine","signature":"pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat)","body":"pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let (x, y, z, _t) = spec_edwards_point(point);\n    let z_inv = math_field_inv(z);\n    (math_field_mul(x, z_inv), math_field_mul(y, z_inv))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":394,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the abstract affine coordinates (x, y) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) represents affine point (X/Z, Y/Z).","math_interpretation":"(X:Y:Z:T) -> (X/Z, Y/Z) in F_p x F_p","informal_interpretation":"Converts an extended/projective Edwards point representation to affine coordinates.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L394","category":"spec","referenced_specs":["math_field_inv","math_field_mul","spec_edwards_point"]},{"id":"specs__edwards_specs__edwards_point_limbs_bounded","name":"edwards_point_limbs_bounded","signature":"pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool","body":"pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool {\n    fe51_limbs_bounded(&point.X, 52) && fe51_limbs_bounded(&point.Y, 52) && fe51_limbs_bounded(\n        &point.Z,\n        52,\n    ) && fe51_limbs_bounded(&point.T, 52)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":366,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"EdwardsPoint invariant: all coordinate limbs must be 52-bounded.","math_interpretation":"all limbs of (X,Y,Z,T) < 2^52","informal_interpretation":"EdwardsPoint invariant: all coordinate limbs must be 52-bounded.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L366","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__edwards_specs__edwards_scalar_mul","name":"edwards_scalar_mul","signature":"pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat) decreases n,","body":"pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat)\n    decreases n,\n{\n    if n == 0 {\n        math_edwards_identity()  // (0, 1)\n\n    } else if n == 1 {\n        point_affine\n    } else if n % 2 == 0 {\n        let half = edwards_scalar_mul(point_affine, (n / 2) as nat);\n        edwards_double(half.0, half.1)\n    } else {\n        let prev = edwards_scalar_mul(point_affine, (n - 1) as nat);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":831,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Scalar multiplication on Edwards curve points (affine coordinates).\n\nUses double-and-add instead of linear recursion to closer match the implementation of mul_by_pow_2\n\n- **Linear**: `n*P = (n-1)*P + P` — reveal gives `add(scalar_mul(P, n-1), P)`\n- **Double-and-add**: even n → `double(scalar_mul(P, n/2))`","math_interpretation":"[n]P via double-and-add on E(F_p)","informal_interpretation":"Computes scalar multiplication of an affine Edwards point by a natural number.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L831","category":"spec","referenced_specs":["edwards_add","edwards_double","math_edwards_identity"]},{"id":"specs__edwards_specs__edwards_scalar_mul_signed","name":"edwards_scalar_mul_signed","signature":"pub open spec fn edwards_scalar_mul_signed(point_affine: (nat, nat), n: int) -> (nat, nat)","body":"pub open spec fn edwards_scalar_mul_signed(point_affine: (nat, nat), n: int) -> (nat, nat) {\n    if n >= 0 {\n        edwards_scalar_mul(point_affine, n as nat)\n    } else {\n        let (x, y) = edwards_scalar_mul(point_affine, (-n) as nat);\n        (math_field_neg(x), y)\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":856,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Scalar multiplication that handles negative scalars (for lookup tables)\nUnlike edwards_scalar_mul which only takes nat (≥ 0), this takes int which can be negative\n\nFor n ≥ 0: returns n * P using edwards_scalar_mul\nFor n < 0: returns n * P = -(|n| * P) by computing |n| * P and negating\nEdwards negation: (x,y) -> (-x,y)\n\nUsed by LookupTable::select(x) where x: i8 can be negative (e.g., -8 ≤ x ≤ 8)","math_interpretation":"","informal_interpretation":"Scalar multiplication that handles negative scalars (for lookup tables)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L856","category":"spec","referenced_specs":["edwards_scalar_mul","math_field_neg"]},{"id":"specs__edwards_specs__edwards_sub","name":"edwards_sub","signature":"pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat)","body":"pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    edwards_add(x1, y1, math_field_neg(x2), y2)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":757,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Affine Edwards subtraction for twisted Edwards curves.\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) - (x2,y2).\nSubtraction is defined as addition with the negation of the second point.\nFor twisted Edwards curves, the negation of (x, y) is (-x, y).","math_interpretation":"(x1,y1) - (x2,y2) = (x1,y1) + (-x2,y2)","informal_interpretation":"Subtracts two affine Edwards points.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L757","category":"spec","referenced_specs":["edwards_add","math_field_neg"]},{"id":"specs__edwards_specs__identity_projective_niels","name":"identity_projective_niels","signature":"pub open spec fn identity_projective_niels() -> ProjectiveNielsPoint","body":"pub open spec fn identity_projective_niels() -> ProjectiveNielsPoint {\n    ProjectiveNielsPoint {\n        Y_plus_X: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Y_minus_X: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Z: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        T2d: crate::field::FieldElement { limbs: [0, 0, 0, 0, 0] },  // 0\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":652,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Identity element for ProjectiveNielsPoint as structure","math_interpretation":"","informal_interpretation":"Identity element for ProjectiveNielsPoint as structure","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L652","category":"spec","referenced_specs":[]},{"id":"specs__edwards_specs__identity_projective_point_edwards","name":"identity_projective_point_edwards","signature":"pub open spec fn identity_projective_point_edwards() -> ProjectivePoint","body":"pub open spec fn identity_projective_point_edwards() -> ProjectivePoint {\n    ProjectivePoint {\n        X: crate::field::FieldElement { limbs: [0, 0, 0, 0, 0] },  // 0\n        Y: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n        Z: crate::field::FieldElement { limbs: [1, 0, 0, 0, 0] },  // 1\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":439,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Identity element for ProjectivePoint as structure","math_interpretation":"","informal_interpretation":"Identity element for ProjectivePoint as structure","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L439","category":"spec","referenced_specs":[]},{"id":"specs__edwards_specs__is_identity_edwards_point","name":"is_identity_edwards_point","signature":"pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool","body":"pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n\n    z != 0 && x == 0 && y == z\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":324,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if an EdwardsPoint represents the identity point\nThe identity point is (0, 1) in affine coordinates\nIn projective coordinates (X:Y:Z:T), this means X/Z = 0 and Y/Z = 1\nWhich is equivalent to X ≡ 0 (mod p) and Y ≡ Z (mod p) with Z ≠ 0","math_interpretation":"X = 0, Y = Z, Z != 0 (projective identity)","informal_interpretation":"Checks whether an Edwards point is the identity (neutral element).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L324","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__edwards_specs__is_valid_completed_point","name":"is_valid_completed_point","signature":"pub open spec fn is_valid_completed_point( point: crate::backend::serial::curve_models::CompletedPoint, ) -> bool","body":"pub open spec fn is_valid_completed_point(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> bool {\n    let (x_abs, y_abs, z_abs, t_abs) = spec_completed_point(point);\n\n    // Z and T must be non-zero\n    z_abs != 0 && t_abs != 0\n        &&\n    // The affine coordinates (X/Z, Y/T) must be on the curve\n    math_on_edwards_curve(\n        math_field_mul(x_abs, math_field_inv(z_abs)),\n        math_field_mul(y_abs, math_field_inv(t_abs)),\n    )\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":765,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if a CompletedPoint is valid\nA CompletedPoint ((X:Z), (Y:T)) in P¹ × P¹ is valid if:\n1. The affine point (X/Z, Y/T) lies on the Edwards curve\n2. Z ≠ 0 and T ≠ 0","math_interpretation":"","informal_interpretation":"Check if a CompletedPoint is valid","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L765","category":"spec","referenced_specs":["math_field_inv","math_field_mul","math_on_edwards_curve","spec_completed_point"]},{"id":"specs__edwards_specs__is_valid_edwards_basepoint_table","name":"is_valid_edwards_basepoint_table","signature":"pub open spec fn is_valid_edwards_basepoint_table( table: EdwardsBasepointTable, basepoint: (nat, nat), ) -> bool","body":"pub open spec fn is_valid_edwards_basepoint_table(\n    table: EdwardsBasepointTable,\n    basepoint: (nat, nat),\n) -> bool {\n    // Each of the 32 LookupTables contains correct multiples of (16²)^i * B\n    // and has bounded limbs\n    forall|i: int|\n        #![trigger table.0[i]]\n        0 <= i < 32 ==> {\n            &&& crate::specs::window_specs::is_valid_lookup_table_affine_coords(\n                table.0[i].0,\n                edwards_scalar_mul(basepoint, pow256(i as nat)),\n                8,\n            )\n            &&& crate::specs::window_specs::lookup_table_affine_limbs_bounded(table.0[i].0)\n        }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":123,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec: A valid EdwardsBasepointTable for a basepoint B contains 32 LookupTables where:\n- table.0[i] contains [1·(16²)^i·B, 2·(16²)^i·B, ..., 8·(16²)^i·B]\n- All entries have bounded limbs (< 2^54)\n\nThis enables computing [scalar] * B via radix-16 representation of scalar.","math_interpretation":"","informal_interpretation":"Spec: A valid EdwardsBasepointTable for a basepoint B contains 32 LookupTables where:","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L123","category":"spec","referenced_specs":["edwards_scalar_mul","is_valid_lookup_table_affine_coords","lookup_table_affine_limbs_bounded","pow256"]},{"id":"specs__edwards_specs__is_valid_edwards_point","name":"is_valid_edwards_point","signature":"pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool","body":"pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n\n    math_is_valid_extended_edwards_point(x, y, z, t)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":356,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if an EdwardsPoint in extended coordinates is valid\nAn EdwardsPoint (X:Y:Z:T) is valid if:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T\n\nExtended coordinates (X:Y:Z:T) with X·Y = Z·T enable faster point arithmetic.\nReference: [HWCD2008] Section 3 for extended twisted Edwards coordinates","math_interpretation":"(X:Y:Z:T) satisfies curve eq + XY = ZT","informal_interpretation":"Checks that an Edwards point satisfies the curve equation (mathematically valid).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L356","category":"spec","referenced_specs":["math_is_valid_extended_edwards_point","spec_field_element"]},{"id":"specs__edwards_specs__is_valid_projective_point","name":"is_valid_projective_point","signature":"pub open spec fn is_valid_projective_point(point: ProjectivePoint) -> bool","body":"pub open spec fn is_valid_projective_point(point: ProjectivePoint) -> bool {\n    let (x, y, z) = spec_projective_point_edwards(point);\n\n    // Z must be non-zero and projective curve equation must hold\n    z != 0 && math_on_edwards_curve_projective(x, y, z)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":786,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if a ProjectivePoint is valid\nA ProjectivePoint (X:Y:Z) in P² is valid if:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n\nThis is equivalent to the affine point (X/Z, Y/Z) lying on the Edwards curve.","math_interpretation":"2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²","informal_interpretation":"Check if a ProjectivePoint is valid","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L786","category":"spec","referenced_specs":["math_on_edwards_curve_projective","spec_projective_point_edwards"]},{"id":"specs__edwards_specs__is_well_formed_edwards_point","name":"is_well_formed_edwards_point","signature":"pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool","body":"pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    is_valid_edwards_point(point) && edwards_point_limbs_bounded(point) && sum_of_limbs_bounded(\n        &point.Y,\n        &point.X,\n        u64::MAX,\n    )\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":374,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"A well-formed EdwardsPoint: mathematically valid and properly bounded.","math_interpretation":"valid on curve + limbs bounded","informal_interpretation":"Stronger validity predicate: point is valid and its internal representation satisfies required bounds.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L374","category":"spec","referenced_specs":["edwards_point_limbs_bounded","is_valid_edwards_point","sum_of_limbs_bounded"]},{"id":"specs__edwards_specs__math_edwards_identity","name":"math_edwards_identity","signature":"pub open spec fn math_edwards_identity() -> (nat, nat)","body":"pub open spec fn math_edwards_identity() -> (nat, nat) {\n    (0, 1)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":311,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"The identity point in affine coordinates (0, 1)","math_interpretation":"O = (0, 1) in affine coordinates","informal_interpretation":"The affine identity point of the Edwards group.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L311","category":"spec","referenced_specs":[]},{"id":"specs__edwards_specs__math_is_valid_extended_edwards_point","name":"math_is_valid_extended_edwards_point","signature":"pub open spec fn math_is_valid_extended_edwards_point(x: nat, y: nat, z: nat, t: nat) -> bool","body":"pub open spec fn math_is_valid_extended_edwards_point(x: nat, y: nat, z: nat, t: nat) -> bool {\n    z != 0 && math_on_edwards_curve_projective(x, y, z) && math_field_mul(x, y) == math_field_mul(\n        z,\n        t,\n    )\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":341,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\n\nThis is the \"unpacked\" version of `is_valid_edwards_point` that operates directly on the\nmathematical values `(x, y, z, t)` (all reduced mod p via `math_field_*`).\n\nAn (X:Y:Z:T) tuple is valid iff:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T","math_interpretation":"Z != 0, curve eq holds, XY = ZT","informal_interpretation":"Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\\n\\nThis is the \"unpacked\" version of `is_valid_edwards_point` that operates directly on the\\nmathematical values `(x, y, z, t)` (all reduced mod p via `math_field_*`).\\n\\nAn (X:Y:Z:T) tuple is valid iff:\\n1. Z ≠ 0\\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\\n3. The Segre relation holds: X·Y = Z·T","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L341","category":"spec","referenced_specs":["math_field_mul","math_on_edwards_curve_projective"]},{"id":"specs__edwards_specs__math_is_valid_y_coordinate","name":"math_is_valid_y_coordinate","signature":"pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool","body":"pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool {\n    let d = spec_field_element(&EDWARDS_D);\n    let y2 = math_field_square(y);\n\n    // Compute u = y² - 1\n    let u = math_field_sub(y2, 1);\n\n    // Compute v = d·y² + 1\n    let v = math_field_add(math_field_mul(d, y2), 1);\n\n    if u % p() == 0 {\n        // If u = 0, then y² = 1, so y = ±1, which gives valid points (x=0, y=±1)\n        true\n    } else if v % p() == 0 {\n        // If v = 0 but u ≠ 0, division by zero case - invalid\n        false\n    } else {\n        // Check if there exists r such that r² * v ≡ ±u (mod p)\n        // This is what sqrt_ratio_i determines\n        exists|r: nat|\n            r < p() && (#[trigger] math_field_mul(math_field_square(r), v) == u % p()\n                || #[trigger] math_field_mul(math_field_square(r), v) == math_field_neg(u))\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":285,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec function: Check if a y-coordinate corresponds to a valid point on the curve.\nMirrors the sqrt_ratio_i computation from field.rs to determine if u/v is a square.\nFrom the curve equation: x² = (y² - 1) / (d·y² + 1)\nThis computes the same check as sqrt_ratio_i(&u, &v) where:\nu = y² - 1\nv = d·y² + 1\nReturns true if u/v is a square (i.e., x can be recovered)","math_interpretation":"exists x. (x, y) in E(F_p)","informal_interpretation":"Checks whether a field element can be a y-coordinate of some Edwards curve point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L285","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_neg","math_field_square","math_field_sub","p","spec_field_element"]},{"id":"specs__edwards_specs__math_on_edwards_curve","name":"math_on_edwards_curve","signature":"pub open spec fn math_on_edwards_curve(x: nat, y: nat) -> bool","body":"pub open spec fn math_on_edwards_curve(x: nat, y: nat) -> bool {\n    let p = p();\n    let d = spec_field_element(&EDWARDS_D);\n    let x2 = math_field_square(x);\n    let y2 = math_field_square(y);\n    let x2y2 = math_field_mul(x2, y2);\n\n    // -x² + y² = 1 + d·x²·y²\n    let lhs = math_field_sub(y2, x2);  // y² - x²\n    let rhs = math_field_add(1, math_field_mul(d, x2y2));  // 1 + d·x²·y²\n\n    lhs == rhs\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":240,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if a point (x, y) satisfies the Edwards curve equation\n-x² + y² = 1 + d·x²·y²  (mod p)\n\nThis is the twisted Edwards curve equation with a = -1.\nReference: [BBJLP2008] Section 3, [RFC8032] Section 5.1","math_interpretation":"-x² + y² = 1 + d·x²·y²  (mod p)","informal_interpretation":"Check if a point (x, y) satisfies the Edwards curve equation","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L240","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_square","math_field_sub","p","spec_field_element"]},{"id":"specs__edwards_specs__math_on_edwards_curve_projective","name":"math_on_edwards_curve_projective","signature":"pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool","body":"pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool {\n    let d = spec_field_element(&EDWARDS_D);\n\n    // Compute X², Y², Z²\n    let x2 = math_field_square(x);\n    let y2 = math_field_square(y);\n    let z2 = math_field_square(z);\n    let z4 = math_field_square(z2);\n\n    // LHS: (-X² + Y²)·Z² = (Y² - X²)·Z²\n    let lhs = math_field_mul(math_field_sub(y2, x2), z2);\n\n    // RHS: Z⁴ + d·X²·Y²\n    let rhs = math_field_add(z4, math_field_mul(d, math_field_mul(x2, y2)));\n\n    lhs == rhs\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":260,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Homogenized Edwards curve equation for projective coordinates\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\nThis is equivalent to the affine equation when Z ≠ 0\n\nReference: [BBJLP2008] Section 3","math_interpretation":"(Y^2 - X^2)Z^2 = Z^4 + dX^2Y^2","informal_interpretation":"Homogenized Edwards curve equation for projective coordinates\\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\\nThis is equivalent to the affine equation when Z ≠ 0\\n\\nReference: [BBJLP2008] Section 3","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L260","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_square","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__negate_projective_niels","name":"negate_projective_niels","signature":"pub open spec fn negate_projective_niels(p: ProjectiveNielsPoint) -> ProjectiveNielsPoint","body":"pub open spec fn negate_projective_niels(p: ProjectiveNielsPoint) -> ProjectiveNielsPoint {\n    ProjectiveNielsPoint {\n        Y_plus_X: p.Y_minus_X,\n        Y_minus_X: p.Y_plus_X,\n        Z: p.Z,\n        T2d: crate::field::FieldElement {\n            limbs: crate::specs::field_specs_u64::spec_negate(p.T2d.limbs),\n        },\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":687,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Negation of a ProjectiveNielsPoint as structure","math_interpretation":"","informal_interpretation":"Negation of a ProjectiveNielsPoint as structure","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L687","category":"spec","referenced_specs":["p","spec_negate"]},{"id":"specs__edwards_specs__pow256","name":"pow256","signature":"pub open spec fn pow256(n: nat) -> nat","body":"pub open spec fn pow256(n: nat) -> nat {\n    pow2(8 * n)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":113,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Compute 256^n (i.e., (16²)^n) for basepoint table indexing\nUses pow2(8*n) since 256 = 2^8","math_interpretation":"Uses pow2(8*n) since 256 = 2^8","informal_interpretation":"Compute 256^n (i.e., (16²)^n) for basepoint table indexing","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L113","category":"spec","referenced_specs":[]},{"id":"specs__edwards_specs__projective_niels_corresponds_to_edwards","name":"projective_niels_corresponds_to_edwards","signature":"pub open spec fn projective_niels_corresponds_to_edwards( niels: ProjectiveNielsPoint, point: EdwardsPoint, ) -> bool","body":"pub open spec fn projective_niels_corresponds_to_edwards(\n    niels: ProjectiveNielsPoint,\n    point: EdwardsPoint,\n) -> bool {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n    let d = spec_field_element(&EDWARDS_D);\n\n    let y_plus_x = spec_field_element(&niels.Y_plus_X);\n    let y_minus_x = spec_field_element(&niels.Y_minus_X);\n    let niels_z = spec_field_element(&niels.Z);\n    let t2d = spec_field_element(&niels.T2d);\n\n    // Check the relationships\n    // 2d is computed as math_field_mul(2, d) in field arithmetic\n    &&& y_plus_x == math_field_add(y, x)\n    &&& y_minus_x == math_field_sub(y, x)\n    &&& niels_z == z\n    &&& t2d == math_field_mul(math_field_mul(2, d), t)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":517,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Check if a ProjectiveNielsPoint corresponds to an EdwardsPoint\nA ProjectiveNielsPoint (Y_plus_X, Y_minus_X, Z, T2d) corresponds to EdwardsPoint (X:Y:Z:T) if:\n1. Y_plus_X = Y + X (mod p)\n2. Y_minus_X = Y - X (mod p)\n3. Z matches\n4. T2d = 2d * T (mod p) where T = XY/Z","math_interpretation":"1. Y_plus_X = Y + X (mod p)","informal_interpretation":"Check if a ProjectiveNielsPoint corresponds to an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L517","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__projective_niels_point_as_affine_edwards","name":"projective_niels_point_as_affine_edwards","signature":"pub open spec fn projective_niels_point_as_affine_edwards(niels: ProjectiveNielsPoint) -> ( nat, nat, )","body":"pub open spec fn projective_niels_point_as_affine_edwards(niels: ProjectiveNielsPoint) -> (\n    nat,\n    nat,\n) {\n    let y_plus_x = spec_field_element(&niels.Y_plus_X);\n    let y_minus_x = spec_field_element(&niels.Y_minus_X);\n    let z = spec_field_element(&niels.Z);\n\n    // Recover projective X and Y from Y+X and Y-X\n    let x_proj = math_field_mul(math_field_sub(y_plus_x, y_minus_x), math_field_inv(2));\n    let y_proj = math_field_mul(math_field_add(y_plus_x, y_minus_x), math_field_inv(2));\n\n    // Convert to affine by dividing by Z\n    let z_inv = math_field_inv(z);\n    let x = math_field_mul(x_proj, z_inv);\n    let y = math_field_mul(y_proj, z_inv);\n\n    (x, y)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":556,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Extract affine coordinates (x, y) from a ProjectiveNielsPoint\nGiven: Y_plus_X = Y + X, Y_minus_X = Y - X, and Z (all in projective coords)\nFirst recover projective X and Y, then convert to affine: x = X/Z, y = Y/Z","math_interpretation":"","informal_interpretation":"Extract affine coordinates (x, y) from a ProjectiveNielsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L556","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub","spec_field_element"]},{"id":"specs__edwards_specs__projective_point_as_affine_edwards","name":"projective_point_as_affine_edwards","signature":"pub open spec fn projective_point_as_affine_edwards(point: ProjectivePoint) -> (nat, nat)","body":"pub open spec fn projective_point_as_affine_edwards(point: ProjectivePoint) -> (nat, nat) {\n    let (x, y, z) = spec_projective_point_edwards(point);\n    let z_inv = math_field_inv(z);\n    (math_field_mul(x, z_inv), math_field_mul(y, z_inv))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":449,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the abstract affine coordinates (x, y) from an Edwards ProjectivePoint.\nAn Edwards ProjectivePoint (X:Y:Z) represents affine point (X/Z, Y/Z).","math_interpretation":"","informal_interpretation":"Returns the abstract affine coordinates (x, y) from an Edwards ProjectivePoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L449","category":"spec","referenced_specs":["math_field_inv","math_field_mul","spec_projective_point_edwards"]},{"id":"specs__edwards_specs__spec_completed_point","name":"spec_completed_point","signature":"pub open spec fn spec_completed_point( point: crate::backend::serial::curve_models::CompletedPoint, ) -> (nat, nat, nat, nat)","body":"pub open spec fn spec_completed_point(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat, nat) {\n    let x_abs = spec_field_element(&point.X);\n    let y_abs = spec_field_element(&point.Y);\n    let z_abs = spec_field_element(&point.Z);\n    let t_abs = spec_field_element(&point.T);\n    (x_abs, y_abs, z_abs, t_abs)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":402,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the field element values (X, Y, Z, T) from a CompletedPoint.\nA CompletedPoint is ((X:Z), (Y:T)) in P¹ × P¹.","math_interpretation":"","informal_interpretation":"Returns the field element values (X, Y, Z, T) from a CompletedPoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L402","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__edwards_specs__spec_completed_to_extended","name":"spec_completed_to_extended","signature":"pub open spec fn spec_completed_to_extended( point: crate::backend::serial::curve_models::CompletedPoint, ) -> (nat, nat, nat, nat)","body":"pub open spec fn spec_completed_to_extended(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat, nat) {\n    let (x, y, z, t) = spec_completed_point(point);\n    (math_field_mul(x, t), math_field_mul(y, z), math_field_mul(z, t), math_field_mul(x, y))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":809,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec for CompletedPoint::as_extended conversion\nConverts from P¹ × P¹ to P³ via the Segre embedding:\n((X:Z), (Y:T)) ↦ (X·T : Y·Z : Z·T : X·Y)\nThis preserves the affine point and satisfies the extended coordinate invariant","math_interpretation":"","informal_interpretation":"Spec for CompletedPoint::as_extended conversion","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L809","category":"spec","referenced_specs":["math_field_mul","spec_completed_point"]},{"id":"specs__edwards_specs__spec_completed_to_projective","name":"spec_completed_to_projective","signature":"pub open spec fn spec_completed_to_projective( point: crate::backend::serial::curve_models::CompletedPoint, ) -> (nat, nat, nat)","body":"pub open spec fn spec_completed_to_projective(\n    point: crate::backend::serial::curve_models::CompletedPoint,\n) -> (nat, nat, nat) {\n    let (x, y, z, t) = spec_completed_point(point);\n    (math_field_mul(x, t), math_field_mul(y, z), math_field_mul(z, t))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":798,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec for CompletedPoint::as_projective conversion\nConverts from P¹ × P¹ to P² via the mapping:\n(X:Z, Y:T) ↦ (X·T : Y·Z : Z·T)\nThis preserves the affine point because:\nX·T / Z·T = X/Z and Y·Z / Z·T = Y/T","math_interpretation":"X·T / Z·T = X/Z and Y·Z / Z·T = Y/T","informal_interpretation":"Spec for CompletedPoint::as_projective conversion","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L798","category":"spec","referenced_specs":["math_field_mul","spec_completed_point"]},{"id":"specs__edwards_specs__spec_ed25519_basepoint","name":"spec_ed25519_basepoint","signature":"pub open spec fn spec_ed25519_basepoint() -> (nat, nat)","body":"pub open spec fn spec_ed25519_basepoint() -> (nat, nat) {\n    (u64_5_as_nat(ED25519_BASEPOINT_POINT.X.limbs), u64_5_as_nat(ED25519_BASEPOINT_POINT.Y.limbs))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":75,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"The Ed25519 basepoint B in affine coordinates (x, y).\nThis is the generator point of the prime-order subgroup.\n\nReferences the actual constant ED25519_BASEPOINT_POINT from constants.rs.\nThe y-coordinate is 4/5 mod p (the first 255 bits of the compressed form).\nThe x-coordinate is the positive square root satisfying the curve equation.\n\nReference: [RFC8032] Section 5.1","math_interpretation":"B = (x_B, y_B), Ed25519 generator","informal_interpretation":"Returns the Ed25519 basepoint in affine coordinates (spec-level).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L75","category":"spec","referenced_specs":["u64_5_as_nat"]},{"id":"specs__edwards_specs__spec_edwards_add_affine_niels","name":"spec_edwards_add_affine_niels","signature":"pub open spec fn spec_edwards_add_affine_niels( p: crate::edwards::EdwardsPoint, q: crate::backend::serial::curve_models::AffineNielsPoint, ) -> (nat, nat)","body":"pub open spec fn spec_edwards_add_affine_niels(\n    p: crate::edwards::EdwardsPoint,\n    q: crate::backend::serial::curve_models::AffineNielsPoint,\n) -> (nat, nat) {\n    let self_affine = edwards_point_as_affine(p);\n    let other_affine = affine_niels_point_as_affine_edwards(q);\n    edwards_add(self_affine.0, self_affine.1, other_affine.0, other_affine.1)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":738,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Helper spec function: Edwards addition of EdwardsPoint and AffineNielsPoint\nCombines the affine conversion and addition into a single convenient spec function.","math_interpretation":"","informal_interpretation":"Helper spec function: Edwards addition of EdwardsPoint and AffineNielsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L738","category":"spec","referenced_specs":["affine_niels_point_as_affine_edwards","edwards_add","edwards_point_as_affine","p"]},{"id":"specs__edwards_specs__spec_edwards_add_projective_niels","name":"spec_edwards_add_projective_niels","signature":"pub open spec fn spec_edwards_add_projective_niels(p: EdwardsPoint, q: ProjectiveNielsPoint) -> ( nat, nat, )","body":"pub open spec fn spec_edwards_add_projective_niels(p: EdwardsPoint, q: ProjectiveNielsPoint) -> (\n    nat,\n    nat,\n) {\n    let self_affine = edwards_point_as_affine(p);\n    let other_affine = projective_niels_point_as_affine_edwards(q);\n    edwards_add(self_affine.0, self_affine.1, other_affine.0, other_affine.1)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":727,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Helper spec function: Edwards addition of EdwardsPoint and ProjectiveNielsPoint\nCombines the affine conversion and addition into a single convenient spec function.","math_interpretation":"","informal_interpretation":"Helper spec function: Edwards addition of EdwardsPoint and ProjectiveNielsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L727","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine","p","projective_niels_point_as_affine_edwards"]},{"id":"specs__edwards_specs__spec_edwards_decompress_from_y_and_sign","name":"spec_edwards_decompress_from_y_and_sign","signature":"pub open spec fn spec_edwards_decompress_from_y_and_sign(y: nat, sign_bit: u8) -> Option< (nat, nat), >","body":"pub open spec fn spec_edwards_decompress_from_y_and_sign(y: nat, sign_bit: u8) -> Option<\n    (nat, nat),\n> {\n    if !math_is_valid_y_coordinate(y) {\n        None\n    } else if math_field_square(y) == 1 && sign_bit == 1u8 {\n        // When y² = 1, we have x = 0, and sign_bit must be 0\n        None\n    } else {\n        // VERIFICATION NOTE: \"choose\" could be replaced with concrete value using sqrt_ratio_i upon need.\n        // Choose x such that (x, y) is on the curve with the correct sign\n        let x = choose|x: nat|\n            math_on_edwards_curve(x, y) && x < p() && (x % 2) == (sign_bit as nat);\n        Some((x, y))\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":1041,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec for Edwards decompression: given y and a sign bit, compute (x, y) on the curve.\n\nMathematical definition:\n- Returns None if y is not a valid y-coordinate (no x exists on curve)\n- Returns None if x = 0 but sign_bit = 1 (invalid sign for zero)\n- Otherwise returns the unique (x, y) on the curve with x % 2 == sign_bit","math_interpretation":"","informal_interpretation":"Spec for Edwards decompression: given y and a sign bit, compute (x, y) on the curve.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L1041","category":"spec","referenced_specs":["math_field_square","math_is_valid_y_coordinate","math_on_edwards_curve","p"]},{"id":"specs__edwards_specs__spec_edwards_point","name":"spec_edwards_point","signature":"pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat)","body":"pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat) {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    let t = spec_field_element(&point.T);\n    (x, y, z, t)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":384,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.","math_interpretation":"(X, Y, Z, T) field values of extended point","informal_interpretation":"Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L384","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__edwards_specs__spec_montgomery_to_edwards_affine_with_sign","name":"spec_montgomery_to_edwards_affine_with_sign","signature":"pub open spec fn spec_montgomery_to_edwards_affine_with_sign(u: nat, sign_bit: u8) -> (nat, nat)","body":"pub open spec fn spec_montgomery_to_edwards_affine_with_sign(u: nat, sign_bit: u8) -> (nat, nat) {\n    if u == math_field_sub(0, 1) {\n        // u = -1: birational map has zero denominator\n        math_edwards_identity()\n    } else {\n        let y = edwards_y_from_montgomery_u(u);\n        match spec_edwards_decompress_from_y_and_sign(y, sign_bit) {\n            Some(P) => P,\n            None => math_edwards_identity(),\n        }\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":1022,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec for Montgomery-to-Edwards conversion with sign bit selection.\n\nConverts Montgomery u-coordinate to Edwards affine (x, y) via:\n1. Birational map: y = (u-1)/(u+1)\n2. Decompression: recover x from y with given sign_bit\n\nReturns identity (0, 1) on failure (u = -1 or invalid y).","math_interpretation":"1. Birational map: y = (u-1)/(u+1)","informal_interpretation":"Spec for Montgomery-to-Edwards conversion with sign bit selection.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L1022","category":"spec","referenced_specs":["edwards_y_from_montgomery_u","math_edwards_identity","math_field_sub","spec_edwards_decompress_from_y_and_sign"]},{"id":"specs__edwards_specs__spec_nonspec_map_to_curve","name":"spec_nonspec_map_to_curve","signature":"pub open spec fn spec_nonspec_map_to_curve(hash_bytes: Seq<u8>) -> (nat, nat) recommends hash_bytes.len() == 32,","body":"pub open spec fn spec_nonspec_map_to_curve(hash_bytes: Seq<u8>) -> (nat, nat)\n    recommends\n        hash_bytes.len() == 32,\n{\n    // Extract sign bit from bit 255 (MSB of last byte)\n    let sign_bit: u8 = (hash_bytes[31] & 0x80u8) >> 7;\n    // Interpret bytes as field element (mod 2^255 to clear high bit, then reduce mod p)\n    let fe_nat = (bytes_seq_to_nat(hash_bytes) % pow2(255)) % p();\n    // Elligator2 encoding: field element -> Montgomery u-coordinate\n    let u = spec_elligator_encode(fe_nat);\n    // Convert Montgomery to Edwards with sign bit selecting x\n    let P = spec_montgomery_to_edwards_affine_with_sign(u, sign_bit);\n    // Cofactor clearing: multiply by 8 to ensure prime-order subgroup\n    edwards_scalar_mul(P, 8)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":999,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Top-level spec for `EdwardsPoint::nonspec_map_to_curve_verus`.\n\nReference: RFC 9380 Section 6.7.1 - Elligator 2 Method\n<https://www.rfc-editor.org/rfc/rfc9380.html#section-6.7.1>\n\nNote from Dalek code: This is NOT a proper hash-to-curve (non-uniform distribution).\nA proper hash-to-curve applies Elligator twice and adds the results.","math_interpretation":"","informal_interpretation":"Top-level spec for `EdwardsPoint::nonspec_map_to_curve_verus`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L999","category":"spec","referenced_specs":["bytes_seq_to_nat","edwards_scalar_mul","p","spec_elligator_encode","spec_montgomery_to_edwards_affine_with_sign"]},{"id":"specs__edwards_specs__spec_projective_point_edwards","name":"spec_projective_point_edwards","signature":"pub open spec fn spec_projective_point_edwards(point: ProjectivePoint) -> (nat, nat, nat)","body":"pub open spec fn spec_projective_point_edwards(point: ProjectivePoint) -> (nat, nat, nat) {\n    let x = spec_field_element(&point.X);\n    let y = spec_field_element(&point.Y);\n    let z = spec_field_element(&point.Z);\n    (x, y, z)\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":425,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Returns the field element values (X, Y, Z) from an Edwards ProjectivePoint.\nAn Edwards ProjectivePoint (X:Y:Z) is in projective coordinates.","math_interpretation":"","informal_interpretation":"Returns the field element values (X, Y, Z) from an Edwards ProjectivePoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L425","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__edwards_specs__spec_projective_to_extended","name":"spec_projective_to_extended","signature":"pub open spec fn spec_projective_to_extended(point: ProjectivePoint) -> (nat, nat, nat, nat)","body":"pub open spec fn spec_projective_to_extended(point: ProjectivePoint) -> (nat, nat, nat, nat) {\n    let (x, y, z) = spec_projective_point_edwards(point);\n    (math_field_mul(x, z), math_field_mul(y, z), math_field_square(z), math_field_mul(x, y))\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":820,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec for ProjectivePoint::as_extended conversion\nConverts from P² to P³ via:\n(X:Y:Z) ↦ (X·Z : Y·Z : Z² : X·Y)\nThis preserves the affine point and establishes the extended coordinate invariant","math_interpretation":"","informal_interpretation":"Spec for ProjectivePoint::as_extended conversion","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L820","category":"spec","referenced_specs":["math_field_mul","math_field_square","spec_projective_point_edwards"]},{"id":"specs__edwards_specs__sum_of_points","name":"sum_of_points","signature":"pub open spec fn sum_of_points(points: Seq<EdwardsPoint>) -> (nat, nat) decreases points.len(),","body":"pub open spec fn sum_of_points(points: Seq<EdwardsPoint>) -> (nat, nat)\n    decreases points.len(),\n{\n    if points.len() == 0 {\n        // Identity point in affine coordinates: (0, 1)\n        (0, 1)\n    } else {\n        let last = (points.len() - 1) as int;\n        let prev = sum_of_points(points.subrange(0, last));\n        let point_affine = edwards_point_as_affine(points[last]);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":868,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec function to compute sum of all EdwardsPoints in a sequence.\nReturns the affine coordinates of the result.\nNote: Processes from back to front to match iterative loop order.","math_interpretation":"","informal_interpretation":"Spec function to compute sum of all EdwardsPoints in a sequence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L868","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine"]},{"id":"specs__edwards_specs__sum_of_scalar_muls","name":"sum_of_scalar_muls","signature":"pub open spec fn sum_of_scalar_muls(scalars: Seq<Scalar>, points: Seq<EdwardsPoint>) -> (nat, nat) decreases scalars.len(),","body":"pub open spec fn sum_of_scalar_muls(scalars: Seq<Scalar>, points: Seq<EdwardsPoint>) -> (nat, nat)\n    decreases scalars.len(),\n{\n    let len = if scalars.len() <= points.len() {\n        scalars.len()\n    } else {\n        points.len()\n    };\n    if len == 0 {\n        // Identity point in affine coordinates: (0, 1)\n        (0, 1)\n    } else {\n        let last = (len - 1) as int;\n        let prev = sum_of_scalar_muls(scalars.subrange(0, last), points.subrange(0, last));\n        let point_affine = edwards_point_as_affine(points[last]);\n        // Use scalar_to_nat (not spec_scalar) to match implementation ensures clauses\n        let scalar_nat = scalar_to_nat(&scalars[last]);\n        let scaled = edwards_scalar_mul(point_affine, scalar_nat);\n        edwards_add(prev.0, prev.1, scaled.0, scaled.1)\n    }\n}","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":884,"module":"specs::edwards_specs","visibility":"pub open spec fn","doc_comment":"Spec function to compute sum of scalar multiplications.\nReturns the affine coordinates of sum(scalars[i] * points[i] for i in 0..min(len_s, len_p)).","math_interpretation":"","informal_interpretation":"Spec function to compute sum of scalar multiplications.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L884","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine","edwards_scalar_mul","scalar_to_nat"]},{"id":"specs__field_specs__fe51_limbs_bounded","name":"fe51_limbs_bounded","signature":"pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool","body":"pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe.limbs[i] < (1u64 << bit_limit)\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":27,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec predicate: all limbs are bounded by a given bit limit","math_interpretation":"forall i in [0..5). limb[i] < 2^b","informal_interpretation":"Checks that a field element’s radix-2^51 limbs are within the given bound.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L27","category":"spec","referenced_specs":[]},{"id":"specs__field_specs__is_inverse_field","name":"is_inverse_field","signature":"pub open spec fn is_inverse_field(a: &FieldElement51, b: &FieldElement51) -> bool","body":"pub open spec fn is_inverse_field(a: &FieldElement51, b: &FieldElement51) -> bool {\n    (spec_field_element(a) * spec_field_element(b)) % p() == 1\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":426,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: two field elements are inverses if their product is 1 (mod p)","math_interpretation":"","informal_interpretation":"Spec function: two field elements are inverses if their product is 1 (mod p)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L426","category":"spec","referenced_specs":["p","spec_field_element"]},{"id":"specs__field_specs__is_sqrt_ratio","name":"is_sqrt_ratio","signature":"pub open spec fn is_sqrt_ratio(u: &FieldElement51, v: &FieldElement51, r: &FieldElement51) -> bool","body":"pub open spec fn is_sqrt_ratio(u: &FieldElement51, v: &FieldElement51, r: &FieldElement51) -> bool {\n    (spec_field_element(r) * spec_field_element(r) * spec_field_element(v)) % p()\n        == spec_field_element(u)\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":472,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: b^2 * v = u (mod p)","math_interpretation":"Spec function: b^2 * v = u (mod p)","informal_interpretation":"Spec function: b^2 * v = u (mod p)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L472","category":"spec","referenced_specs":["p","spec_field_element"]},{"id":"specs__field_specs__is_sqrt_ratio_times_i","name":"is_sqrt_ratio_times_i","signature":"pub open spec fn is_sqrt_ratio_times_i( u: &FieldElement51, v: &FieldElement51, r: &FieldElement51, ) -> bool","body":"pub open spec fn is_sqrt_ratio_times_i(\n    u: &FieldElement51,\n    v: &FieldElement51,\n    r: &FieldElement51,\n) -> bool {\n    (spec_field_element(r) * spec_field_element(r) * spec_field_element(v)) % p() == (\n    spec_field_element(&constants::SQRT_M1) * spec_field_element(u)) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":479,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: r^2 * v = i*u (mod p), where i = sqrt(-1)\nUsed for the nonsquare case in sqrt_ratio_i","math_interpretation":"Spec function: r^2 * v = i*u (mod p), where i = sqrt(-1)","informal_interpretation":"Spec function: r^2 * v = i*u (mod p), where i = sqrt(-1)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L479","category":"spec","referenced_specs":["p","spec_field_element"]},{"id":"specs__field_specs__is_square_mod_p","name":"is_square_mod_p","signature":"pub open spec fn is_square_mod_p(a: nat) -> bool","body":"pub open spec fn is_square_mod_p(a: nat) -> bool {\n    exists|y: nat| (#[trigger] (y * y) % p()) == (a % p())\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":568,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L568","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_field_add","name":"math_field_add","signature":"pub open spec fn math_field_add(a: nat, b: nat) -> nat","body":"pub open spec fn math_field_add(a: nat, b: nat) -> nat {\n    (a + b) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":110,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field addition","math_interpretation":"(a + b) mod p, p = 2^255-19","informal_interpretation":"Math-level field addition","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L110","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_field_inv","name":"math_field_inv","signature":"pub open spec fn math_field_inv(a: nat) -> nat","body":"pub open spec fn math_field_inv(a: nat) -> nat {\n    if a % p() == 0 {\n        0  // Convention: inverse of 0 is defined as 0\n\n    } else {\n        spec_mod_inverse(a, p())\n    }\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":141,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field inversion: returns w such that (a * w) % p == 1\n\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\n\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\nwhich relies on p being prime.","math_interpretation":"a^(-1) mod p, p = 2^255-19","informal_interpretation":"Math-level field inversion: returns w such that (a * w) % p == 1\\n\\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\\n\\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\\nwhich relies on p being prime.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L141","category":"spec","referenced_specs":["p","spec_mod_inverse"]},{"id":"specs__field_specs__math_field_mul","name":"math_field_mul","signature":"pub open spec fn math_field_mul(a: nat, b: nat) -> nat","body":"pub open spec fn math_field_mul(a: nat, b: nat) -> nat {\n    (a * b) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":120,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field multiplication","math_interpretation":"(a * b) mod p, p = 2^255-19","informal_interpretation":"Math-level field multiplication","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L120","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_field_neg","name":"math_field_neg","signature":"pub open spec fn math_field_neg(a: nat) -> nat","body":"pub open spec fn math_field_neg(a: nat) -> nat {\n    (p() - (a % p())) as nat % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":125,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field negation","math_interpretation":"-a mod p, p = 2^255-19","informal_interpretation":"Math-level field negation","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L125","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_field_square","name":"math_field_square","signature":"pub open spec fn math_field_square(a: nat) -> nat","body":"pub open spec fn math_field_square(a: nat) -> nat {\n    (a * a) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":130,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field squaring","math_interpretation":"a^2 mod p, p = 2^255-19","informal_interpretation":"Math-level field squaring","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L130","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_field_sub","name":"math_field_sub","signature":"pub open spec fn math_field_sub(a: nat, b: nat) -> nat","body":"pub open spec fn math_field_sub(a: nat, b: nat) -> nat {\n    (((a % p()) + p()) - (b % p())) as nat % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":115,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Math-level field subtraction","math_interpretation":"(a - b) mod p, p = 2^255-19","informal_interpretation":"Math-level field subtraction","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L115","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_invsqrt","name":"math_invsqrt","signature":"pub open spec fn math_invsqrt(a: nat) -> nat","body":"pub open spec fn math_invsqrt(a: nat) -> nat {\n    if a % p() == 0 {\n        0\n    } else {\n        choose|r: nat|\n            #![auto]\n            !math_is_negative(r) && (math_is_sqrt_ratio(1, a, r) || math_is_sqrt_ratio_times_i(\n                1,\n                a,\n                r,\n            ))\n    }\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":510,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of inverse square root with a canonical sign choice.\n\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).","math_interpretation":"1/sqrt(a) mod p (canonical sign)","informal_interpretation":"Spec-only model of inverse square root with a canonical sign choice.\\n\\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L510","category":"spec","referenced_specs":["math_is_negative","math_is_sqrt_ratio","math_is_sqrt_ratio_times_i","p"]},{"id":"specs__field_specs__math_is_negative","name":"math_is_negative","signature":"pub open spec fn math_is_negative(a: nat) -> bool","body":"pub open spec fn math_is_negative(a: nat) -> bool {\n    (a % p()) % 2 == 1\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":503,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec predicate: a field element is negative if its canonical low bit is 1.","math_interpretation":"a mod p is odd (sign convention)","informal_interpretation":"Spec predicate: a field element is negative if its canonical low bit is 1.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L503","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_is_sqrt_ratio","name":"math_is_sqrt_ratio","signature":"pub open spec fn math_is_sqrt_ratio(u: nat, v: nat, r: nat) -> bool","body":"pub open spec fn math_is_sqrt_ratio(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == u\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":491,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: r² * v = u (mod p) — math version operating on nat values\nThis is the mathematical equivalent of is_sqrt_ratio but without FieldElement wrappers.\nUse this when working with mathematical values directly in lemmas.","math_interpretation":"r^2 * v = u (mod p)","informal_interpretation":"Spec function: r² * v = u (mod p) — math version operating on nat values\\nThis is the mathematical equivalent of is_sqrt_ratio but without FieldElement wrappers.\\nUse this when working with mathematical values directly in lemmas.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L491","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_is_sqrt_ratio_times_i","name":"math_is_sqrt_ratio_times_i","signature":"pub open spec fn math_is_sqrt_ratio_times_i(u: nat, v: nat, r: nat) -> bool","body":"pub open spec fn math_is_sqrt_ratio_times_i(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == (spec_sqrt_m1() * u) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":498,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: r² * v = i*u (mod p) — math version operating on nat values\nUsed for the nonsquare case in sqrt_ratio_i.\nThis is the mathematical equivalent of is_sqrt_ratio_times_i.","math_interpretation":"r^2 * v = i*u (mod p), i = sqrt(-1)","informal_interpretation":"Spec function: r² * v = i*u (mod p) — math version operating on nat values\\nUsed for the nonsquare case in sqrt_ratio_i.\\nThis is the mathematical equivalent of is_sqrt_ratio_times_i.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L498","category":"spec","referenced_specs":["p","spec_sqrt_m1"]},{"id":"specs__field_specs__math_is_square","name":"math_is_square","signature":"pub open spec fn math_is_square(a: nat) -> bool","body":"pub open spec fn math_is_square(a: nat) -> bool {\n    exists|y: nat| (#[trigger] (y * y) % p()) == (a % p())\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":319,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Check if a value is a quadratic residue (square) modulo p","math_interpretation":"","informal_interpretation":"Check if a value is a quadratic residue (square) modulo p","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L319","category":"spec","referenced_specs":["p"]},{"id":"specs__field_specs__math_sqrt","name":"math_sqrt","signature":"pub open spec fn math_sqrt(a: nat) -> nat recommends math_is_square(a),","body":"pub open spec fn math_sqrt(a: nat) -> nat\n    recommends\n        math_is_square(a),\n{\n    choose|y: nat| y < p() && #[trigger] ((y * y) % p()) == (a % p())\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":327,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Compute a square root modulo p (if it exists)\nReturns some y such that y^2 ≡ a (mod p)\nThe result is unspecified if a is not a quadratic residue\nNote result is not unique","math_interpretation":"Returns some y such that y^2 ≡ a (mod p)","informal_interpretation":"Compute a square root modulo p (if it exists)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L327","category":"spec","referenced_specs":["math_is_square","p"]},{"id":"specs__field_specs__spec_add_fe51_limbs","name":"spec_add_fe51_limbs","signature":"pub open spec fn spec_add_fe51_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51","body":"pub open spec fn spec_add_fe51_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51 {\n    FieldElement51 {\n        limbs: [\n            (a.limbs[0] + b.limbs[0]) as u64,\n            (a.limbs[1] + b.limbs[1]) as u64,\n            (a.limbs[2] + b.limbs[2]) as u64,\n            (a.limbs[3] + b.limbs[3]) as u64,\n            (a.limbs[4] + b.limbs[4]) as u64,\n        ],\n    }\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":41,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: result of limb-wise addition (what add_spec returns)","math_interpretation":"","informal_interpretation":"Spec function: result of limb-wise addition (what add_spec returns)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L41","category":"spec","referenced_specs":[]},{"id":"specs__field_specs__spec_bytes32_from_nat","name":"spec_bytes32_from_nat","signature":"pub open spec fn spec_bytes32_from_nat(n: nat) -> [u8; 32]","body":"pub open spec fn spec_bytes32_from_nat(n: nat) -> [u8; 32] {\n    choose|b: [u8; 32]| bytes32_to_nat(&b) == n % pow2(256)\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":525,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Canonical little-endian bytes for a nat (mod 2^256).","math_interpretation":"n mod 2^256 -> [u8;32] little-endian","informal_interpretation":"Canonical little-endian bytes for a nat (mod 2^256).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L525","category":"spec","referenced_specs":["bytes32_to_nat"]},{"id":"specs__field_specs__spec_fe51_from_bytes","name":"spec_fe51_from_bytes","signature":"pub open spec fn spec_fe51_from_bytes(bytes: &[u8; 32]) -> FieldElement51","body":"pub open spec fn spec_fe51_from_bytes(bytes: &[u8; 32]) -> FieldElement51 {\n    // Mimic the implementation in field_verus.rs:from_bytes\n    // Load 8-byte chunks at specified offsets and mask to 51-bit limbs\n    let low_51_bit_mask = mask51;\n\n    FieldElement51 {\n        limbs: [\n        // load bits [  0, 64), mask to 51 bits\n\n            (spec_load8_at(bytes, 0) as u64) & low_51_bit_mask,\n            // load bits [ 48,112), shift right by 3, mask to 51 bits\n            ((spec_load8_at(bytes, 6) as u64) >> 3) & low_51_bit_mask,\n            // load bits [ 96,160), shift right by 6, mask to 51 bits\n            ((spec_load8_at(bytes, 12) as u64) >> 6) & low_51_bit_mask,\n            // load bits [152,216), shift right by 1, mask to 51 bits\n            ((spec_load8_at(bytes, 19) as u64) >> 1) & low_51_bit_mask,\n            // load bits [192,256), shift right by 12, mask to 51 bits (this ignores high bit)\n            ((spec_load8_at(bytes, 24) as u64) >> 12) & low_51_bit_mask,\n        ],\n    }\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":337,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function for FieldElement::from_bytes\nTakes a 32-byte array and produces a FieldElement51\nThe high bit of byte[31] is ignored, giving a 255-bit value","math_interpretation":"","informal_interpretation":"Spec function for FieldElement::from_bytes","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L337","category":"spec","referenced_specs":["spec_load8_at"]},{"id":"specs__field_specs__spec_fe51_to_bytes","name":"spec_fe51_to_bytes","signature":"pub open spec fn spec_fe51_to_bytes(fe: &FieldElement51) -> Seq<u8>","body":"pub open spec fn spec_fe51_to_bytes(fe: &FieldElement51) -> Seq<u8> {\n    // Step 1: Basic reduction to ensure h < 2*p\n    let limbs = spec_reduce(fe.limbs);\n\n    // Step 2: Compute q (quotient) to detect if limbs >= p\n    // q = 0 if h < p, q = 1 if h >= p\n    // This works because h >= p <==> h + 19 >= 2^255\n    let q0 = ((limbs[0] + 19) as u64) >> 51;\n    let q1 = ((limbs[1] + q0) as u64) >> 51;\n    let q2 = ((limbs[2] + q1) as u64) >> 51;\n    let q3 = ((limbs[3] + q2) as u64) >> 51;\n    let q = ((limbs[4] + q3) as u64) >> 51;\n\n    // Step 3: Compute r = h - pq = h + 19q - 2^255q\n    // Add 19*q to limbs[0]\n    let limbs0_adj = (limbs[0] + 19 * q) as u64;\n\n    // Step 4: Propagate carries and mask to 51 bits (this subtracts 2^255q implicitly)\n    let limbs1_adj = (limbs[1] + (limbs0_adj >> 51)) as u64;\n    let limbs0_canon = (limbs0_adj & mask51) as u64;\n    let limbs2_adj = (limbs[2] + (limbs1_adj >> 51)) as u64;\n    let limbs1_canon = (limbs1_adj & mask51) as u64;\n    let limbs3_adj = (limbs[3] + (limbs2_adj >> 51)) as u64;\n    let limbs2_canon = (limbs2_adj & mask51) as u64;\n    let limbs4_adj = (limbs[4] + (limbs3_adj >> 51)) as u64;\n    let limbs3_canon = (limbs3_adj & mask51) as u64;\n    // Discard carry from limbs[4], which subtracts 2^255q\n    let limbs4_canon = (limbs4_adj & mask51) as u64;\n\n    // Step 5: Pack canonical limbs into 32 bytes (little-endian)\n    seq![\n        limbs0_canon as u8,\n        (limbs0_canon >> 8) as u8,\n        (limbs0_canon >> 16) as u8,\n        (limbs0_canon >> 24) as u8,\n        (limbs0_canon >> 32) as u8,\n        (limbs0_canon >> 40) as u8,\n        ((limbs0_canon >> 48) | (limbs1_canon << 3)) as u8,\n        (limbs1_canon >> 5) as u8,\n        (limbs1_canon >> 13) as u8,\n        (limbs1_canon >> 21) as u8,\n        (limbs1_canon >> 29) as u8,\n        (limbs1_canon >> 37) as u8,\n        ((limbs1_canon >> 45) | (limbs2_canon << 6)) as u8,\n        (limbs2_canon >> 2) as u8,\n        (limbs2_canon >> 10) as u8,\n        (limbs2_canon >> 18) as u8,\n        (limbs2_canon >> 26) as u8,\n        (limbs2_canon >> 34) as u8,\n        (limbs2_canon >> 42) as u8,\n        ((limbs2_canon >> 50) | (limbs3_canon << 1)) as u8,\n        (limbs3_canon >> 7) as u8,\n        (limbs3_canon >> 15) as u8,\n        (limbs3_canon >> 23) as u8,\n        (limbs3_canon >> 31) as u8,\n        (limbs3_canon >> 39) as u8,\n        ((limbs3_canon >> 47) | (limbs4_canon << 4)) as u8,\n        (limbs4_canon >> 4) as u8,\n        (limbs4_canon >> 12) as u8,\n        (limbs4_canon >> 20) as u8,\n        (limbs4_canon >> 28) as u8,\n        (limbs4_canon >> 36) as u8,\n        (limbs4_canon >> 44) as u8,\n    ]\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":359,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L359","category":"spec","referenced_specs":["p","spec_reduce"]},{"id":"specs__field_specs__spec_field_element","name":"spec_field_element","signature":"pub open spec fn spec_field_element(fe: &FieldElement51) -> nat","body":"pub open spec fn spec_field_element(fe: &FieldElement51) -> nat {\n    spec_field_element_as_nat(fe) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":75,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Returns the canonical mathematical value of a field element in [0, p)\nwhere p = 2^255 - 19","math_interpretation":"fe -> fe mod p, canonical in [0, p)","informal_interpretation":"Interprets a field element value as an integer modulo the prime p.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L75","category":"spec","referenced_specs":["p","spec_field_element_as_nat"]},{"id":"specs__field_specs__spec_field_element_as_nat","name":"spec_field_element_as_nat","signature":"pub open spec fn spec_field_element_as_nat(fe: &FieldElement51) -> nat","body":"pub open spec fn spec_field_element_as_nat(fe: &FieldElement51) -> nat {\n    u64_5_as_nat(fe.limbs)\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":69,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"sum_i limb[i] * 2^(51i)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L69","category":"spec","referenced_specs":["u64_5_as_nat"]},{"id":"specs__field_specs__spec_field_element_from_bytes","name":"spec_field_element_from_bytes","signature":"pub open spec fn spec_field_element_from_bytes(bytes: &[u8; 32]) -> nat","body":"pub open spec fn spec_field_element_from_bytes(bytes: &[u8; 32]) -> nat {\n    (bytes32_to_nat(bytes) % pow2(255)) % p()\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":98,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Returns the canonical mathematical value when creating a field element from bytes.\nThe bytes are interpreted as a little-endian integer with the high bit of byte[31] ignored.\nThe result is the canonical value in [0, p) where p = 2^255 - 19.","math_interpretation":"LE(b) mod 2^255 mod p","informal_interpretation":"Interprets 32 bytes as a field element (spec-level decoding).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L98","category":"spec","referenced_specs":["bytes32_to_nat","p"]},{"id":"specs__field_specs__spec_field_element_sign_bit","name":"spec_field_element_sign_bit","signature":"pub open spec fn spec_field_element_sign_bit(fe: &FieldElement51) -> u8","body":"pub open spec fn spec_field_element_sign_bit(fe: &FieldElement51) -> u8 {\n    ((spec_field_element(fe) % p()) % 2) as u8\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":104,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: Get the sign bit of a field element\nIn Curve25519, the sign bit is the least significant bit of the canonical representation","math_interpretation":"(fe mod p) mod 2 (parity bit)","informal_interpretation":"Returns the sign bit used in point compression (typically the parity of x).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L104","category":"spec","referenced_specs":["p","spec_field_element"]},{"id":"specs__field_specs__spec_sqrt_m1","name":"spec_sqrt_m1","signature":"pub open spec fn spec_sqrt_m1() -> nat","body":"pub open spec fn spec_sqrt_m1() -> nat {\n    spec_field_element(&constants::SQRT_M1)\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":584,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"The mathematical value of SQRT_M1 (sqrt(-1) mod p)\nThis is the 4th root of unity i such that i² = -1 (mod p)","math_interpretation":"i in F_p : i^2 = -1 (mod p)","informal_interpretation":"The mathematical value of SQRT_M1 (sqrt(-1) mod p)\\nThis is the 4th root of unity i such that i² = -1 (mod p)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L584","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__field_specs__spec_sub_limbs","name":"spec_sub_limbs","signature":"pub open spec fn spec_sub_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51","body":"pub open spec fn spec_sub_limbs(a: &FieldElement51, b: &FieldElement51) -> FieldElement51 {\n    FieldElement51 {\n        limbs: spec_reduce(\n            [\n                ((a.limbs[0] + 36028797018963664u64) - b.limbs[0]) as u64,\n                ((a.limbs[1] + 36028797018963952u64) - b.limbs[1]) as u64,\n                ((a.limbs[2] + 36028797018963952u64) - b.limbs[2]) as u64,\n                ((a.limbs[3] + 36028797018963952u64) - b.limbs[3]) as u64,\n                ((a.limbs[4] + 36028797018963952u64) - b.limbs[4]) as u64,\n            ],\n        ),\n    }\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":55,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec function: result of limb-wise subtraction with reduction (what sub_spec returns)\nAdds multiples of p to avoid underflow, then reduces","math_interpretation":"","informal_interpretation":"Spec function: result of limb-wise subtraction with reduction (what sub_spec returns)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L55","category":"spec","referenced_specs":["spec_reduce"]},{"id":"specs__field_specs__sum_of_limbs_bounded","name":"sum_of_limbs_bounded","signature":"pub open spec fn sum_of_limbs_bounded( fe1: &FieldElement51, fe2: &FieldElement51, bound: u64, ) -> bool","body":"pub open spec fn sum_of_limbs_bounded(\n    fe1: &FieldElement51,\n    fe2: &FieldElement51,\n    bound: u64,\n) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe1.limbs[i] + fe2.limbs[i] < bound\n}","file":"curve25519-dalek/src/specs/field_specs.rs","line":32,"module":"specs::field_specs","visibility":"pub open spec fn","doc_comment":"Spec predicate: sum of limbs are bounded by a given bit limit","math_interpretation":"forall i. limb1[i] + limb2[i] < bound","informal_interpretation":"Checks that adding two field-element limb arrays stays within a safe bound (used to justify u64/u128 arithmetic).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs.rs#L32","category":"spec","referenced_specs":[]},{"id":"specs__field_specs_u64__p","name":"p","signature":"pub open spec fn p() -> nat","body":"pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n}","file":"curve25519-dalek/src/specs/field_specs_u64.rs","line":11,"module":"specs::field_specs_u64","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"p = 2^255 - 19 (Curve25519 prime)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L11","category":"spec","referenced_specs":[]},{"id":"specs__field_specs_u64__pre_reduce_limbs","name":"pre_reduce_limbs","signature":"pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5]","body":"pub open spec fn pre_reduce_limbs(limbs: [u64; 5]) -> [u64; 5] {\n    let r = [\n        (sixteen_p_vec[0] - limbs[0]) as u64,\n        (sixteen_p_vec[1] - limbs[1]) as u64,\n        (sixteen_p_vec[2] - limbs[2]) as u64,\n        (sixteen_p_vec[3] - limbs[3]) as u64,\n        (sixteen_p_vec[4] - limbs[4]) as u64,\n    ];\n    r\n}","file":"curve25519-dalek/src/specs/field_specs_u64.rs","line":82,"module":"specs::field_specs_u64","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L82","category":"spec","referenced_specs":[]},{"id":"specs__field_specs_u64__spec_negate","name":"spec_negate","signature":"pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5]","body":"pub open spec fn spec_negate(limbs: [u64; 5]) -> [u64; 5] {\n    let r = spec_reduce(pre_reduce_limbs(limbs));\n    r\n}","file":"curve25519-dalek/src/specs/field_specs_u64.rs","line":93,"module":"specs::field_specs_u64","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L93","category":"spec","referenced_specs":["pre_reduce_limbs","spec_reduce"]},{"id":"specs__field_specs_u64__spec_reduce","name":"spec_reduce","signature":"pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5])","body":"pub open spec fn spec_reduce(limbs: [u64; 5]) -> (r: [u64; 5]) {\n    let r = [\n        ((limbs[0] & mask51) + (limbs[4] >> 51) * 19) as u64,\n        ((limbs[1] & mask51) + (limbs[0] >> 51)) as u64,\n        ((limbs[2] & mask51) + (limbs[1] >> 51)) as u64,\n        ((limbs[3] & mask51) + (limbs[2] >> 51)) as u64,\n        ((limbs[4] & mask51) + (limbs[3] >> 51)) as u64,\n    ];\n    r\n}","file":"curve25519-dalek/src/specs/field_specs_u64.rs","line":62,"module":"specs::field_specs_u64","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L62","category":"spec","referenced_specs":[]},{"id":"specs__field_specs_u64__u64_5_as_nat","name":"u64_5_as_nat","signature":"pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat","body":"pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n}","file":"curve25519-dalek/src/specs/field_specs_u64.rs","line":52,"module":"specs::field_specs_u64","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"sum_i limb[i] * 2^(51i), radix-2^51","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/field_specs_u64.rs#L52","category":"spec","referenced_specs":[]},{"id":"specs__iterator_specs__all_points_some","name":"all_points_some","signature":"pub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool","body":"pub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool {\n    forall|i: int| 0 <= i < points.len() ==> points[i].is_some()\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":56,"module":"specs::iterator_specs","visibility":"pub open spec fn","doc_comment":"Check if all optional points in a sequence are Some.","math_interpretation":"","informal_interpretation":"Check if all optional points in a sequence are Some.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L56","category":"spec","referenced_specs":[]},{"id":"specs__iterator_specs__spec_edwards_from_ristretto_iter","name":"spec_edwards_from_ristretto_iter","signature":"pub uninterp spec fn spec_edwards_from_ristretto_iter<P, J>(iter: J) -> Seq<EdwardsPoint>; /// Spec function to convert an iterator of Option<RistrettoPoint> directly to /// a sequence of Option<EdwardsPoint> (extracting .0 from each Some). pub uninterp spec fn spec_optional_edwards_from_ristretto_iter<J>(iter: J) -> Seq< Option<EdwardsPoint>, >; /// Spec function to compute sum of all RistrettoPoints in a sequence. /// Returns the affine coordinates of the result. pub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat) decreases points.len(),","body":"pub uninterp spec fn spec_edwards_from_ristretto_iter<P, J>(iter: J) -> Seq<EdwardsPoint>;\n\n/// Spec function to convert an iterator of Option<RistrettoPoint> directly to\n/// a sequence of Option<EdwardsPoint> (extracting .0 from each Some).\npub uninterp spec fn spec_optional_edwards_from_ristretto_iter<J>(iter: J) -> Seq<\n    Option<EdwardsPoint>,\n>;\n\n/// Spec function to compute sum of all RistrettoPoints in a sequence.\n/// Returns the affine coordinates of the result.\npub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat)\n    decreases points.len(),\n{\n    if points.len() == 0 {\n        // Identity point in affine coordinates: (0, 1)\n        (0, 1)\n    } else {\n        let last = (points.len() - 1) as int;\n        let prev = sum_of_ristretto_points(points.subrange(0, last));\n        let point_affine = edwards_point_as_affine(points[last].0);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":227,"module":"specs::iterator_specs","visibility":"pub uninterp spec fn","doc_comment":"Spec function to convert an iterator of RistrettoPoints directly to\na sequence of EdwardsPoints (extracting .0 from each).","math_interpretation":"","informal_interpretation":"Spec function to convert an iterator of RistrettoPoints directly to","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L227","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine","spec_optional_edwards_from_ristretto_iter","sum_of_ristretto_points"]},{"id":"specs__iterator_specs__spec_optional_edwards_from_ristretto_iter","name":"spec_optional_edwards_from_ristretto_iter","signature":"pub uninterp spec fn spec_optional_edwards_from_ristretto_iter<J>(iter: J) -> Seq< Option<EdwardsPoint>, >; /// Spec function to compute sum of all RistrettoPoints in a sequence. /// Returns the affine coordinates of the result. pub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat) decreases points.len(),","body":"pub uninterp spec fn spec_optional_edwards_from_ristretto_iter<J>(iter: J) -> Seq<\n    Option<EdwardsPoint>,\n>;\n\n/// Spec function to compute sum of all RistrettoPoints in a sequence.\n/// Returns the affine coordinates of the result.\npub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat)\n    decreases points.len(),\n{\n    if points.len() == 0 {\n        // Identity point in affine coordinates: (0, 1)\n        (0, 1)\n    } else {\n        let last = (points.len() - 1) as int;\n        let prev = sum_of_ristretto_points(points.subrange(0, last));\n        let point_affine = edwards_point_as_affine(points[last].0);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":231,"module":"specs::iterator_specs","visibility":"pub uninterp spec fn","doc_comment":"Spec function to convert an iterator of Option<RistrettoPoint> directly to\na sequence of Option<EdwardsPoint> (extracting .0 from each Some).","math_interpretation":"","informal_interpretation":"Spec function to convert an iterator of Option<RistrettoPoint> directly to","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L231","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine","sum_of_ristretto_points"]},{"id":"specs__iterator_specs__spec_optional_points_from_iter","name":"spec_optional_points_from_iter","signature":"pub uninterp spec fn spec_optional_points_from_iter<J>(iter: J) -> Seq<Option<EdwardsPoint>>; /// Spec function to convert an iterator of points to a sequence. pub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>; // ============================================================================ // Spec functions for optional point sequences // ============================================================================ /// Check if all optional points in a sequence are Some. pub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool","body":"pub uninterp spec fn spec_optional_points_from_iter<J>(iter: J) -> Seq<Option<EdwardsPoint>>;\n\n/// Spec function to convert an iterator of points to a sequence.\npub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>;\n\n// ============================================================================\n// Spec functions for optional point sequences\n// ============================================================================\n/// Check if all optional points in a sequence are Some.\npub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool {\n    forall|i: int| 0 <= i < points.len() ==> points[i].is_some()\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":47,"module":"specs::iterator_specs","visibility":"pub uninterp spec fn","doc_comment":"Spec function to convert an iterator of optional points to a sequence.","math_interpretation":"","informal_interpretation":"Spec function to convert an iterator of optional points to a sequence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L47","category":"spec","referenced_specs":["all_points_some","spec_points_from_iter"]},{"id":"specs__iterator_specs__spec_points_from_iter","name":"spec_points_from_iter","signature":"pub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>; // ============================================================================ // Spec functions for optional point sequences // ============================================================================ /// Check if all optional points in a sequence are Some. pub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool","body":"pub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>;\n\n// ============================================================================\n// Spec functions for optional point sequences\n// ============================================================================\n/// Check if all optional points in a sequence are Some.\npub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool {\n    forall|i: int| 0 <= i < points.len() ==> points[i].is_some()\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":50,"module":"specs::iterator_specs","visibility":"pub uninterp spec fn","doc_comment":"Spec function to convert an iterator of points to a sequence.","math_interpretation":"","informal_interpretation":"Spec function to convert an iterator of points to a sequence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L50","category":"spec","referenced_specs":["all_points_some"]},{"id":"specs__iterator_specs__spec_scalars_from_iter","name":"spec_scalars_from_iter","signature":"pub uninterp spec fn spec_scalars_from_iter<S, I>(iter: I) -> Seq<Scalar>; /// Spec function to convert an iterator of optional points to a sequence. pub uninterp spec fn spec_optional_points_from_iter<J>(iter: J) -> Seq<Option<EdwardsPoint>>; /// Spec function to convert an iterator of points to a sequence. pub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>; // ============================================================================ // Spec functions for optional point sequences // ============================================================================ /// Check if all optional points in a sequence are Some. pub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool","body":"pub uninterp spec fn spec_scalars_from_iter<S, I>(iter: I) -> Seq<Scalar>;\n\n/// Spec function to convert an iterator of optional points to a sequence.\npub uninterp spec fn spec_optional_points_from_iter<J>(iter: J) -> Seq<Option<EdwardsPoint>>;\n\n/// Spec function to convert an iterator of points to a sequence.\npub uninterp spec fn spec_points_from_iter<P, J>(iter: J) -> Seq<EdwardsPoint>;\n\n// ============================================================================\n// Spec functions for optional point sequences\n// ============================================================================\n/// Check if all optional points in a sequence are Some.\npub open spec fn all_points_some(points: Seq<Option<EdwardsPoint>>) -> bool {\n    forall|i: int| 0 <= i < points.len() ==> points[i].is_some()\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":44,"module":"specs::iterator_specs","visibility":"pub uninterp spec fn","doc_comment":"Spec function to convert an iterator of scalars to a sequence.","math_interpretation":"","informal_interpretation":"Spec function to convert an iterator of scalars to a sequence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L44","category":"spec","referenced_specs":["all_points_some","spec_optional_points_from_iter","spec_points_from_iter"]},{"id":"specs__iterator_specs__sum_of_ristretto_points","name":"sum_of_ristretto_points","signature":"pub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat) decreases points.len(),","body":"pub open spec fn sum_of_ristretto_points(points: Seq<RistrettoPoint>) -> (nat, nat)\n    decreases points.len(),\n{\n    if points.len() == 0 {\n        // Identity point in affine coordinates: (0, 1)\n        (0, 1)\n    } else {\n        let last = (points.len() - 1) as int;\n        let prev = sum_of_ristretto_points(points.subrange(0, last));\n        let point_affine = edwards_point_as_affine(points[last].0);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":237,"module":"specs::iterator_specs","visibility":"pub open spec fn","doc_comment":"Spec function to compute sum of all RistrettoPoints in a sequence.\nReturns the affine coordinates of the result.","math_interpretation":"","informal_interpretation":"Spec function to compute sum of all RistrettoPoints in a sequence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L237","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine"]},{"id":"specs__iterator_specs__unwrap_points","name":"unwrap_points","signature":"pub open spec fn unwrap_points(points: Seq<Option<EdwardsPoint>>) -> Seq<EdwardsPoint> recommends all_points_some(points),","body":"pub open spec fn unwrap_points(points: Seq<Option<EdwardsPoint>>) -> Seq<EdwardsPoint>\n    recommends\n        all_points_some(points),\n{\n    points.map(|_i, opt: Option<EdwardsPoint>| opt.unwrap())\n}","file":"curve25519-dalek/src/specs/iterator_specs.rs","line":61,"module":"specs::iterator_specs","visibility":"pub open spec fn","doc_comment":"Extract EdwardsPoints from an Option sequence (assumes all are Some).","math_interpretation":"","informal_interpretation":"Extract EdwardsPoints from an Option sequence (assumes all are Some).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/iterator_specs.rs#L61","category":"spec","referenced_specs":["all_points_some"]},{"id":"specs__montgomery_reduce_specs__montgomery_congruent","name":"montgomery_congruent","signature":"pub open spec fn montgomery_congruent(result: &Scalar52, limbs: &[u128; 9]) -> bool","body":"pub open spec fn montgomery_congruent(result: &Scalar52, limbs: &[u128; 9]) -> bool {\n    (scalar52_to_nat(result) * montgomery_radix()) % group_order() == slice128_to_nat(limbs)\n        % group_order()\n}","file":"curve25519-dalek/src/specs/montgomery_reduce_specs.rs","line":65,"module":"specs::montgomery_reduce_specs","visibility":"pub open spec fn","doc_comment":"The Montgomery reduction property: result * R ≡ input (mod L)","math_interpretation":"","informal_interpretation":"The Montgomery reduction property: result * R ≡ input (mod L)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_reduce_specs.rs#L65","category":"spec","referenced_specs":["group_order","montgomery_radix","scalar52_to_nat","slice128_to_nat"]},{"id":"specs__montgomery_reduce_specs__montgomery_reduce_canonical_bound","name":"montgomery_reduce_canonical_bound","signature":"pub open spec fn montgomery_reduce_canonical_bound(limbs: &[u128; 9]) -> bool","body":"pub open spec fn montgomery_reduce_canonical_bound(limbs: &[u128; 9]) -> bool {\n    slice128_to_nat(limbs) < montgomery_radix() * group_order()\n}","file":"curve25519-dalek/src/specs/montgomery_reduce_specs.rs","line":60,"module":"specs::montgomery_reduce_specs","visibility":"pub open spec fn","doc_comment":"The value bound that montgomery_reduce requires to produce a canonical output.\nWhen the total value is < R * L, the intermediate result_raw will be < 2L,\nwhich allows sub(result_raw, L) to produce a canonical result.\n\n# Motivation\n- result_raw = (input + N*L) / R, where N < R\n- For result_raw < 2L: we need input/R + L < 2L, i.e., input < R*L\n\n# Relationship to r4_safe_bound\n- canonical_bound (T < R×L ≈ 2^512) implies r4_safe_bound (T < 2^520)\n- canonical_bound additionally ensures result < L (canonical)\n\n# Note\nThis is purely a VALUE constraint. The per-limb overflow bounds\n(montgomery_reduce_input_bounds) must be established separately.","math_interpretation":"- result_raw = (input + N*L) / R, where N < R","informal_interpretation":"The value bound that montgomery_reduce requires to produce a canonical output.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_reduce_specs.rs#L60","category":"spec","referenced_specs":["group_order","montgomery_radix","slice128_to_nat"]},{"id":"specs__montgomery_reduce_specs__montgomery_reduce_input_bounds","name":"montgomery_reduce_input_bounds","signature":"pub open spec fn montgomery_reduce_input_bounds(limbs: &[u128; 9]) -> bool","body":"pub open spec fn montgomery_reduce_input_bounds(limbs: &[u128; 9]) -> bool {\n    limbs[0] < pow2(104) &&  // 1 product term\n    limbs[1] < pow2(105) &&  // 2 product terms\n    limbs[2] < pow2(106) &&  // 3 product terms\n    limbs[3] < pow2(107) &&  // 4 product terms\n    limbs[4] < pow2(107) &&  // 5 product terms\n    limbs[5] < pow2(107) &&  // 4 product terms\n    limbs[6] < pow2(106) &&  // 3 product terms\n    limbs[7] < pow2(105) &&  // 2 product terms\n    limbs[8] < pow2(104)     // 1 product term\n}","file":"curve25519-dalek/src/specs/montgomery_reduce_specs.rs","line":33,"module":"specs::montgomery_reduce_specs","visibility":"pub open spec fn","doc_comment":"The limb bounds that montgomery_reduce requires to avoid overflow.\nThese are the bounds produced by mul_internal(bounded, bounded).\n\n# Motivation\nmontgomery_reduce performs iterative computations where each iteration\naccumulates products of limbs. To avoid overflow in u128 arithmetic,\nwe need these specific bounds on each input limb.","math_interpretation":"","informal_interpretation":"The limb bounds that montgomery_reduce requires to avoid overflow.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_reduce_specs.rs#L33","category":"spec","referenced_specs":[]},{"id":"specs__montgomery_specs__canonical_montgomery_lift","name":"canonical_montgomery_lift","signature":"pub open spec fn canonical_montgomery_lift(u: nat) -> MontgomeryAffine recommends is_valid_u_coordinate(u),","body":"pub open spec fn canonical_montgomery_lift(u: nat) -> MontgomeryAffine\n    recommends\n        is_valid_u_coordinate(u),\n{\n    let v = canonical_sqrt(montgomery_rhs(u));\n    MontgomeryAffine::Finite { u: u % p(), v }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":104,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Given u-coordinate of a Montgomery point (non-torsion),\nreturn the unique affine Montgomery point (u, v)\nwhere v is the canonical square root of u*(u^2 + A*u + 1).","math_interpretation":"","informal_interpretation":"Given u-coordinate of a Montgomery point (non-torsion),","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L104","category":"spec","referenced_specs":["canonical_sqrt","is_valid_u_coordinate","montgomery_rhs","p"]},{"id":"specs__montgomery_specs__canonical_sqrt","name":"canonical_sqrt","signature":"pub open spec fn canonical_sqrt(r: nat) -> nat recommends math_is_square(r),","body":"pub open spec fn canonical_sqrt(r: nat) -> nat\n    recommends\n        math_is_square(r),\n{\n    let s1 = math_sqrt(r);  // some square root\n    let s2 = math_field_neg(s1);  // the other root\n\n    if (s1 % 2 == 0) {\n        s1\n    } else {\n        s2\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":83,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Choose a canonical square root.\nReturn the sqrt(r) whose least-significant bit is 0.\n(This matches Ed25519’s canonical-sign rule.)","math_interpretation":"","informal_interpretation":"Choose a canonical square root.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L83","category":"spec","referenced_specs":["math_field_neg","math_is_square","math_sqrt"]},{"id":"specs__montgomery_specs__edwards_y_from_montgomery_u","name":"edwards_y_from_montgomery_u","signature":"pub open spec fn edwards_y_from_montgomery_u(u: nat) -> nat recommends u != math_field_sub(0, 1),","body":"pub open spec fn edwards_y_from_montgomery_u(u: nat) -> nat\n    recommends\n        u != math_field_sub(0, 1),\n{\n    let denom = math_field_add(u, 1);\n    let numerator = math_field_sub(u, 1);\n    math_field_mul(numerator, math_field_inv(denom))\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":276,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Map Montgomery u to Edwards affine y via y = (u-1)/(u+1).\nRecommends u != -1 to avoid division by zero.","math_interpretation":"Map Montgomery u to Edwards affine y via y = (u-1)/(u+1).","informal_interpretation":"Map Montgomery u to Edwards affine y via y = (u-1)/(u+1).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L276","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub"]},{"id":"specs__montgomery_specs__is_equal_to_minus_one","name":"is_equal_to_minus_one","signature":"pub open spec fn is_equal_to_minus_one(u: nat) -> bool","body":"pub open spec fn is_equal_to_minus_one(u: nat) -> bool {\n    u == math_field_sub(0, 1)  // u == -1\n\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":258,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Check if a Montgomery u-coordinate is invalid for conversion to Edwards\nu = -1 is invalid because it corresponds to a point on the twist","math_interpretation":"u = p - 1 (i.e. u = -1 mod p)","informal_interpretation":"Checks whether a field element equals -1 modulo the prime field.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L258","category":"spec","referenced_specs":["math_field_sub"]},{"id":"specs__montgomery_specs__is_valid_montgomery_point","name":"is_valid_montgomery_point","signature":"pub open spec fn is_valid_montgomery_point(point: crate::montgomery::MontgomeryPoint) -> bool","body":"pub open spec fn is_valid_montgomery_point(point: crate::montgomery::MontgomeryPoint) -> bool {\n    let u = spec_montgomery(point);\n    is_valid_u_coordinate(u)\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":117,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Check if a MontgomeryPoint's u-coordinate corresponds to a valid point on the Montgomery curve.\n\nA MontgomeryPoint is valid if its u-coordinate allows a canonical Montgomery lift,\nwhich requires that montgomery_rhs(u) = u³ + A·u² + u is a quadratic residue (square) mod p.\nThis ensures there exists a v such that v² = montgomery_rhs(u), making (u,v) a point on the curve.","math_interpretation":"","informal_interpretation":"Check if a MontgomeryPoint's u-coordinate corresponds to a valid point on the Montgomery curve.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L117","category":"spec","referenced_specs":["is_valid_u_coordinate","spec_montgomery"]},{"id":"specs__montgomery_specs__is_valid_u_coordinate","name":"is_valid_u_coordinate","signature":"pub open spec fn is_valid_u_coordinate(u: nat) -> bool","body":"pub open spec fn is_valid_u_coordinate(u: nat) -> bool {\n    math_is_square(montgomery_rhs(u))\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":97,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L97","category":"spec","referenced_specs":["math_is_square","montgomery_rhs"]},{"id":"specs__montgomery_specs__montgomery_add","name":"montgomery_add","signature":"pub open spec fn montgomery_add(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine","body":"pub open spec fn montgomery_add(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine {\n    match (P, Q) {\n        (MontgomeryAffine::Infinity, _) => Q,\n        (_, MontgomeryAffine::Infinity) => P,\n        (MontgomeryAffine::Finite { u: u1, v: v1 }, MontgomeryAffine::Finite { u: u2, v: v2 }) => {\n            let A = spec_field_element(&MONTGOMERY_A);\n\n            // P = -Q (same u, opposite v)\n            if u1 == u2 && math_field_add(v1, v2) == 0 {\n                MontgomeryAffine::Infinity\n            }\n            // P = Q (doubling)\n             else if u1 == u2 && v1 == v2 {\n                let u1_sq = math_field_square(u1);\n                let numerator = math_field_add(\n                    math_field_add(\n                        math_field_mul(3, u1_sq),\n                        math_field_mul(math_field_mul(2, A), u1),\n                    ),\n                    1,\n                );\n                let denominator = math_field_mul(2, v1);\n                let lambda = math_field_mul(numerator, math_field_inv(denominator));\n\n                let lambda_sq = math_field_square(lambda);\n                let u3 = math_field_sub(math_field_sub(lambda_sq, A), math_field_mul(2, u1));\n                let v3 = math_field_sub(math_field_mul(lambda, math_field_sub(u1, u3)), v1);\n\n                MontgomeryAffine::Finite { u: u3, v: v3 }\n            }\n            // Add for distinct points P != Q\n             else {\n                let numerator = math_field_sub(v2, v1);\n                let denominator = math_field_sub(u2, u1);\n                let lambda = math_field_mul(numerator, math_field_inv(denominator));\n\n                let lambda_sq = math_field_square(lambda);\n                let u3 = math_field_sub(math_field_sub(math_field_sub(lambda_sq, A), u1), u2);\n                let v3 = math_field_sub(math_field_mul(lambda, math_field_sub(u1, u3)), v1);\n\n                MontgomeryAffine::Finite { u: u3, v: v3 }\n            }\n        },\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":144,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Addition on the Montgomery curve using the chord-tangent method.\nFor the Montgomery curve B·v² = u³ + A·u² + u (with B=1, A=486662):\n\nAddition formulas:\n- If P = ∞ or Q = ∞: return the other point (identity element)\n- If P = -Q (same u, opposite v): return ∞\n- If P = Q (point doubling): λ = (3u₁² + 2Au₁ + 1) / (2v₁)\n- Otherwise (distinct points): λ = (v₂ - v₁) / (u₂ - u₁)\n\nThen: u₃ = λ² - A - u₁ - u₂  and  v₃ = λ(u₁ - u₃) - v₁","math_interpretation":"- If P = ∞ or Q = ∞: return the other point (identity element)","informal_interpretation":"Addition on the Montgomery curve using the chord-tangent method.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L144","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_square","math_field_sub","spec_field_element"]},{"id":"specs__montgomery_specs__montgomery_affine_u","name":"montgomery_affine_u","signature":"pub open spec fn montgomery_affine_u(P: MontgomeryAffine) -> nat","body":"pub open spec fn montgomery_affine_u(P: MontgomeryAffine) -> nat {\n    match P {\n        MontgomeryAffine::Infinity => 0,  // Convention: infinity maps to 0\n        MontgomeryAffine::Finite { u, v: _ } => u,\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":397,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Extract u-coordinate from a MontgomeryAffine point","math_interpretation":"","informal_interpretation":"Extract u-coordinate from a MontgomeryAffine point","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L397","category":"spec","referenced_specs":[]},{"id":"specs__montgomery_specs__montgomery_corresponds_to_edwards","name":"montgomery_corresponds_to_edwards","signature":"pub open spec fn montgomery_corresponds_to_edwards( montgomery: crate::montgomery::MontgomeryPoint, edwards: crate::edwards::EdwardsPoint, ) -> bool","body":"pub open spec fn montgomery_corresponds_to_edwards(\n    montgomery: crate::montgomery::MontgomeryPoint,\n    edwards: crate::edwards::EdwardsPoint,\n) -> bool {\n    let u = spec_montgomery(montgomery);\n    let (x, y) = crate::specs::edwards_specs::edwards_point_as_affine(edwards);\n    let denominator = math_field_sub(1, y);\n\n    if denominator == 0 {\n        // Special case: Edwards identity (x=0, y=1) maps to Montgomery u=0\n        u == 0\n    } else {\n        // General case: u = (1+y)/(1-y)\n        let numerator = math_field_add(1, y);\n        u == math_field_mul(numerator, math_field_inv(denominator))\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":213,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Check if a MontgomeryPoint corresponds to an EdwardsPoint\nvia the birational map u = (1+y)/(1-y)\nSpecial case: Edwards identity (y=1) maps to u=0","math_interpretation":"u = (1+y)/(1-y), birational map","informal_interpretation":"Relates a Montgomery u-coordinate representation to an Edwards point under the standard birational map.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L213","category":"spec","referenced_specs":["edwards_point_as_affine","math_field_add","math_field_inv","math_field_mul","math_field_sub","spec_montgomery"]},{"id":"specs__montgomery_specs__montgomery_neg","name":"montgomery_neg","signature":"pub open spec fn montgomery_neg(P: MontgomeryAffine) -> MontgomeryAffine","body":"pub open spec fn montgomery_neg(P: MontgomeryAffine) -> MontgomeryAffine {\n    match P {\n        MontgomeryAffine::Infinity => MontgomeryAffine::Infinity,\n        MontgomeryAffine::Finite { u, v } => { MontgomeryAffine::Finite { u, v: math_field_neg(v) }\n        },\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":126,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Negation on the Montgomery curve.\nFor the Montgomery curve v² = u³ + A·u² + u, the negation of a point is:\n- Infinity → Infinity (the identity element is its own inverse)\n- (u, v) → (u, -v) (negate the v-coordinate)","math_interpretation":"","informal_interpretation":"Negation on the Montgomery curve.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L126","category":"spec","referenced_specs":["math_field_neg"]},{"id":"specs__montgomery_specs__montgomery_rhs","name":"montgomery_rhs","signature":"pub open spec fn montgomery_rhs(u: nat) -> nat","body":"pub open spec fn montgomery_rhs(u: nat) -> nat {\n    let A = spec_field_element(&MONTGOMERY_A);\n    let u2 = math_field_mul(u, u);  // u^2\n    let u3 = math_field_mul(u2, u);  // u^3\n    let Au2 = math_field_mul(A, u2);  // A*u^2\n    math_field_add(math_field_add(u3, Au2), u)  // u^3 + A*u^2 + u\n\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":71,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Compute f(u) = u^3 + A*u^2 + u over the field.","math_interpretation":"Compute f(u) = u^3 + A*u^2 + u over the field.","informal_interpretation":"Compute f(u) = u^3 + A*u^2 + u over the field.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L71","category":"spec","referenced_specs":["math_field_add","math_field_mul","spec_field_element"]},{"id":"specs__montgomery_specs__montgomery_scalar_mul","name":"montgomery_scalar_mul","signature":"pub open spec fn montgomery_scalar_mul(P: MontgomeryAffine, n: nat) -> MontgomeryAffine decreases n,","body":"pub open spec fn montgomery_scalar_mul(P: MontgomeryAffine, n: nat) -> MontgomeryAffine\n    decreases n,\n{\n    if n == 0 {\n        MontgomeryAffine::Infinity\n    } else {\n        montgomery_add(P, montgomery_scalar_mul(P, (n - 1) as nat))\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":367,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Scalar multiplication on Montgomery curve (abstract specification)\nComputes [n]P where n is a scalar and P is a Montgomery point","math_interpretation":"","informal_interpretation":"Scalar multiplication on Montgomery curve (abstract specification)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L367","category":"spec","referenced_specs":["montgomery_add"]},{"id":"specs__montgomery_specs__montgomery_scalar_mul_u","name":"montgomery_scalar_mul_u","signature":"pub open spec fn montgomery_scalar_mul_u(u: nat, n: nat) -> nat","body":"pub open spec fn montgomery_scalar_mul_u(u: nat, n: nat) -> nat {\n    // Compute full scalar mul and extract u-coordinate\n    montgomery_affine_u(\n        montgomery_scalar_mul(\n            MontgomeryAffine::Finite { u, v: canonical_sqrt(montgomery_rhs(u)) },\n            n,\n        ),\n    )\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":406,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Scalar multiplication on Montgomery curve, returning only u-coordinate\nThis is what X25519 computes: [n]P returning just the u-coordinate","math_interpretation":"","informal_interpretation":"Scalar multiplication on Montgomery curve, returning only u-coordinate","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L406","category":"spec","referenced_specs":["canonical_sqrt","montgomery_affine_u","montgomery_rhs","montgomery_scalar_mul"]},{"id":"specs__montgomery_specs__montgomery_sub","name":"montgomery_sub","signature":"pub open spec fn montgomery_sub(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine","body":"pub open spec fn montgomery_sub(P: MontgomeryAffine, Q: MontgomeryAffine) -> MontgomeryAffine {\n    montgomery_add(P, montgomery_neg(Q))\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":191,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Subtraction on the Montgomery curve, defined as P - Q = P + (-Q).","math_interpretation":"Subtraction on the Montgomery curve, defined as P - Q = P + (-Q).","informal_interpretation":"Subtraction on the Montgomery curve, defined as P - Q = P + (-Q).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L191","category":"spec","referenced_specs":["montgomery_add","montgomery_neg"]},{"id":"specs__montgomery_specs__projective_represents_montgomery","name":"projective_represents_montgomery","signature":"pub open spec fn projective_represents_montgomery( P_proj: ProjectivePoint, P_aff: MontgomeryAffine, ) -> bool","body":"pub open spec fn projective_represents_montgomery(\n    P_proj: ProjectivePoint,\n    P_aff: MontgomeryAffine,\n) -> bool {\n    match P_aff {\n        MontgomeryAffine::Infinity =>\n        // The ladder never uses or produces ∞, so it should never be represented.\n        false,\n        MontgomeryAffine::Finite { u, v } => {\n            // W must not be zero for a meaningful U/W value\n            let W = spec_field_element(&P_proj.W);\n            let U = spec_field_element(&P_proj.U);\n\n            W != 0 &&\n            // Encoding requirement: U/W = u\n            // Use cross-multiplication to avoid division.\n            U == math_field_mul(u, W)\n        },\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":305,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Check if a Montgomery ProjectivePoint (U:W) represents a MontgomeryAffine point (u,v) for some v.\n\nA ProjectivePoint stores only the u-coordinate in projective form: u = U/W.\n\nReturns true if:\n- The affine point is finite (not infinity)\n- W ≠ 0 (valid projective representation)\n- U/W equals the affine u-coordinate","math_interpretation":"","informal_interpretation":"Check if a Montgomery ProjectivePoint (U:W) represents a MontgomeryAffine point (u,v) for some v.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L305","category":"spec","referenced_specs":["math_field_mul","spec_field_element"]},{"id":"specs__montgomery_specs__projective_represents_montgomery_or_infinity","name":"projective_represents_montgomery_or_infinity","signature":"pub open spec fn projective_represents_montgomery_or_infinity( P_proj: ProjectivePoint, P_aff: MontgomeryAffine, ) -> bool","body":"pub open spec fn projective_represents_montgomery_or_infinity(\n    P_proj: ProjectivePoint,\n    P_aff: MontgomeryAffine,\n) -> bool {\n    match P_aff {\n        MontgomeryAffine::Infinity => {\n            // Infinity is represented by W = 0 in projective coordinates.\n            // We require U ≠ 0 to exclude the degenerate (0:0), which represents no valid point.\n            spec_field_element(&P_proj.W) == 0 && spec_field_element(&P_proj.U) != 0\n        },\n        MontgomeryAffine::Finite { u, v: _ } => {\n            // Same encoding requirement as `projective_represents_montgomery`.\n            let W = spec_field_element(&P_proj.W);\n            let U = spec_field_element(&P_proj.U);\n            W != 0 && U == math_field_mul(u, W)\n        },\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":331,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Check if a Montgomery ProjectivePoint (U:W) represents a MontgomeryAffine point, including ∞.\n\nWe cannot use u-coordinates alone because both ∞ and the finite point (0,0) have u=0.\nInstead, we distinguish them structurally: ∞ requires W=0 (and U≠0), while finite points\nrequire W≠0.","math_interpretation":"","informal_interpretation":"Check if a Montgomery ProjectivePoint (U:W) represents a MontgomeryAffine point, including ∞.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L331","category":"spec","referenced_specs":["math_field_mul","projective_represents_montgomery","spec_field_element"]},{"id":"specs__montgomery_specs__projective_represents_montgomery_or_infinity_nat","name":"projective_represents_montgomery_or_infinity_nat","signature":"pub open spec fn projective_represents_montgomery_or_infinity_nat( U: nat, W: nat, P_aff: MontgomeryAffine, ) -> bool","body":"pub open spec fn projective_represents_montgomery_or_infinity_nat(\n    U: nat,\n    W: nat,\n    P_aff: MontgomeryAffine,\n) -> bool {\n    match P_aff {\n        MontgomeryAffine::Infinity => { W == 0 && U != 0 },\n        MontgomeryAffine::Finite { u, v: _ } => { W != 0 && U == math_field_mul(u, W) },\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":354,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Nat-only variant of `projective_represents_montgomery_or_infinity`.\n\nThis is convenient for stating algebraic properties of x-only algorithms without needing\nto construct concrete `FieldElement`s in specs.","math_interpretation":"","informal_interpretation":"Nat-only variant of `projective_represents_montgomery_or_infinity`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L354","category":"spec","referenced_specs":["math_field_mul"]},{"id":"specs__montgomery_specs__spec_elligator_encode","name":"spec_elligator_encode","signature":"pub open spec fn spec_elligator_encode(r: nat) -> nat","body":"pub open spec fn spec_elligator_encode(r: nat) -> nat {\n    let A = spec_field_element(&MONTGOMERY_A);\n    let r_sq = math_field_square(r);\n    let two_r_sq = math_field_mul(2, r_sq);\n    let d_denom = math_field_add(1, two_r_sq);  // 1 + 2r²\n\n    // d = -A / (1 + 2r²)\n    let d = math_field_mul(math_field_neg(A), math_field_inv(d_denom));\n\n    // eps = d³ + A*d² + d = d * (d² + A*d + 1)\n    let d_sq = math_field_square(d);\n    let A_d = math_field_mul(A, d);\n    let inner = math_field_add(math_field_add(d_sq, A_d), 1);\n    let eps = math_field_mul(d, inner);\n\n    // Choose u based on whether eps is a quadratic residue\n    let eps_is_square = math_is_square(eps);\n\n    if eps_is_square {\n        // eps is square → point is on curve → result u = d\n        d\n    } else {\n        // eps is not square → point is on twist → result u = -d - A\n        math_field_neg(math_field_add(d, A))\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":452,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Elligator2 mapping from a field element to a Montgomery u-coordinate.\n\nGiven input r, computes:\nd = -A / (1 + 2*r²)\neps = d³ + A*d² + d = d * (d² + A*d + 1)\nif eps is square: u = d       (point lands on the curve)\nif eps is not square: u = -d - A  (point lands on the quadratic twist)\n\n## Quadratic Twist\n\nFor a Montgomery curve v² = u³ + Au² + u, not every u-coordinate has a\ncorresponding v (i.e., u³ + Au² + u may not be a square). The \"quadratic\ntwist\" is a related curve containing exactly those points whose u-coordinates\nare invalid on the original curve.\n\n- If eps = u³ + Au² + u is a **quadratic residue** (square) → u is on the **curve**\n- If eps is a **non-residue** (not a square) → u is on the **twist**\n\n## Twist Security\n\nCurve25519 is specifically designed to be \"twist-secure\". The twist has group\norder 4 * p' where p' is a large prime, similar to the main curve's order 8 * q.\nThis means:\n- The Montgomery ladder (used in X25519) produces correct results regardless\nof whether the input u-coordinate is on the curve or the twist\n- An attacker cannot learn secret key bits by sending a malicious u-coordinate\nthat corresponds to a point on the twist (a \"small subgroup attack\")\n\nThe output u is always a valid u-coordinate on either the Montgomery curve\nor its quadratic twist. This provides a deterministic mapping from field\nelements to curve points.","math_interpretation":"d = -A / (1 + 2*r²)","informal_interpretation":"Elligator2 mapping from a field element to a Montgomery u-coordinate.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L452","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_neg","math_field_square","math_is_square","spec_field_element"]},{"id":"specs__montgomery_specs__spec_montgomery","name":"spec_montgomery","signature":"pub open spec fn spec_montgomery(point: crate::montgomery::MontgomeryPoint) -> nat","body":"pub open spec fn spec_montgomery(point: crate::montgomery::MontgomeryPoint) -> nat {\n    spec_field_element_from_bytes(&point.0)\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":206,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Returns the u-coordinate of a Montgomery point as a field element\nMontgomery points only store the u-coordinate; sign information is lost","math_interpretation":"MontgomeryPoint -> u in F_p","informal_interpretation":"Interprets a `MontgomeryPoint` as a field element u-coordinate (spec-level).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L206","category":"spec","referenced_specs":["spec_field_element_from_bytes"]},{"id":"specs__montgomery_specs__spec_projective_u_coordinate","name":"spec_projective_u_coordinate","signature":"pub open spec fn spec_projective_u_coordinate(P: ProjectivePoint) -> nat","body":"pub open spec fn spec_projective_u_coordinate(P: ProjectivePoint) -> nat {\n    let U = spec_field_element(&P.U);\n    let W = spec_field_element(&P.W);\n    if W == 0 {\n        0\n    } else {\n        math_field_mul(U, math_field_inv(W))\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":287,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Extract the u-coordinate from a ProjectivePoint (U:W) as u = U/W.\nReturns 0 if W = 0 (which represents the point at infinity).","math_interpretation":"Extract the u-coordinate from a ProjectivePoint (U:W) as u = U/W.","informal_interpretation":"Extract the u-coordinate from a ProjectivePoint (U:W) as u = U/W.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L287","category":"spec","referenced_specs":["math_field_inv","math_field_mul","spec_field_element"]},{"id":"specs__montgomery_specs__spec_u_coordinate","name":"spec_u_coordinate","signature":"pub open spec fn spec_u_coordinate(point: MontgomeryAffine) -> nat","body":"pub open spec fn spec_u_coordinate(point: MontgomeryAffine) -> nat {\n    match point {\n        MontgomeryAffine::Infinity => 0,\n        MontgomeryAffine::Finite { u, v: _ } => u,\n    }\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":197,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"Extract the u-coordinate from a MontgomeryAffine point.\nMaps Infinity to 0, and Finite{u, v} to u.","math_interpretation":"","informal_interpretation":"Extract the u-coordinate from a MontgomeryAffine point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L197","category":"spec","referenced_specs":[]},{"id":"specs__montgomery_specs__spec_x25519_basepoint_u","name":"spec_x25519_basepoint_u","signature":"pub open spec fn spec_x25519_basepoint_u() -> nat","body":"pub open spec fn spec_x25519_basepoint_u() -> nat {\n    spec_field_element_from_bytes(&X25519_BASEPOINT.0)\n}","file":"curve25519-dalek/src/specs/montgomery_specs.rs","line":392,"module":"specs::montgomery_specs","visibility":"pub open spec fn","doc_comment":"The X25519/Montgomery basepoint u-coordinate.\n\nReferences the actual constant `X25519_BASEPOINT` from `constants.rs`.\nThe u-coordinate is 9, as specified in:\n- [RFC 7748] Section 4.1: \"The u-coordinate of the base point is u = 9\"\n- https://www.rfc-editor.org/rfc/rfc7748#section-4.1\n\nThe Montgomery basepoint corresponds to the Ed25519 basepoint under\nthe birational map between twisted Edwards and Montgomery forms.\n\nNote: X25519 uses X-only (u-coordinate only) arithmetic, so the full\naffine point (u, v) is not needed - we only work with u-coordinates.","math_interpretation":"- [RFC 7748] Section 4.1: \"The u-coordinate of the base point is u = 9\"","informal_interpretation":"The X25519/Montgomery basepoint u-coordinate.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/montgomery_specs.rs#L392","category":"spec","referenced_specs":["spec_field_element_from_bytes"]},{"id":"specs__primality_specs__is_prime","name":"is_prime","signature":"pub open spec fn is_prime(n: nat) -> bool","body":"pub open spec fn is_prime(n: nat) -> bool {\n    n > 1 && forall|d: nat| 1 < d < n ==> #[trigger] (n % d) != 0\n}","file":"curve25519-dalek/src/specs/primality_specs.rs","line":12,"module":"specs::primality_specs","visibility":"pub open spec fn","doc_comment":"Specification: A natural number n is prime if it is greater than 1\nand has no divisors other than 1 and itself.\n\nFormally: n is prime ⟺ n > 1 ∧ ∀d. (1 < d < n ⟹ n % d ≠ 0)","math_interpretation":"","informal_interpretation":"Specification: A natural number n is prime if it is greater than 1","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/primality_specs.rs#L12","category":"spec","referenced_specs":[]},{"id":"specs__proba_specs__is_independent_uniform_bytes32","name":"is_independent_uniform_bytes32","signature":"pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool; /// Independence predicate for two field elements. /// /// This is intended to be used together with `is_uniform_field_element(..)` to /// model two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool;\n\n/// Independence predicate for two field elements.\n///\n/// This is intended to be used together with `is_uniform_field_element(..)` to\n/// model two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":83,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Independence predicate for two 32-byte strings.\n\nThis is intended to be used together with `is_uniform_bytes(..)` to model\ntwo *independent uniform* samples when needed.","math_interpretation":"","informal_interpretation":"Independence predicate for two 32-byte strings.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L83","category":"spec","referenced_specs":["is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","is_uniform_bytes","is_uniform_field_element","is_uniform_over_elligator_image","is_uniform_ristretto_point"]},{"id":"specs__proba_specs__is_independent_uniform_field_elements","name":"is_independent_uniform_field_elements","signature":"pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":89,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Independence predicate for two field elements.\n\nThis is intended to be used together with `is_uniform_field_element(..)` to\nmodel two *independent uniform* samples when needed.","math_interpretation":"","informal_interpretation":"Independence predicate for two field elements.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L89","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_independent_uniform_ristretto_points","is_uniform_bytes","is_uniform_over_elligator_image","is_uniform_ristretto_point"]},{"id":"specs__proba_specs__is_independent_uniform_ristretto_points","name":"is_independent_uniform_ristretto_points","signature":"pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":99,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Independence predicate for two Ristretto points.\n\nThis captures that two points are sampled independently. It can be used for\neither full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\nother sampling distributions (e.g. Elligator-image samples).","math_interpretation":"","informal_interpretation":"Independence predicate for two Ristretto points.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L99","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_uniform_bytes","is_uniform_over_elligator_image"]},{"id":"specs__proba_specs__is_uniform_bytes","name":"is_uniform_bytes","signature":"pub uninterp spec fn is_uniform_bytes(bytes: &[u8]) -> bool; /// Uniform distribution predicate for a field element. /// True if the field element is uniformly distributed over F_p. pub uninterp spec fn is_uniform_field_element(fe: &FieldElement) -> bool; /// Uniform distribution predicate for a scalar. /// True if the scalar is uniformly distributed over [0, l) where l is the group order. pub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool; /// Uniform distribution predicate for a Ristretto point. /// True if the point is uniformly distributed over the Ristretto group. pub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool; /// Independence predicate for two 32-byte strings. /// /// This is intended to be used together with `is_uniform_bytes(..)` to model /// two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool; /// Independence predicate for two field elements. /// /// This is intended to be used together with `is_uniform_field_element(..)` to /// model two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_uniform_bytes(bytes: &[u8]) -> bool;\n\n/// Uniform distribution predicate for a field element.\n/// True if the field element is uniformly distributed over F_p.\npub uninterp spec fn is_uniform_field_element(fe: &FieldElement) -> bool;\n\n/// Uniform distribution predicate for a scalar.\n/// True if the scalar is uniformly distributed over [0, l) where l is the group order.\npub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool;\n\n/// Uniform distribution predicate for a Ristretto point.\n/// True if the point is uniformly distributed over the Ristretto group.\npub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool;\n\n/// Independence predicate for two 32-byte strings.\n///\n/// This is intended to be used together with `is_uniform_bytes(..)` to model\n/// two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool;\n\n/// Independence predicate for two field elements.\n///\n/// This is intended to be used together with `is_uniform_field_element(..)` to\n/// model two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":65,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Uniform distribution predicate for a byte slice.\nTrue if the bytes are uniformly distributed over their domain.","math_interpretation":"","informal_interpretation":"Uniform distribution predicate for a byte slice.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L65","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","is_uniform_field_element","is_uniform_over_elligator_image","is_uniform_ristretto_point","is_uniform_scalar"]},{"id":"specs__proba_specs__is_uniform_field_element","name":"is_uniform_field_element","signature":"pub uninterp spec fn is_uniform_field_element(fe: &FieldElement) -> bool; /// Uniform distribution predicate for a scalar. /// True if the scalar is uniformly distributed over [0, l) where l is the group order. pub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool; /// Uniform distribution predicate for a Ristretto point. /// True if the point is uniformly distributed over the Ristretto group. pub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool; /// Independence predicate for two 32-byte strings. /// /// This is intended to be used together with `is_uniform_bytes(..)` to model /// two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool; /// Independence predicate for two field elements. /// /// This is intended to be used together with `is_uniform_field_element(..)` to /// model two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_uniform_field_element(fe: &FieldElement) -> bool;\n\n/// Uniform distribution predicate for a scalar.\n/// True if the scalar is uniformly distributed over [0, l) where l is the group order.\npub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool;\n\n/// Uniform distribution predicate for a Ristretto point.\n/// True if the point is uniformly distributed over the Ristretto group.\npub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool;\n\n/// Independence predicate for two 32-byte strings.\n///\n/// This is intended to be used together with `is_uniform_bytes(..)` to model\n/// two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool;\n\n/// Independence predicate for two field elements.\n///\n/// This is intended to be used together with `is_uniform_field_element(..)` to\n/// model two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":69,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Uniform distribution predicate for a field element.\nTrue if the field element is uniformly distributed over F_p.","math_interpretation":"","informal_interpretation":"Uniform distribution predicate for a field element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L69","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","is_uniform_bytes","is_uniform_over_elligator_image","is_uniform_ristretto_point","is_uniform_scalar"]},{"id":"specs__proba_specs__is_uniform_over_elligator_image","name":"is_uniform_over_elligator_image","signature":"pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":109,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Uniform distribution over the Elligator image (roughly half the Ristretto group).\n\nA single Elligator call does NOT produce a uniform point over the full group.\nIt only reaches points with a certain Jacobi symbol - approximately half the group.\nThis predicate captures uniformity over that restricted image.","math_interpretation":"","informal_interpretation":"Uniform distribution over the Elligator image (roughly half the Ristretto group).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L109","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_uniform_bytes"]},{"id":"specs__proba_specs__is_uniform_ristretto_point","name":"is_uniform_ristretto_point","signature":"pub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool; /// Independence predicate for two 32-byte strings. /// /// This is intended to be used together with `is_uniform_bytes(..)` to model /// two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool; /// Independence predicate for two field elements. /// /// This is intended to be used together with `is_uniform_field_element(..)` to /// model two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool;\n\n/// Independence predicate for two 32-byte strings.\n///\n/// This is intended to be used together with `is_uniform_bytes(..)` to model\n/// two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool;\n\n/// Independence predicate for two field elements.\n///\n/// This is intended to be used together with `is_uniform_field_element(..)` to\n/// model two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":77,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Uniform distribution predicate for a Ristretto point.\nTrue if the point is uniformly distributed over the Ristretto group.","math_interpretation":"","informal_interpretation":"Uniform distribution predicate for a Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L77","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","is_uniform_bytes","is_uniform_field_element","is_uniform_over_elligator_image"]},{"id":"specs__proba_specs__is_uniform_scalar","name":"is_uniform_scalar","signature":"pub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool; /// Uniform distribution predicate for a Ristretto point. /// True if the point is uniformly distributed over the Ristretto group. pub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool; /// Independence predicate for two 32-byte strings. /// /// This is intended to be used together with `is_uniform_bytes(..)` to model /// two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool; /// Independence predicate for two field elements. /// /// This is intended to be used together with `is_uniform_field_element(..)` to /// model two *independent uniform* samples when needed. pub uninterp spec fn is_independent_uniform_field_elements( fe1: &FieldElement, fe2: &FieldElement, ) -> bool; /// Independence predicate for two Ristretto points. /// /// This captures that two points are sampled independently. It can be used for /// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for /// other sampling distributions (e.g. Elligator-image samples). pub uninterp spec fn is_independent_uniform_ristretto_points( p1: &RistrettoPoint, p2: &RistrettoPoint, ) -> bool; /// Uniform distribution over the Elligator image (roughly half the Ristretto group). /// /// A single Elligator call does NOT produce a uniform point over the full group. /// It only reaches points with a certain Jacobi symbol - approximately half the group. /// This predicate captures uniformity over that restricted image. pub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool; // ============================================================================= // Axiom 1: Splitting uniform bytes preserves uniformity // ============================================================================= /// Axiom: Splitting uniform bytes preserves uniformity on each half. /// /// Mathematical justification: /// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits /// are each uniform over [0, 2^256) (they are independent uniform samples). pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32]) requires first@ == bytes@.subrange(0, 32), second@ == bytes@.subrange(32, 64), is_uniform_bytes(bytes), ensures is_uniform_bytes(first), is_uniform_bytes(second), is_independent_uniform_bytes32(first, second),","body":"pub uninterp spec fn is_uniform_scalar(scalar: &Scalar) -> bool;\n\n/// Uniform distribution predicate for a Ristretto point.\n/// True if the point is uniformly distributed over the Ristretto group.\npub uninterp spec fn is_uniform_ristretto_point(point: &RistrettoPoint) -> bool;\n\n/// Independence predicate for two 32-byte strings.\n///\n/// This is intended to be used together with `is_uniform_bytes(..)` to model\n/// two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_bytes32(first: &[u8; 32], second: &[u8; 32]) -> bool;\n\n/// Independence predicate for two field elements.\n///\n/// This is intended to be used together with `is_uniform_field_element(..)` to\n/// model two *independent uniform* samples when needed.\npub uninterp spec fn is_independent_uniform_field_elements(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n) -> bool;\n\n/// Independence predicate for two Ristretto points.\n///\n/// This captures that two points are sampled independently. It can be used for\n/// either full-group-uniform samples (`is_uniform_ristretto_point(..)`) or for\n/// other sampling distributions (e.g. Elligator-image samples).\npub uninterp spec fn is_independent_uniform_ristretto_points(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n) -> bool;\n\n/// Uniform distribution over the Elligator image (roughly half the Ristretto group).\n///\n/// A single Elligator call does NOT produce a uniform point over the full group.\n/// It only reaches points with a certain Jacobi symbol - approximately half the group.\n/// This predicate captures uniformity over that restricted image.\npub uninterp spec fn is_uniform_over_elligator_image(point: &RistrettoPoint) -> bool;\n\n// =============================================================================\n// Axiom 1: Splitting uniform bytes preserves uniformity\n// =============================================================================\n/// Axiom: Splitting uniform bytes preserves uniformity on each half.\n///\n/// Mathematical justification:\n/// If X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\n/// are each uniform over [0, 2^256) (they are independent uniform samples).\npub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),\n{\n    admit();\n}","file":"curve25519-dalek/src/specs/proba_specs.rs","line":73,"module":"specs::proba_specs","visibility":"pub uninterp spec fn","doc_comment":"Uniform distribution predicate for a scalar.\nTrue if the scalar is uniformly distributed over [0, l) where l is the group order.","math_interpretation":"","informal_interpretation":"Uniform distribution predicate for a scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L73","category":"spec","referenced_specs":["is_independent_uniform_bytes32","is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","is_uniform_bytes","is_uniform_field_element","is_uniform_over_elligator_image","is_uniform_ristretto_point"]},{"id":"specs__ristretto_specs__is_in_even_subgroup","name":"is_in_even_subgroup","signature":"pub open spec fn is_in_even_subgroup(point: EdwardsPoint) -> bool","body":"pub open spec fn is_in_even_subgroup(point: EdwardsPoint) -> bool {\n    exists|q: EdwardsPoint|\n        edwards_point_as_affine(point) == edwards_scalar_mul(\n            #[trigger] edwards_point_as_affine(q),\n            2,\n        )\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":346,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Point is in the even subgroup 2E = {2Q : Q ∈ E}; valid Ristretto points must lie in 2E.","math_interpretation":"P in 2E = {2Q : Q in E(F_p)}","informal_interpretation":"Predicate that an Edwards point lies in the even (torsion-free) subgroup used by Ristretto decoding.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L346","category":"spec","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul"]},{"id":"specs__ristretto_specs__is_ristretto_coset","name":"is_ristretto_coset","signature":"pub open spec fn is_ristretto_coset(points: [EdwardsPoint; 4], base: EdwardsPoint) -> bool","body":"pub open spec fn is_ristretto_coset(points: [EdwardsPoint; 4], base: EdwardsPoint) -> bool {\n    let base_affine = edwards_point_as_affine(base);\n    let t2 = edwards_point_as_affine(EIGHT_TORSION[2]);\n    let t4 = edwards_point_as_affine(EIGHT_TORSION[4]);\n    let t6 = edwards_point_as_affine(EIGHT_TORSION[6]);\n\n    // points[0] = base (T[0] is identity)\n    edwards_point_as_affine(points[0])\n        == base_affine\n    // points[1] = base + T[2]\n     && edwards_point_as_affine(points[1]) == edwards_add(\n        base_affine.0,\n        base_affine.1,\n        t2.0,\n        t2.1,\n    )\n    // points[2] = base + T[4]\n     && edwards_point_as_affine(points[2]) == edwards_add(\n        base_affine.0,\n        base_affine.1,\n        t4.0,\n        t4.1,\n    )\n    // points[3] = base + T[6]\n     && edwards_point_as_affine(points[3]) == edwards_add(base_affine.0, base_affine.1, t6.0, t6.1)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":358,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Check if 4 Edwards points form a coset of the 4-torsion subgroup E[4].\n\nA coset P + E[4] = {P, P + T[2], P + T[4], P + T[6]} represents a single\nRistretto equivalence class - all 4 points map to the same Ristretto point.","math_interpretation":"A coset P + E[4] = {P, P + T[2], P + T[4], P + T[6]} represents a single","informal_interpretation":"Check if 4 Edwards points form a coset of the 4-torsion subgroup E[4].","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L358","category":"spec","referenced_specs":["edwards_add","edwards_point_as_affine"]},{"id":"specs__ristretto_specs__ristretto_equivalent","name":"ristretto_equivalent","signature":"pub open spec fn ristretto_equivalent(p1: EdwardsPoint, p2: EdwardsPoint) -> bool recommends is_well_formed_edwards_point(p1), is_well_formed_edwards_point(p2),","body":"pub open spec fn ristretto_equivalent(p1: EdwardsPoint, p2: EdwardsPoint) -> bool\n    recommends\n        is_well_formed_edwards_point(p1),\n        is_well_formed_edwards_point(p2),\n{\n    let p1_affine = edwards_point_as_affine(p1);\n    let p2_affine = edwards_point_as_affine(p2);\n    let diff = edwards_sub(p1_affine.0, p1_affine.1, p2_affine.0, p2_affine.1);\n\n    // The difference must be a 4-torsion element (one of T[0], T[2], T[4], T[6])\n    let t0 = edwards_point_as_affine(EIGHT_TORSION[0]);\n    let t2 = edwards_point_as_affine(EIGHT_TORSION[2]);\n    let t4 = edwards_point_as_affine(EIGHT_TORSION[4]);\n    let t6 = edwards_point_as_affine(EIGHT_TORSION[6]);\n\n    diff == t0 || diff == t2 || diff == t4 || diff == t6\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":386,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Two Edwards points are Ristretto-equivalent if they differ by a 4-torsion element.","math_interpretation":"","informal_interpretation":"Two Edwards points are Ristretto-equivalent if they differ by a 4-torsion element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L386","category":"spec","referenced_specs":["edwards_point_as_affine","edwards_sub","is_well_formed_edwards_point"]},{"id":"specs__ristretto_specs__spec_elligator_ristretto_flavor","name":"spec_elligator_ristretto_flavor","signature":"pub open spec fn spec_elligator_ristretto_flavor(r_0: nat) -> (nat, nat)","body":"pub open spec fn spec_elligator_ristretto_flavor(r_0: nat) -> (nat, nat) {\n    let i = spec_sqrt_m1();\n    let d = spec_field_element(&EDWARDS_D);\n    let one_minus_d_sq = math_field_mul(math_field_sub(1, d), math_field_add(1, d));  // (1-d)(1+d) = 1 - d²\n    let d_minus_one_sq = math_field_square(math_field_sub(d, 1));  // (d-1)²\n    let c_init: nat = math_field_neg(1);  // -1\n\n    let r = math_field_mul(i, math_field_square(r_0));\n    let n_s = math_field_mul(math_field_add(r, 1), one_minus_d_sq);\n    let d_val = math_field_mul(math_field_sub(c_init, math_field_mul(d, r)), math_field_add(r, d));\n\n    // sqrt_ratio_i(N_s, D) returns (was_square, s)\n    // invsqrt = 1/sqrt(N_s * D), so s = invsqrt * N_s = sqrt(N_s/D)\n    let invsqrt = math_invsqrt(math_field_mul(n_s, d_val));\n    let s_if_square = math_field_mul(invsqrt, n_s);\n    // was_square checks if s² · D = N_s (i.e., N_s/D is a square)\n    let was_square = math_is_sqrt_ratio(n_s, d_val, s_if_square);\n\n    // s' = s * r_0, then conditionally negate to make it negative\n    let s_prime_raw = math_field_mul(s_if_square, r_0);\n    let s_prime = if !math_is_negative(s_prime_raw) {\n        math_field_neg(s_prime_raw)\n    } else {\n        s_prime_raw\n    };\n\n    // If !was_square: s = s', c = r\n    let s = if was_square {\n        s_if_square\n    } else {\n        s_prime\n    };\n    let c = if was_square {\n        c_init\n    } else {\n        r\n    };\n\n    // N_t = c * (r - 1) * (d - 1)² - D\n    let n_t = math_field_sub(\n        math_field_mul(math_field_mul(c, math_field_sub(r, 1)), d_minus_one_sq),\n        d_val,\n    );\n    let s_sq = math_field_square(s);\n\n    // Final point in completed coordinates, then converted to affine:\n    // X = 2*s*D, Z = N_t * sqrt(a*d - 1), Y = 1 - s², T = 1 + s²\n    // Affine: x = X*T / (Z*T) = X/Z, y = Y*Z / (Z*T) = Y/T\n    let sqrt_ad_minus_one = spec_sqrt_ad_minus_one();\n    let x_completed = math_field_mul(math_field_mul(2, s), d_val);\n    let z_completed = math_field_mul(n_t, sqrt_ad_minus_one);\n    let y_completed = math_field_sub(1, s_sq);\n    let t_completed = math_field_add(1, s_sq);\n\n    // Convert completed point ((X:Z), (Y:T)) to affine (X/Z, Y/T)\n    let x_affine = math_field_mul(x_completed, math_field_inv(z_completed));\n    let y_affine = math_field_mul(y_completed, math_field_inv(t_completed));\n\n    (x_affine, y_affine)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":238,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of the Ristretto Elligator map (MAP function).\n\nThis maps a field element r_0 to a Ristretto point deterministically.\nReference: [RISTRETTO], §4.3.4 \"MAP\" function;\nhttps://ristretto.group/formulas/elligator.html\n\nThe algorithm:\n1. r = i * r_0²  (where i = sqrt(-1))\n2. N_s = (r + 1) * (1 - d²)\n3. D = (c - d*r) * (r + d) where c = -1 initially\n4. (was_square, s) = sqrt_ratio_i(N_s, D)\n5. Conditionally adjust s and c based on was_square\n6. Compute final point coordinates\n\nReturns the affine (x, y) coordinates of the resulting Ristretto point.","math_interpretation":"1. r = i * r_0²  (where i = sqrt(-1))","informal_interpretation":"Spec-only model of the Ristretto Elligator map (MAP function).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L238","category":"spec","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_neg","math_field_square","math_field_sub","math_invsqrt","math_is_negative","math_is_sqrt_ratio","spec_field_element","spec_sqrt_ad_minus_one","spec_sqrt_m1"]},{"id":"specs__ristretto_specs__spec_ristretto_basepoint","name":"spec_ristretto_basepoint","signature":"pub open spec fn spec_ristretto_basepoint() -> (nat, nat)","body":"pub open spec fn spec_ristretto_basepoint() -> (nat, nat) {\n    spec_ed25519_basepoint()\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":194,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"The canonical representative of the Ristretto basepoint.\n\nThe Ristretto basepoint is the equivalence class [B] where B is the\nEd25519 basepoint. We use B itself as the canonical representative.","math_interpretation":"[B] (Ristretto basepoint = Ed25519 B)","informal_interpretation":"Returns the Ristretto basepoint (spec-level).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L194","category":"spec","referenced_specs":["spec_ed25519_basepoint"]},{"id":"specs__ristretto_specs__spec_ristretto_compress","name":"spec_ristretto_compress","signature":"pub open spec fn spec_ristretto_compress(point: RistrettoPoint) -> [u8; 32]","body":"pub open spec fn spec_ristretto_compress(point: RistrettoPoint) -> [u8; 32] {\n    let (x, y, z, t) = spec_edwards_point(point.0);\n    spec_ristretto_compress_extended(x, y, z, t)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":113,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of Ristretto compression from a RistrettoPoint.\n\nThis captures the canonical encoding of a Ristretto point.\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\"","math_interpretation":"E/~ -> [u8;32], Ristretto encoding","informal_interpretation":"Spec-level function computing the canonical compressed encoding of a Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L113","category":"spec","referenced_specs":["spec_edwards_point","spec_ristretto_compress_extended"]},{"id":"specs__ristretto_specs__spec_ristretto_compress_affine","name":"spec_ristretto_compress_affine","signature":"pub open spec fn spec_ristretto_compress_affine(x: nat, y: nat) -> [u8; 32]","body":"pub open spec fn spec_ristretto_compress_affine(x: nat, y: nat) -> [u8; 32] {\n    spec_ristretto_compress_extended(x, y, 1, math_field_mul(x, y))\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":124,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of Ristretto compression from affine coordinates.\n\nFor affine coords (x, y), we use z = 1 and t = x * y\n(since T = XY/Z = xy/1 = xy in extended coords).\n\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\"","math_interpretation":"(since T = XY/Z = xy/1 = xy in extended coords).","informal_interpretation":"Spec-only model of Ristretto compression from affine coordinates.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L124","category":"spec","referenced_specs":["math_field_mul","spec_ristretto_compress_extended"]},{"id":"specs__ristretto_specs__spec_ristretto_compress_extended","name":"spec_ristretto_compress_extended","signature":"pub open spec fn spec_ristretto_compress_extended(x: nat, y: nat, z: nat, t: nat) -> [u8; 32]","body":"pub open spec fn spec_ristretto_compress_extended(x: nat, y: nat, z: nat, t: nat) -> [u8; 32] {\n    let u1 = math_field_mul(math_field_add(z, y), math_field_sub(z, y));\n    let u2 = math_field_mul(x, y);\n    let invsqrt = math_invsqrt(math_field_mul(u1, math_field_square(u2)));\n    let i1 = math_field_mul(invsqrt, u1);\n    let i2 = math_field_mul(invsqrt, u2);\n    let z_inv = math_field_mul(i1, math_field_mul(i2, t));\n    let den_inv = i2;\n\n    let iX = math_field_mul(x, spec_sqrt_m1());\n    let iY = math_field_mul(y, spec_sqrt_m1());\n    let enchanted_denominator = math_field_mul(\n        i1,\n        spec_field_element(&u64_constants::INVSQRT_A_MINUS_D),\n    );\n\n    let rotate = math_is_negative(math_field_mul(t, z_inv));\n    let x_rot = if rotate {\n        iY\n    } else {\n        x\n    };\n    let y_rot = if rotate {\n        iX\n    } else {\n        y\n    };\n    let den_inv_rot = if rotate {\n        enchanted_denominator\n    } else {\n        den_inv\n    };\n\n    let y_final = if math_is_negative(math_field_mul(x_rot, z_inv)) {\n        math_field_neg(y_rot)\n    } else {\n        y_rot\n    };\n    let s = math_field_mul(den_inv_rot, math_field_sub(z, y_final));\n    let s_final = if math_is_negative(s) {\n        math_field_neg(s)\n    } else {\n        s\n    };\n\n    spec_bytes32_from_nat(s_final)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":61,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Core Ristretto compression from extended coordinates (X, Y, Z, T).\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\";\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html.","math_interpretation":"(X,Y,Z,T) -> [u8;32], core encoding","informal_interpretation":"Core Ristretto compression from extended coordinates (X, Y, Z, T).\\nReference: [RISTRETTO], §5.3 \"Ristretto255 Encoding\";\\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L61","category":"spec","referenced_specs":["math_field_add","math_field_mul","math_field_neg","math_field_square","math_field_sub","math_invsqrt","math_is_negative","spec_bytes32_from_nat","spec_field_element","spec_sqrt_m1"]},{"id":"specs__ristretto_specs__spec_ristretto_decompress","name":"spec_ristretto_decompress","signature":"pub open spec fn spec_ristretto_decompress(bytes: [u8; 32]) -> Option<RistrettoPoint>","body":"pub open spec fn spec_ristretto_decompress(bytes: [u8; 32]) -> Option<RistrettoPoint> {\n    let s_bytes_nat = bytes32_to_nat(&bytes);\n    let s = spec_field_element_from_bytes(&bytes);\n    let s_encoding_is_canonical = s_bytes_nat < p();\n    let s_is_negative = math_is_negative(s);\n\n    if !s_encoding_is_canonical || s_is_negative {\n        None\n    } else {\n        let ss = math_field_square(s);\n        let u1 = math_field_sub(1, ss);\n        let u2 = math_field_add(1, ss);\n        let u2_sqr = math_field_square(u2);\n        let neg_d = math_field_neg(spec_field_element(&EDWARDS_D));\n        let u1_sqr = math_field_square(u1);\n        let v = math_field_sub(math_field_mul(neg_d, u1_sqr), u2_sqr);\n\n        let invsqrt_input = math_field_mul(v, u2_sqr);\n        let invsqrt = math_invsqrt(invsqrt_input);\n        let ok = math_is_sqrt_ratio(1, invsqrt_input, invsqrt);\n\n        let dx = math_field_mul(invsqrt, u2);\n        let dy = math_field_mul(invsqrt, math_field_mul(dx, v));\n        let x_tmp = math_field_mul(math_field_add(s, s), dx);\n        let x = if math_is_negative(x_tmp) {\n            math_field_neg(x_tmp)\n        } else {\n            x_tmp\n        };\n        let y = math_field_mul(u1, dy);\n        let t = math_field_mul(x, y);\n\n        let t_is_negative = math_is_negative(t);\n        let y_is_zero = y == 0;\n\n        if !ok || t_is_negative || y_is_zero {\n            None\n        } else if exists|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t) {\n            Some(choose|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t))\n        } else {\n            None\n        }\n    }\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":131,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of Ristretto decompression.\nReference: [RISTRETTO], §5.2 \"Ristretto255 Decoding\";\n[DECAF], Section 6 (decoding formulas), and https://ristretto.group/formulas/decoding.html.","math_interpretation":"[u8;32] -> Option<E/~>, Ristretto decoding","informal_interpretation":"Spec-level function decoding a compressed Ristretto encoding to an optional point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L131","category":"spec","referenced_specs":["bytes32_to_nat","math_field_add","math_field_mul","math_field_neg","math_field_square","math_field_sub","math_invsqrt","math_is_negative","math_is_sqrt_ratio","p","spec_edwards_point","spec_field_element","spec_field_element_from_bytes"]},{"id":"specs__ristretto_specs__spec_ristretto_from_uniform_bytes","name":"spec_ristretto_from_uniform_bytes","signature":"pub open spec fn spec_ristretto_from_uniform_bytes(bytes: &[u8; 64]) -> (nat, nat)","body":"pub open spec fn spec_ristretto_from_uniform_bytes(bytes: &[u8; 64]) -> (nat, nat) {\n    let b1 = spec_uniform_bytes_first(bytes);\n    let b2 = spec_uniform_bytes_second(bytes);\n    let r1 = spec_field_element_from_bytes(&b1);\n    let r2 = spec_field_element_from_bytes(&b2);\n    let p1 = spec_elligator_ristretto_flavor(r1);\n    let p2 = spec_elligator_ristretto_flavor(r2);\n    edwards_add(p1.0, p1.1, p2.0, p2.1)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":324,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec-only model of RistrettoPoint::from_uniform_bytes.\n\nConstructs a Ristretto point from 64 uniform random bytes using the\n\"hash-to-group\" construction for Ristretto.\n\nReference: [RISTRETTO], §4.3.4 \"Hash-to-group\";\nhttps://ristretto.group/formulas/encoding.html\n\nAlgorithm:\n1. Split 64 bytes into two 32-byte halves: b1 = bytes[0..32], b2 = bytes[32..64]\n2. Convert each half to a field element: r1 = from_bytes(b1), r2 = from_bytes(b2)\n3. Map each field element to a Ristretto point via Elligator: p1 = MAP(r1), p2 = MAP(r2)\n4. Add the two points: result = p1 + p2\n\nReturns the affine (x, y) coordinates of the resulting Ristretto point.","math_interpretation":"4. Add the two points: result = p1 + p2","informal_interpretation":"Spec-only model of RistrettoPoint::from_uniform_bytes.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L324","category":"spec","referenced_specs":["edwards_add","spec_elligator_ristretto_flavor","spec_field_element_from_bytes","spec_uniform_bytes_first","spec_uniform_bytes_second"]},{"id":"specs__ristretto_specs__spec_sqrt_ad_minus_one","name":"spec_sqrt_ad_minus_one","signature":"pub open spec fn spec_sqrt_ad_minus_one() -> nat","body":"pub open spec fn spec_sqrt_ad_minus_one() -> nat {\n    // sqrt(-1 * d - 1) = sqrt(-d - 1)\n    // This is a constant defined in the codebase\n    spec_field_element(&u64_constants::SQRT_AD_MINUS_ONE)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":336,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec for sqrt(a*d - 1) where a = -1 for Ed25519.\nThis equals sqrt(-d - 1).","math_interpretation":"Spec for sqrt(a*d - 1) where a = -1 for Ed25519.","informal_interpretation":"Spec for sqrt(a*d - 1) where a = -1 for Ed25519.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L336","category":"spec","referenced_specs":["spec_field_element"]},{"id":"specs__ristretto_specs__spec_uniform_bytes_first","name":"spec_uniform_bytes_first","signature":"pub open spec fn spec_uniform_bytes_first(bytes: &[u8; 64]) -> [u8; 32]","body":"pub open spec fn spec_uniform_bytes_first(bytes: &[u8; 64]) -> [u8; 32] {\n    choose|b: [u8; 32]| b@ == bytes@.subrange(0, 32)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":300,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec helper: first 32 bytes of a 64-byte input.","math_interpretation":"","informal_interpretation":"Spec helper: first 32 bytes of a 64-byte input.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L300","category":"spec","referenced_specs":[]},{"id":"specs__ristretto_specs__spec_uniform_bytes_second","name":"spec_uniform_bytes_second","signature":"pub open spec fn spec_uniform_bytes_second(bytes: &[u8; 64]) -> [u8; 32]","body":"pub open spec fn spec_uniform_bytes_second(bytes: &[u8; 64]) -> [u8; 32] {\n    choose|b: [u8; 32]| b@ == bytes@.subrange(32, 64)\n}","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":305,"module":"specs::ristretto_specs","visibility":"pub open spec fn","doc_comment":"Spec helper: second 32 bytes of a 64-byte input.","math_interpretation":"","informal_interpretation":"Spec helper: second 32 bytes of a 64-byte input.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L305","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__group_order","name":"group_order","signature":"pub open spec fn group_order() -> nat","body":"pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":85,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"L = 2^252 + 27742317777372353535851937790883648493","informal_interpretation":"Returns the Curve25519/Ed25519 scalar field modulus (group order).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L85","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__is_canonical_scalar52","name":"is_canonical_scalar52","signature":"pub open spec fn is_canonical_scalar52(s: &Scalar52) -> bool","body":"pub open spec fn is_canonical_scalar52(s: &Scalar52) -> bool {\n    limbs_bounded(s) && scalar52_to_nat(s) < group_order()\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":126,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"Checks if a Scalar52 is in canonical form:\n- All limbs are properly bounded (< 2^52)\n- The value is reduced modulo group order (< L)\n\nThis is the Scalar52 equivalent of is_canonical_scalar for Scalar.","math_interpretation":"","informal_interpretation":"Checks if a Scalar52 is in canonical form:","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L126","category":"spec","referenced_specs":["group_order","limbs_bounded","scalar52_to_nat"]},{"id":"specs__scalar52_specs__limb_prod_bounded_u128","name":"limb_prod_bounded_u128","signature":"pub open spec fn limb_prod_bounded_u128(limbs1: [u64; 5], limbs2: [u64; 5], k: nat) -> bool","body":"pub open spec fn limb_prod_bounded_u128(limbs1: [u64; 5], limbs2: [u64; 5], k: nat) -> bool {\n    forall|i: int, j: int| 0 <= i < 5 && 0 <= j < 5 ==> (limbs1[i] * limbs2[j]) * k <= u128::MAX\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":117,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L117","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__limbs52_to_nat","name":"limbs52_to_nat","signature":"pub open spec fn limbs52_to_nat(limbs: &[u64]) -> nat","body":"pub open spec fn limbs52_to_nat(limbs: &[u64]) -> nat {\n    seq_to_nat_52(limbs@.map(|i, x| x as nat))\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":34,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"Convert a slice of u64 limbs to nat using 52-bit radix.\nThis is for low-level lemmas that work with raw arrays.","math_interpretation":"","informal_interpretation":"Convert a slice of u64 limbs to nat using 52-bit radix.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L34","category":"spec","referenced_specs":["seq_to_nat_52"]},{"id":"specs__scalar52_specs__limbs_bounded","name":"limbs_bounded","signature":"pub open spec fn limbs_bounded(s: &Scalar52) -> bool","body":"pub open spec fn limbs_bounded(s: &Scalar52) -> bool {\n    forall|i: int| 0 <= i < 5 ==> s.limbs[i] < (1u64 << 52)\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":101,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L101","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__limbs_bounded_for_sub","name":"limbs_bounded_for_sub","signature":"pub open spec fn limbs_bounded_for_sub(a: &Scalar52, b: &Scalar52) -> bool","body":"pub open spec fn limbs_bounded_for_sub(a: &Scalar52, b: &Scalar52) -> bool {\n    &&& forall|i: int| 0 <= i < 4 ==> a.limbs[i] < (1u64 << 52)\n    &&& a.limbs[4] < (1u64 << 52) + b.limbs[4]\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":112,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"Relaxed bound for sub's first argument: limbs 0-3 bounded, limb 4 can exceed 2^52 by up to b[4].\n\nThis is needed for montgomery_reduce where the intermediate result has r4 > 2^52.\nThe sub algorithm still works correctly because:\n- For limbs 0-3: standard bounded subtraction\n- For limb 4: a[4] - b[4] < 2^52, so masking doesn't lose bits\n","math_interpretation":"","informal_interpretation":"Relaxed bound for sub's first argument: limbs 0-3 bounded, limb 4 can exceed 2^52 by up to b[4].","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L112","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__montgomery_radix","name":"montgomery_radix","signature":"pub open spec fn montgomery_radix() -> nat","body":"pub open spec fn montgomery_radix() -> nat {\n    pow2(260)\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":90,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L90","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__scalar52_to_nat","name":"scalar52_to_nat","signature":"pub open spec fn scalar52_to_nat(s: &Scalar52) -> nat","body":"pub open spec fn scalar52_to_nat(s: &Scalar52) -> nat {\n    limbs52_to_nat(&s.limbs)\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":40,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"Convert a Scalar52 to its natural number representation.\nThis is the primary spec function for Scalar52 interpretation.","math_interpretation":"","informal_interpretation":"Convert a Scalar52 to its natural number representation.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L40","category":"spec","referenced_specs":["limbs52_to_nat"]},{"id":"specs__scalar52_specs__seq_to_nat_52","name":"seq_to_nat_52","signature":"pub open spec fn seq_to_nat_52(limbs: Seq<nat>) -> nat decreases limbs.len(),","body":"pub open spec fn seq_to_nat_52(limbs: Seq<nat>) -> nat\n    decreases limbs.len(),\n{\n    if limbs.len() == 0 {\n        0\n    } else {\n        limbs[0] + seq_to_nat_52(limbs.subrange(1, limbs.len() as int)) * pow2(52)\n    }\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":14,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"Convert a sequence of limbs to nat using 52-bit radix (Horner form).\nThis is the base recursive function for Scalar52 limb interpretation.\nComputes: limbs[0] + limbs[1]*2^52 + limbs[2]*2^104 + ...","math_interpretation":"","informal_interpretation":"Convert a sequence of limbs to nat using 52-bit radix (Horner form).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L14","category":"spec","referenced_specs":[]},{"id":"specs__scalar52_specs__slice128_to_nat","name":"slice128_to_nat","signature":"pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat","body":"pub open spec fn slice128_to_nat(limbs: &[u128]) -> nat {\n    seq_to_nat_52(limbs@.map(|i, x| x as nat))\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":24,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L24","category":"spec","referenced_specs":["seq_to_nat_52"]},{"id":"specs__scalar52_specs__spec_mul_internal","name":"spec_mul_internal","signature":"pub open spec fn spec_mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9] recommends limbs_bounded(a), limbs_bounded(b),","body":"pub open spec fn spec_mul_internal(a: &Scalar52, b: &Scalar52) -> [u128; 9]\n    recommends\n        limbs_bounded(a),\n        limbs_bounded(b),\n{\n    [\n        ((a.limbs[0] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[1] as u128) + (a.limbs[1] as u128) * (\n        b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[2] as u128) + (a.limbs[1] as u128) * (b.limbs[1] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[3] as u128) + (a.limbs[1] as u128) * (b.limbs[2] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[1] as u128) + (a.limbs[3] as u128) * (\n        b.limbs[0] as u128)) as u128,\n        ((a.limbs[0] as u128) * (b.limbs[4] as u128) + (a.limbs[1] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[2] as u128) * (b.limbs[2] as u128) + (a.limbs[3] as u128) * (\n        b.limbs[1] as u128) + (a.limbs[4] as u128) * (b.limbs[0] as u128)) as u128,\n        ((a.limbs[1] as u128) * (b.limbs[4] as u128) + (a.limbs[2] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[3] as u128) * (b.limbs[2] as u128) + (a.limbs[4] as u128) * (\n        b.limbs[1] as u128)) as u128,\n        ((a.limbs[2] as u128) * (b.limbs[4] as u128) + (a.limbs[3] as u128) * (b.limbs[3] as u128)\n            + (a.limbs[4] as u128) * (b.limbs[2] as u128)) as u128,\n        ((a.limbs[3] as u128) * (b.limbs[4] as u128) + (a.limbs[4] as u128) * (\n        b.limbs[3] as u128)) as u128,\n        ((a.limbs[4] as u128) * (b.limbs[4] as u128)) as u128,\n    ]\n}","file":"curve25519-dalek/src/specs/scalar52_specs.rs","line":130,"module":"specs::scalar52_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar52_specs.rs#L130","category":"spec","referenced_specs":["limbs_bounded"]},{"id":"specs__scalar_specs__is_canonical_scalar","name":"is_canonical_scalar","signature":"pub open spec fn is_canonical_scalar(s: &Scalar) -> bool","body":"pub open spec fn is_canonical_scalar(s: &Scalar) -> bool {\n    // Invariant #2: Scalar is reduced (< group order)\n    bytes32_to_nat(&s.bytes)\n        < group_order()\n    // Invariant #1: High bit is clear (< 2^255)\n     && s.bytes[31] <= 127\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":30,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Checks if a Scalar satisfies the canonical representation invariants:\n- Invariant #1: High bit (bit 255) is clear, ensuring s < 2^255\n- Invariant #2: Scalar is reduced modulo group order, i.e., s < ℓ","math_interpretation":"0 <= s < L and s < 2^255","informal_interpretation":"Predicate that a `Scalar` is in canonical form (reduced modulo the group order).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L30","category":"spec","referenced_specs":["bytes32_to_nat","group_order"]},{"id":"specs__scalar_specs__is_clamped_integer","name":"is_clamped_integer","signature":"pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool","body":"pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool {\n    // The 3 least significant bits are cleared (divisible by 8)\n    bytes[0] & 0b0000_0111\n        == 0\n    // Bit 255 (MSB) is cleared, making it < 2^255\n     && bytes[31] & 0b1000_0000 == 0\n    // Bit 254 is set, so result >= 2^254\n     && bytes[31] & 0b0100_0000\n        == 0b0100_0000\n    // MSB cleared implies bytes[31] <= 127 (needed for mul_req precondition)\n     && bytes[31] <= 127\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":90,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Returns true iff a byte array represents a clamped integer for X25519.\nA clamped integer has:\n- The 3 least significant bits cleared (divisible by 8)\n- Bit 255 (MSB) cleared (< 2^255), which means bytes[31] <= 127\n- Bit 254 set (>= 2^254)\nThis creates values in range: 2^254 + 8*{0, 1, 2, ..., 2^251 - 1}","math_interpretation":"bits 0-2 clear, bit 254 set, bit 255 clear","informal_interpretation":"Checks that a 32-byte array satisfies X25519 clamping (bit constraints).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L90","category":"spec","referenced_specs":["mul_req"]},{"id":"specs__scalar_specs__is_inverse","name":"is_inverse","signature":"pub open spec fn is_inverse(a: &Scalar, b: &Scalar) -> bool","body":"pub open spec fn is_inverse(a: &Scalar, b: &Scalar) -> bool {\n    (bytes32_to_nat(&a.bytes) * bytes32_to_nat(&b.bytes)) % group_order() == 1\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":40,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Returns true iff a and b are multiplicative inverses modulo group_order\ni.e., a * b ≡ 1 (mod group_order)","math_interpretation":"i.e., a * b ≡ 1 (mod group_order)","informal_interpretation":"Returns true iff a and b are multiplicative inverses modulo group_order","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L40","category":"spec","referenced_specs":["bytes32_to_nat","group_order"]},{"id":"specs__scalar_specs__is_inverse_of_nat","name":"is_inverse_of_nat","signature":"pub open spec fn is_inverse_of_nat(s: &Scalar, n: nat) -> bool","body":"pub open spec fn is_inverse_of_nat(s: &Scalar, n: nat) -> bool {\n    (bytes32_to_nat(&s.bytes) * n) % group_order() == 1\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":80,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Returns true iff a scalar is the inverse of a natural number (mod group_order)","math_interpretation":"","informal_interpretation":"Returns true iff a scalar is the inverse of a natural number (mod group_order)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L80","category":"spec","referenced_specs":["bytes32_to_nat","group_order"]},{"id":"specs__scalar_specs__is_valid_naf","name":"is_valid_naf","signature":"pub open spec fn is_valid_naf(naf: Seq<i8>, w: nat) -> bool","body":"pub open spec fn is_valid_naf(naf: Seq<i8>, w: nat) -> bool {\n    forall|i: int|\n        0 <= i < naf.len() ==> {\n            let digit = (#[trigger] naf[i]) as int;\n            // Each nonzero digit is odd and within bound\n            (digit == 0 || (digit % 2 != 0 && -pow2((w - 1) as nat) < digit && digit < pow2(\n                (w - 1) as nat,\n            ))) &&\n            // At most one nonzero in any w consecutive digits\n            forall|j: int|\n                1 <= j < w && #[trigger] (i + j) < naf.len() ==> !(digit != 0 && (naf[#[trigger] (i\n                    + j)] as int) != 0)\n        }\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":163,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Predicate describing a valid width-w Non-Adjacent Form.","math_interpretation":"","informal_interpretation":"Predicate describing a valid width-w Non-Adjacent Form.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L163","category":"spec","referenced_specs":[]},{"id":"specs__scalar_specs__is_valid_radix_16","name":"is_valid_radix_16","signature":"pub open spec fn is_valid_radix_16(digits: &[i8; 64]) -> bool","body":"pub open spec fn is_valid_radix_16(digits: &[i8; 64]) -> bool {\n    is_valid_radix_2w(digits, 4, 64)\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":215,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Predicate describing a valid radix-16 representation with signed digits\nThis is just radix-2^w with w=4","math_interpretation":"","informal_interpretation":"Predicate describing a valid radix-16 representation with signed digits","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L215","category":"spec","referenced_specs":["is_valid_radix_2w"]},{"id":"specs__scalar_specs__is_valid_radix_2w","name":"is_valid_radix_2w","signature":"pub open spec fn is_valid_radix_2w(digits: &[i8; 64], w: nat, digits_count: nat) -> bool","body":"pub open spec fn is_valid_radix_2w(digits: &[i8; 64], w: nat, digits_count: nat) -> bool {\n    4 <= w <= 8 && digits_count <= 64 && forall|i: int|\n        0 <= i < digits_count ==> {\n            let bound = pow2((w - 1) as nat) as int;\n            if i < digits_count - 1 {\n                -bound <= (#[trigger] digits[i]) && (#[trigger] digits[i]) < bound\n            } else {\n                -bound <= (#[trigger] digits[i]) && (#[trigger] digits[i]) <= bound\n            }\n        }\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":194,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Predicate describing a valid radix-2^w representation with signed digits\nFor window size w, coefficients are in [-2^(w-1), 2^(w-1)) for most indices,\nand [-2^(w-1), 2^(w-1)] for the last non-zero index","math_interpretation":"","informal_interpretation":"Predicate describing a valid radix-2^w representation with signed digits","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L194","category":"spec","referenced_specs":[]},{"id":"specs__scalar_specs__product_of_scalars","name":"product_of_scalars","signature":"pub open spec fn product_of_scalars(scalars: Seq<Scalar>) -> nat decreases scalars.len(),","body":"pub open spec fn product_of_scalars(scalars: Seq<Scalar>) -> nat\n    decreases scalars.len(),\n{\n    if scalars.len() == 0 {\n        1\n    } else {\n        let last = (scalars.len() - 1) as int;\n        (product_of_scalars(scalars.subrange(0, last)) * bytes32_to_nat(&scalars[last].bytes))\n            % group_order()\n    }\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":47,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Spec function to compute product of all scalars in a sequence (mod group_order)\nReturns the natural number representation\nNote: Processes from back to front to match iterative loop order","math_interpretation":"","informal_interpretation":"Spec function to compute product of all scalars in a sequence (mod group_order)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L47","category":"spec","referenced_specs":["bytes32_to_nat","group_order"]},{"id":"specs__scalar_specs__radix_16_all_bounded","name":"radix_16_all_bounded","signature":"pub open spec fn radix_16_all_bounded(digits: &[i8; 64]) -> bool","body":"pub open spec fn radix_16_all_bounded(digits: &[i8; 64]) -> bool {\n    forall|i: int| 0 <= i < 64 ==> radix_16_digit_bounded(#[trigger] digits[i])\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":226,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"All radix-16 digits are bounded by [-8, 8]","math_interpretation":"","informal_interpretation":"All radix-16 digits are bounded by [-8, 8]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L226","category":"spec","referenced_specs":["radix_16_digit_bounded"]},{"id":"specs__scalar_specs__radix_16_digit_bounded","name":"radix_16_digit_bounded","signature":"pub open spec fn radix_16_digit_bounded(digit: i8) -> bool","body":"pub open spec fn radix_16_digit_bounded(digit: i8) -> bool {\n    -8 <= digit && digit <= 8\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":221,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Simple bounds check for radix-16 digits: all digits in [-8, 8]\nThis is a simpler predicate than is_valid_radix_16 for easier use","math_interpretation":"","informal_interpretation":"Simple bounds check for radix-16 digits: all digits in [-8, 8]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L221","category":"spec","referenced_specs":[]},{"id":"specs__scalar_specs__reconstruct","name":"reconstruct","signature":"pub open spec fn reconstruct(naf: Seq<i8>) -> int decreases naf.len(),","body":"pub open spec fn reconstruct(naf: Seq<i8>) -> int\n    decreases naf.len(),\n{\n    if naf.len() == 0 {\n        0\n    } else {\n        (naf[0] as int) + 2 * reconstruct(naf.skip(1))\n    }\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":152,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L152","category":"spec","referenced_specs":[]},{"id":"specs__scalar_specs__reconstruct_radix_16","name":"reconstruct_radix_16","signature":"pub open spec fn reconstruct_radix_16(digits: Seq<i8>) -> int","body":"pub open spec fn reconstruct_radix_16(digits: Seq<i8>) -> int {\n    reconstruct_radix_2w(digits, 4)\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":209,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Reconstructs the integer value from a radix-16 representation\nThis is just radix-2^w with w=4","math_interpretation":"","informal_interpretation":"Reconstructs the integer value from a radix-16 representation","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L209","category":"spec","referenced_specs":["reconstruct_radix_2w"]},{"id":"specs__scalar_specs__reconstruct_radix_2w","name":"reconstruct_radix_2w","signature":"pub open spec fn reconstruct_radix_2w(digits: Seq<i8>, w: nat) -> int decreases digits.len(),","body":"pub open spec fn reconstruct_radix_2w(digits: Seq<i8>, w: nat) -> int\n    decreases digits.len(),\n{\n    if digits.len() == 0 {\n        0\n    } else {\n        (digits[0] as int) + pow2(w) * reconstruct_radix_2w(digits.skip(1), w)\n    }\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":181,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Reconstructs an integer from a radix-2^w digit representation\nThe scalar is represented as: a_0 + a_1*2^w + a_2*2^(2w) + ...","math_interpretation":"","informal_interpretation":"Reconstructs an integer from a radix-2^w digit representation","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L181","category":"spec","referenced_specs":[]},{"id":"specs__scalar_specs__scalar_to_nat","name":"scalar_to_nat","signature":"pub open spec fn scalar_to_nat(s: &Scalar) -> nat","body":"pub open spec fn scalar_to_nat(s: &Scalar) -> nat {\n    bytes32_to_nat(&s.bytes)\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":17,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"","math_interpretation":"LE(s.bytes) -> nat","informal_interpretation":"Interprets a `Scalar`’s canonical byte encoding as a natural number.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L17","category":"spec","referenced_specs":["bytes32_to_nat"]},{"id":"specs__scalar_specs__spec_clamp_integer","name":"spec_clamp_integer","signature":"pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32]","body":"pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32] {\n    // Build the result array element by element\n    [\n        bytes[0] & 0b1111_1000,  // Clear low 3 bits of byte 0\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n        bytes[6],\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n        bytes[19],\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        (bytes[31] & 0b0111_1111) | 0b0100_0000,  // Clear bit 7 and set bit 6 of byte 31\n    ]\n}","file":"curve25519-dalek/src/specs/scalar_specs.rs","line":112,"module":"specs::scalar_specs","visibility":"pub open spec fn","doc_comment":"Spec function for clamping a byte array to produce a valid X25519 scalar.\nThis is the spec-level version of the `clamp_integer` exec function.\n\nThe clamping operation:\n- Clears the 3 least significant bits (bits 0-2 of byte 0)\n- Clears bit 255 (bit 7 of byte 31)\n- Sets bit 6 of byte 31)\n\nThis produces a value in the range [2^254, 2^255) that is divisible by 8.","math_interpretation":"clamp: clear bits 0-2 and 255, set bit 254","informal_interpretation":"Specification function computing the clamped 32-byte scalar used in X25519.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/scalar_specs.rs#L112","category":"spec","referenced_specs":[]},{"id":"specs__window_specs__from_req","name":"from_req","signature":"open spec fn from_req(P: &'a EdwardsPoint) -> bool","body":"open spec fn from_req(P: &'a EdwardsPoint) -> bool {\n    edwards_point_limbs_bounded(*P)\n    && sum_of_limbs_bounded(&P.Y, &P.X, u64::MAX)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":242,"module":"specs::window_specs","visibility":"open spec fn","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L242","category":"spec","referenced_specs":["edwards_point_limbs_bounded","sum_of_limbs_bounded"]},{"id":"specs__window_specs__is_valid_lookup_table_affine","name":"is_valid_lookup_table_affine","signature":"pub open spec fn is_valid_lookup_table_affine<const N: usize>( table: [AffineNielsPoint; N], P: EdwardsPoint, size: nat, ) -> bool","body":"pub open spec fn is_valid_lookup_table_affine<const N: usize>(\n    table: [AffineNielsPoint; N],\n    P: EdwardsPoint,\n    size: nat,\n) -> bool {\n    is_valid_lookup_table_affine_coords(table, edwards_point_as_affine(P), size)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":76,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in AffineNiels form\nWrapper that takes an EdwardsPoint and extracts affine coords.","math_interpretation":"","informal_interpretation":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in AffineNiels form","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L76","category":"spec","referenced_specs":["edwards_point_as_affine","is_valid_lookup_table_affine_coords"]},{"id":"specs__window_specs__is_valid_lookup_table_affine_coords","name":"is_valid_lookup_table_affine_coords","signature":"pub open spec fn is_valid_lookup_table_affine_coords<const N: usize>( table: [AffineNielsPoint; N], basepoint: (nat, nat), size: nat, ) -> bool","body":"pub open spec fn is_valid_lookup_table_affine_coords<const N: usize>(\n    table: [AffineNielsPoint; N],\n    basepoint: (nat, nat),\n    size: nat,\n) -> bool {\n    &&& table.len() == size\n    &&& forall|j: int|\n        #![trigger table[j]]\n        0 <= j < size ==> affine_niels_point_as_affine_edwards(table[j]) == edwards_scalar_mul(\n            basepoint,\n            (j + 1) as nat,\n        )\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":60,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in AffineNiels form\nwhere P is given as affine coordinates (nat, nat).","math_interpretation":"","informal_interpretation":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in AffineNiels form","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L60","category":"spec","referenced_specs":["affine_niels_point_as_affine_edwards","edwards_scalar_mul"]},{"id":"specs__window_specs__is_valid_lookup_table_projective","name":"is_valid_lookup_table_projective","signature":"pub open spec fn is_valid_lookup_table_projective<const N: usize>( table: [ProjectiveNielsPoint; N], P: EdwardsPoint, size: nat, ) -> bool","body":"pub open spec fn is_valid_lookup_table_projective<const N: usize>(\n    table: [ProjectiveNielsPoint; N],\n    P: EdwardsPoint,\n    size: nat,\n) -> bool {\n    &&& table.len() == size\n    &&& forall|j: int|\n        0 <= j < size ==> projective_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(P), (j + 1) as nat)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":23,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in ProjectiveNiels form","math_interpretation":"","informal_interpretation":"Spec: Check if a lookup table contains [P, 2P, 3P, ..., size*P] in ProjectiveNiels form","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L23","category":"spec","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","projective_niels_point_as_affine_edwards"]},{"id":"specs__window_specs__is_valid_naf_lookup_table5_affine","name":"is_valid_naf_lookup_table5_affine","signature":"pub open spec fn is_valid_naf_lookup_table5_affine( table: [AffineNielsPoint; 8], A: EdwardsPoint, ) -> bool","body":"pub open spec fn is_valid_naf_lookup_table5_affine(\n    table: [AffineNielsPoint; 8],\n    A: EdwardsPoint,\n) -> bool {\n    forall|j: int|\n        0 <= j < 8 ==> affine_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(A), (2 * j + 1) as nat)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":122,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a NafLookupTable5 contains odd multiples [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\nin AffineNiels form.","math_interpretation":"","informal_interpretation":"Spec: Check if a NafLookupTable5 contains odd multiples [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L122","category":"spec","referenced_specs":["affine_niels_point_as_affine_edwards","edwards_point_as_affine","edwards_scalar_mul"]},{"id":"specs__window_specs__is_valid_naf_lookup_table5_projective","name":"is_valid_naf_lookup_table5_projective","signature":"pub open spec fn is_valid_naf_lookup_table5_projective( table: [ProjectiveNielsPoint; 8], A: EdwardsPoint, ) -> bool","body":"pub open spec fn is_valid_naf_lookup_table5_projective(\n    table: [ProjectiveNielsPoint; 8],\n    A: EdwardsPoint,\n) -> bool {\n    forall|j: int|\n        0 <= j < 8 ==> projective_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(A), (2 * j + 1) as nat)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":111,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a NafLookupTable5 contains odd multiples [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\nin ProjectiveNiels form.","math_interpretation":"","informal_interpretation":"Spec: Check if a NafLookupTable5 contains odd multiples [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L111","category":"spec","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","projective_niels_point_as_affine_edwards"]},{"id":"specs__window_specs__is_valid_naf_lookup_table8_affine","name":"is_valid_naf_lookup_table8_affine","signature":"pub open spec fn is_valid_naf_lookup_table8_affine( table: [AffineNielsPoint; 64], A: EdwardsPoint, ) -> bool","body":"pub open spec fn is_valid_naf_lookup_table8_affine(\n    table: [AffineNielsPoint; 64],\n    A: EdwardsPoint,\n) -> bool {\n    forall|j: int|\n        0 <= j < 64 ==> affine_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(A), (2 * j + 1) as nat)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":173,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]\nin AffineNiels form.","math_interpretation":"","informal_interpretation":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L173","category":"spec","referenced_specs":["affine_niels_point_as_affine_edwards","edwards_point_as_affine","edwards_scalar_mul"]},{"id":"specs__window_specs__is_valid_naf_lookup_table8_affine_coords","name":"is_valid_naf_lookup_table8_affine_coords","signature":"pub open spec fn is_valid_naf_lookup_table8_affine_coords( table: [AffineNielsPoint; 64], basepoint: (nat, nat), ) -> bool","body":"pub open spec fn is_valid_naf_lookup_table8_affine_coords(\n    table: [AffineNielsPoint; 64],\n    basepoint: (nat, nat),\n) -> bool {\n    forall|j: int|\n        #![trigger table[j]]\n        0 <= j < 64 ==> affine_niels_point_as_affine_edwards(table[j]) == edwards_scalar_mul(\n            basepoint,\n            (2 * j + 1) as nat,\n        )\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":185,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]\nin AffineNiels form, where A is given as affine coordinates (nat, nat).","math_interpretation":"","informal_interpretation":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L185","category":"spec","referenced_specs":["affine_niels_point_as_affine_edwards","edwards_scalar_mul"]},{"id":"specs__window_specs__is_valid_naf_lookup_table8_projective","name":"is_valid_naf_lookup_table8_projective","signature":"pub open spec fn is_valid_naf_lookup_table8_projective( table: [ProjectiveNielsPoint; 64], A: EdwardsPoint, ) -> bool","body":"pub open spec fn is_valid_naf_lookup_table8_projective(\n    table: [ProjectiveNielsPoint; 64],\n    A: EdwardsPoint,\n) -> bool {\n    forall|j: int|\n        0 <= j < 64 ==> projective_niels_point_as_affine_edwards(#[trigger] table[j])\n            == edwards_scalar_mul(edwards_point_as_affine(A), (2 * j + 1) as nat)\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":161,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]\nin ProjectiveNiels form.","math_interpretation":"","informal_interpretation":"Spec: Check if a NafLookupTable8 contains odd multiples [1A, 3A, 5A, ..., 127A]","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L161","category":"spec","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","projective_niels_point_as_affine_edwards"]},{"id":"specs__window_specs__lookup_table_affine_limbs_bounded","name":"lookup_table_affine_limbs_bounded","signature":"pub open spec fn lookup_table_affine_limbs_bounded<const N: usize>( table: [AffineNielsPoint; N], ) -> bool","body":"pub open spec fn lookup_table_affine_limbs_bounded<const N: usize>(\n    table: [AffineNielsPoint; N],\n) -> bool {\n    forall|j: int|\n        0 <= j < table.len() ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.y_plus_x, 54) && fe51_limbs_bounded(&entry.y_minus_x, 54)\n                && fe51_limbs_bounded(&entry.xy2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":47,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in an AffineNiels lookup table have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in an AffineNiels lookup table have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L47","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__window_specs__lookup_table_projective_limbs_bounded","name":"lookup_table_projective_limbs_bounded","signature":"pub open spec fn lookup_table_projective_limbs_bounded<const N: usize>( table: [ProjectiveNielsPoint; N], ) -> bool","body":"pub open spec fn lookup_table_projective_limbs_bounded<const N: usize>(\n    table: [ProjectiveNielsPoint; N],\n) -> bool {\n    forall|j: int|\n        0 <= j < table.len() ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.Y_plus_X, 54) && fe51_limbs_bounded(&entry.Y_minus_X, 54)\n                && fe51_limbs_bounded(&entry.Z, 54) && fe51_limbs_bounded(&entry.T2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":35,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in a ProjectiveNiels lookup table have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in a ProjectiveNiels lookup table have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L35","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__window_specs__naf_lookup_table5_affine_limbs_bounded","name":"naf_lookup_table5_affine_limbs_bounded","signature":"pub open spec fn naf_lookup_table5_affine_limbs_bounded(table: [AffineNielsPoint; 8]) -> bool","body":"pub open spec fn naf_lookup_table5_affine_limbs_bounded(table: [AffineNielsPoint; 8]) -> bool {\n    forall|j: int|\n        0 <= j < 8 ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.y_plus_x, 54) && fe51_limbs_bounded(&entry.y_minus_x, 54)\n                && fe51_limbs_bounded(&entry.xy2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":100,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in a NafLookupTable5<AffineNielsPoint> have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in a NafLookupTable5<AffineNielsPoint> have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L100","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__window_specs__naf_lookup_table5_projective_limbs_bounded","name":"naf_lookup_table5_projective_limbs_bounded","signature":"pub open spec fn naf_lookup_table5_projective_limbs_bounded( table: [ProjectiveNielsPoint; 8], ) -> bool","body":"pub open spec fn naf_lookup_table5_projective_limbs_bounded(\n    table: [ProjectiveNielsPoint; 8],\n) -> bool {\n    forall|j: int|\n        0 <= j < 8 ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.Y_plus_X, 54) && fe51_limbs_bounded(&entry.Y_minus_X, 54)\n                && fe51_limbs_bounded(&entry.Z, 54) && fe51_limbs_bounded(&entry.T2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":88,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in a NafLookupTable5<ProjectiveNielsPoint> have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in a NafLookupTable5<ProjectiveNielsPoint> have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L88","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__window_specs__naf_lookup_table8_affine_limbs_bounded","name":"naf_lookup_table8_affine_limbs_bounded","signature":"pub open spec fn naf_lookup_table8_affine_limbs_bounded(table: [AffineNielsPoint; 64]) -> bool","body":"pub open spec fn naf_lookup_table8_affine_limbs_bounded(table: [AffineNielsPoint; 64]) -> bool {\n    forall|j: int|\n        0 <= j < 64 ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.y_plus_x, 54) && fe51_limbs_bounded(&entry.y_minus_x, 54)\n                && fe51_limbs_bounded(&entry.xy2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":149,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in a NafLookupTable8<AffineNielsPoint> have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in a NafLookupTable8<AffineNielsPoint> have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L149","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"specs__window_specs__naf_lookup_table8_projective_limbs_bounded","name":"naf_lookup_table8_projective_limbs_bounded","signature":"pub open spec fn naf_lookup_table8_projective_limbs_bounded( table: [ProjectiveNielsPoint; 64], ) -> bool","body":"pub open spec fn naf_lookup_table8_projective_limbs_bounded(\n    table: [ProjectiveNielsPoint; 64],\n) -> bool {\n    forall|j: int|\n        0 <= j < 64 ==> {\n            let entry = #[trigger] table[j];\n            fe51_limbs_bounded(&entry.Y_plus_X, 54) && fe51_limbs_bounded(&entry.Y_minus_X, 54)\n                && fe51_limbs_bounded(&entry.Z, 54) && fe51_limbs_bounded(&entry.T2d, 54)\n        }\n}","file":"curve25519-dalek/src/specs/window_specs.rs","line":136,"module":"specs::window_specs","visibility":"pub open spec fn","doc_comment":"Spec: All entries in a NafLookupTable8<ProjectiveNielsPoint> have bounded limbs","math_interpretation":"","informal_interpretation":"Spec: All entries in a NafLookupTable8<ProjectiveNielsPoint> have bounded limbs","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L136","category":"spec","referenced_specs":["fe51_limbs_bounded"]},{"id":"core_assumes__axiom_hash_is_canonical","name":"axiom_hash_is_canonical","signature":"pub proof fn axiom_hash_is_canonical<H>(","body":"pub proof fn axiom_hash_is_canonical<H>(\n    point1: &MontgomeryPoint,\n    point2: &MontgomeryPoint,\n    state: H,\n)\n    requires\n// The two points represent the same field element (same canonical value)\n\n        spec_field_element_from_bytes(&point1.0) == spec_field_element_from_bytes(&point2.0),\n    ensures\n// Points with equal field element values hash to the same state\n\n        spec_state_after_hash_montgomery(state, point1) == spec_state_after_hash_montgomery(\n            state,\n            point2,\n        ),","file":"curve25519-dalek/src/core_assumes.rs","line":241,"module":"core_assumes","visibility":"proof fn","doc_comment":"","math_interpretation":"field_element(P1) = field_element(P2) => hash(P1) = hash(P2)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L241","category":"axiom","referenced_specs":["spec_field_element_from_bytes","spec_state_after_hash_montgomery"]},{"id":"core_assumes__axiom_sha512_output_length","name":"axiom_sha512_output_length","signature":"pub proof fn axiom_sha512_output_length(input: Seq<u8>)","body":"pub proof fn axiom_sha512_output_length(input: Seq<u8>)\n    ensures\n        spec_sha512(input).len() == 64,","file":"curve25519-dalek/src/core_assumes.rs","line":374,"module":"core_assumes","visibility":"proof fn","doc_comment":"Axiom: SHA-512 always produces exactly 64 bytes of output.","math_interpretation":"|SHA-512(input)| = 64 bytes","informal_interpretation":"Axiom: SHA-512 always produces exactly 64 bytes of output.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/core_assumes.rs#L374","category":"axiom","referenced_specs":["spec_sha512"]},{"id":"lemmas__common_lemmas__number_theory_lemmas__axiom_binomial_theorem","name":"axiom_binomial_theorem","signature":"proof fn axiom_binomial_theorem(a: nat, n: nat)","body":"proof fn axiom_binomial_theorem(a: nat, n: nat)\n    ensures\n        binomial_sum(a, n, n) == pow((a + 1) as int, n) as nat,","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":585,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"proof fn","doc_comment":"Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)","math_interpretation":"Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)","informal_interpretation":"Binomial Theorem: (a+1)^n = Σ_{k=0}^{n} C(n,k) * a^k (axiom)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L585","category":"axiom","referenced_specs":["binomial_sum"]},{"id":"lemmas__common_lemmas__number_theory_lemmas__axiom_gcd_mod_noop","name":"axiom_gcd_mod_noop","signature":"pub proof fn axiom_gcd_mod_noop(a: nat, m: nat)","body":"pub proof fn axiom_gcd_mod_noop(a: nat, m: nat)\n    requires\n        m > 0,\n    ensures\n        spec_gcd(a % m, m) == spec_gcd(a, m),","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":230,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"proof fn","doc_comment":"Axiom: gcd(a % m, m) = gcd(a, m) for m > 0\n\nMathematical proof: By the Euclidean algorithm property,\ngcd(a, m) = gcd(m, a % m) = gcd(a % m, m) (using commutativity).\nThis reflects that reducing a modulo m doesn't change the GCD with m.","math_interpretation":"gcd(a, m) = gcd(m, a % m) = gcd(a % m, m) (using commutativity).","informal_interpretation":"Axiom: gcd(a % m, m) = gcd(a, m) for m > 0","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L230","category":"axiom","referenced_specs":["spec_gcd"]},{"id":"lemmas__common_lemmas__number_theory_lemmas__axiom_gcd_pow2_odd","name":"axiom_gcd_pow2_odd","signature":"pub proof fn axiom_gcd_pow2_odd(k: nat, n: nat)","body":"pub proof fn axiom_gcd_pow2_odd(k: nat, n: nat)\n    requires\n        n % 2 == 1,  // n is odd\n\n    ensures\n        spec_gcd(pow2(k), n) == 1,","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":248,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"proof fn","doc_comment":"Axiom: gcd(2^k, n) = 1 when n is odd\n\nMathematical proof:\n- 2^k has only factor 2 (repeated k times)\n- An odd number n has no factor of 2\n- Therefore, gcd(2^k, n) = 1\n\nThe only divisors of 2^k are {1, 2, 4, ..., 2^k}.\nSince n is odd, 2 doesn't divide n, so no power of 2 > 1 divides n.","math_interpretation":"- Therefore, gcd(2^k, n) = 1","informal_interpretation":"Axiom: gcd(2^k, n) = 1 when n is odd","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L248","category":"axiom","referenced_specs":["spec_gcd"]},{"id":"lemmas__common_lemmas__number_theory_lemmas__axiom_gcd_symmetric","name":"axiom_gcd_symmetric","signature":"pub proof fn axiom_gcd_symmetric(a: nat, b: nat)","body":"pub proof fn axiom_gcd_symmetric(a: nat, b: nat)\n    ensures\n        spec_gcd(a, b) == spec_gcd(b, a),","file":"curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs","line":218,"module":"lemmas::common_lemmas::number_theory_lemmas","visibility":"proof fn","doc_comment":"Axiom: gcd(a, b) = gcd(b, a) (commutativity of GCD)\n\nMathematical proof: The GCD is defined as the largest common divisor of a and b.\nSince \"common divisor of a and b\" is the same as \"common divisor of b and a\",\nthe GCD is symmetric.","math_interpretation":"spec_gcd(a, b) = spec_gcd(b, a)","informal_interpretation":"Axiom: gcd(a, b) = gcd(b, a) (commutativity of GCD)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs#L218","category":"axiom","referenced_specs":["spec_gcd"]},{"id":"lemmas__edwards_lemmas__constants_lemmas__axiom_edwards_d2_is_2d","name":"axiom_edwards_d2_is_2d","signature":"pub(crate) proof fn axiom_edwards_d2_is_2d()","body":"pub(crate) proof fn axiom_edwards_d2_is_2d()\n    ensures\n        spec_field_element(&constants::EDWARDS_D2) == math_field_mul(\n            2,\n            spec_field_element(&EDWARDS_D),\n        ),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs","line":126,"module":"lemmas::edwards_lemmas::constants_lemmas","visibility":"proof fn","doc_comment":"EDWARDS_D2 equals 2 * EDWARDS_D in the field\n\n## Mathematical Background\nEDWARDS_D2 is precomputed as 2*d mod p in the curve25519-dalek library.\nThis is a well-established relationship for the curve25519 constants.\n\nThe postcondition states that spec_field_element(&EDWARDS_D2) equals\nmath_field_mul(2, spec_field_element(&EDWARDS_D)), i.e., 2*d mod p.","math_interpretation":"D2 = 2*D in F_p","informal_interpretation":"EDWARDS_D2 equals 2 * EDWARDS_D in the field","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/constants_lemmas.rs#L126","category":"axiom","referenced_specs":["math_field_mul","spec_field_element"]},{"id":"lemmas__edwards_lemmas__curve_equation_lemmas__axiom_add_neg_is_identity","name":"axiom_add_neg_is_identity","signature":"pub proof fn axiom_add_neg_is_identity(P: (nat, nat))","body":"pub proof fn axiom_add_neg_is_identity(P: (nat, nat))\n    ensures\n        edwards_add(P.0, P.1, edwards_neg(P).0, edwards_neg(P).1) == math_edwards_identity(),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs","line":1113,"module":"lemmas::edwards_lemmas::curve_equation_lemmas","visibility":"proof fn","doc_comment":"Axiom: Adding a point and its negation gives identity.\nP + (-P) = O (identity)","math_interpretation":"P + (-P) = O (identity)","informal_interpretation":"Axiom: Adding a point and its negation gives identity.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1113","category":"axiom","referenced_specs":["edwards_add","edwards_neg","math_edwards_identity"]},{"id":"lemmas__edwards_lemmas__curve_equation_lemmas__axiom_edwards_add_associative","name":"axiom_edwards_add_associative","signature":"pub proof fn axiom_edwards_add_associative(x1: nat, y1: nat, x2: nat, y2: nat, x3: nat, y3: nat)","body":"pub proof fn axiom_edwards_add_associative(x1: nat, y1: nat, x2: nat, y2: nat, x3: nat, y3: nat)\n    ensures\n        ({\n            let ab = edwards_add(x1, y1, x2, y2);\n            edwards_add(ab.0, ab.1, x3, y3)\n        }) == ({\n            let bc = edwards_add(x2, y2, x3, y3);\n            edwards_add(x1, y1, bc.0, bc.1)\n        }),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs","line":686,"module":"lemmas::edwards_lemmas::curve_equation_lemmas","visibility":"proof fn","doc_comment":"Axiom: Edwards addition is associative.\n\nThis is a standard group-law property.","math_interpretation":"(P + Q) + R = P + (Q + R) on Edwards curve","informal_interpretation":"Axiom: Edwards addition is associative.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L686","category":"axiom","referenced_specs":["edwards_add"]},{"id":"lemmas__edwards_lemmas__curve_equation_lemmas__axiom_edwards_scalar_mul_signed_additive","name":"axiom_edwards_scalar_mul_signed_additive","signature":"pub proof fn axiom_edwards_scalar_mul_signed_additive(P: (nat, nat), a: int, b: int)","body":"pub proof fn axiom_edwards_scalar_mul_signed_additive(P: (nat, nat), a: int, b: int)\n    ensures\n        ({\n            let pa = edwards_scalar_mul_signed(P, a);\n            let pb = edwards_scalar_mul_signed(P, b);\n            edwards_add(pa.0, pa.1, pb.0, pb.1)\n        }) == edwards_scalar_mul_signed(P, a + b),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs","line":1123,"module":"lemmas::edwards_lemmas::curve_equation_lemmas","visibility":"proof fn","doc_comment":"Axiom: [a]P + [b]P = [a+b]P for signed scalars a, b.\n\nThis is the group law for scalar multiplication linearity (group homomorphism property).","math_interpretation":"[a]P + [b]P = [a+b]P (signed scalars)","informal_interpretation":"Axiom: [a]P + [b]P = [a+b]P for signed scalars a, b.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1123","category":"axiom","referenced_specs":["edwards_add","edwards_scalar_mul_signed"]},{"id":"lemmas__edwards_lemmas__curve_equation_lemmas__axiom_neg_distributes_over_add","name":"axiom_neg_distributes_over_add","signature":"pub proof fn axiom_neg_distributes_over_add(P: (nat, nat), Q: (nat, nat))","body":"pub proof fn axiom_neg_distributes_over_add(P: (nat, nat), Q: (nat, nat))\n    ensures\n        edwards_add(edwards_neg(P).0, edwards_neg(P).1, edwards_neg(Q).0, edwards_neg(Q).1)\n            == edwards_neg(edwards_add(P.0, P.1, Q.0, Q.1)),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs","line":1103,"module":"lemmas::edwards_lemmas::curve_equation_lemmas","visibility":"proof fn","doc_comment":"Axiom: Negation distributes over addition (group homomorphism property).\n(-P) + (-Q) = -(P + Q)","math_interpretation":"(-P) + (-Q) = -(P + Q)","informal_interpretation":"Axiom: Negation distributes over addition (group homomorphism property).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1103","category":"axiom","referenced_specs":["edwards_add","edwards_neg"]},{"id":"lemmas__edwards_lemmas__curve_equation_lemmas__axiom_scalar_mul_distributes_over_neg","name":"axiom_scalar_mul_distributes_over_neg","signature":"pub proof fn axiom_scalar_mul_distributes_over_neg(P: (nat, nat), n: nat)","body":"pub proof fn axiom_scalar_mul_distributes_over_neg(P: (nat, nat), n: nat)\n    ensures\n        edwards_scalar_mul(edwards_neg(P), n) == edwards_neg(edwards_scalar_mul(P, n)),","file":"curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs","line":1094,"module":"lemmas::edwards_lemmas::curve_equation_lemmas","visibility":"proof fn","doc_comment":"Axiom: Scalar multiplication distributes over point negation.\n[n](-P) = -([n]P)","math_interpretation":"[n](-P) = -([n]P)","informal_interpretation":"Axiom: Scalar multiplication distributes over point negation.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/edwards_lemmas/curve_equation_lemmas.rs#L1094","category":"axiom","referenced_specs":["edwards_neg","edwards_scalar_mul"]},{"id":"lemmas__field_lemmas__field_algebra_lemmas__axiom_birational_edwards_montgomery","name":"axiom_birational_edwards_montgomery","signature":"pub proof fn axiom_birational_edwards_montgomery(y: nat, z: nat)","body":"pub proof fn axiom_birational_edwards_montgomery(y: nat, z: nat)\n    requires\n        z % p() != 0,  // Non-identity point (Z ≠ 0)\n\n    ensures\n        ({\n            let y_affine = math_field_mul(y, math_field_inv(z));\n            let one_plus_y = math_field_add(1, y_affine);\n            let one_minus_y = math_field_sub(1, y_affine);\n            let projective_result = math_field_mul(\n                math_field_add(z, y),\n                math_field_inv(math_field_sub(z, y)),\n            );\n            let affine_result = math_field_mul(one_plus_y, math_field_inv(one_minus_y));\n            projective_result == affine_result\n        }),","file":"curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs","line":1783,"module":"lemmas::field_lemmas::field_algebra_lemmas","visibility":"proof fn","doc_comment":"Lemma: Birational map identity for Edwards-to-Montgomery conversion\n\n## Mathematical Proof\nThe birational map from Edwards to Montgomery is u = (1+y)/(1-y).\nIn projective coordinates with affine y = Y/Z, this becomes:\n\n```text\n(1 + Y/Z) / (1 - Y/Z) = ((Z + Y)/Z) / ((Z - Y)/Z)\n= (Z + Y) / (Z - Y)       [Z cancels]\n```\n\nThis identity is fundamental to the Edwards-Montgomery birational equivalence.","math_interpretation":"(z+y)/(z-y) = (1+y/z)/(1-y/z) (birational map)","informal_interpretation":"Lemma: Birational map identity for Edwards-to-Montgomery conversion","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/field_algebra_lemmas.rs#L1783","category":"axiom","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_sub","p"]},{"id":"lemmas__field_lemmas__sqrt_m1_lemmas__axiom_neg_sqrt_m1_not_square","name":"axiom_neg_sqrt_m1_not_square","signature":"pub proof fn axiom_neg_sqrt_m1_not_square()","body":"pub proof fn axiom_neg_sqrt_m1_not_square()\n    ensures\n        !is_square_mod_p((p() - spec_sqrt_m1()) as nat),","file":"curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs","line":87,"module":"lemmas::field_lemmas::sqrt_m1_lemmas","visibility":"proof fn","doc_comment":"AXIOM: -i = -(sqrt(-1)) is not a square in F_p\n\nMathematical justification:\n- (-i)^((p-1)/2) = (-1)^((p-1)/2) · i^((p-1)/2)\n- (p-1)/2 = 2^254 - 10, which is even, so (-1)^((p-1)/2) = 1\n- From axiom_sqrt_m1_not_square: i^((p-1)/2) = -1\n- Therefore (-i)^((p-1)/2) = 1 · (-1) = -1 ≠ 1\n- By Euler's criterion, -i is NOT a square\n\nUsed in: lemma_no_square_root_when_times_i","math_interpretation":"-sqrt(-1) is not a quadratic residue mod p","informal_interpretation":"AXIOM: -i = -(sqrt(-1)) is not a square in F_p","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L87","category":"axiom","referenced_specs":["is_square_mod_p","p","spec_sqrt_m1"]},{"id":"lemmas__field_lemmas__sqrt_m1_lemmas__axiom_sqrt_m1_not_square","name":"axiom_sqrt_m1_not_square","signature":"pub proof fn axiom_sqrt_m1_not_square()","body":"pub proof fn axiom_sqrt_m1_not_square()\n    ensures\n        !is_square_mod_p(spec_sqrt_m1()),","file":"curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs","line":70,"module":"lemmas::field_lemmas::sqrt_m1_lemmas","visibility":"proof fn","doc_comment":"AXIOM: i = sqrt(-1) is not a square in F_p\n\nMathematical justification:\n- p = 2^255 - 19 ≡ 5 (mod 8)\n- For p ≡ 5 (mod 8), the Euler criterion gives:\ni^((p-1)/2) = (i²)^((p-1)/4) = (-1)^((p-1)/4)\n- (p-1)/4 = (2^255 - 20)/4 = 2^253 - 5, which is odd\n- Therefore (-1)^((p-1)/4) = -1 ≠ 1\n- By Euler's criterion, i is NOT a square\n\nUsed in: lemma_no_square_root_when_times_i","math_interpretation":"sqrt(-1) is not a quadratic residue mod p","informal_interpretation":"AXIOM: i = sqrt(-1) is not a square in F_p","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L70","category":"axiom","referenced_specs":["is_square_mod_p","spec_sqrt_m1"]},{"id":"lemmas__field_lemmas__sqrt_m1_lemmas__axiom_sqrt_m1_squared","name":"axiom_sqrt_m1_squared","signature":"pub proof fn axiom_sqrt_m1_squared()","body":"pub proof fn axiom_sqrt_m1_squared()\n    ensures\n        (spec_sqrt_m1() * spec_sqrt_m1()) % p() == (p() - 1),","file":"curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs","line":52,"module":"lemmas::field_lemmas::sqrt_m1_lemmas","visibility":"proof fn","doc_comment":"AXIOM: i² = -1 (mod p) — Definition of SQRT_M1\n\nMathematical justification:\n- SQRT_M1 is a specific constant computed to satisfy i² ≡ -1 (mod p)\n- The value is approximately 2^252.3 (a ~252-bit number)\n- Verification would require BigInt computation of the actual product\n\nUsed in: lemma_sqrt_m1_neq_one, lemma_sqrt_m1_neq_neg_one,\nlemma_multiply_by_i_flips_sign, lemma_no_square_root_when_times_i","math_interpretation":"i^2 = -1 (mod p), where i = sqrt(-1)","informal_interpretation":"AXIOM: i² = -1 (mod p) — Definition of SQRT_M1","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/field_lemmas/sqrt_m1_lemmas.rs#L52","category":"axiom","referenced_specs":["p","spec_sqrt_m1"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_2_times_486661_not_qr","name":"axiom_2_times_486661_not_qr","signature":"pub proof fn axiom_2_times_486661_not_qr()","body":"pub proof fn axiom_2_times_486661_not_qr()\n    ensures\n        !math_is_square((2nat * 486661nat) % p()),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":731,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: 2 * 486661 (= 2*(A-1)) is not a quadratic residue mod p.\nSince p ≡ 5 (mod 8), 2 is a non-QR; 486661 = A-1 is a QR; product is non-QR.\nVerified by runtime test `test_2_times_486661_not_qr`.","math_interpretation":"Since p ≡ 5 (mod 8), 2 is a non-QR; 486661 = A-1 is a QR; product is non-QR.","informal_interpretation":"Axiom: 2 * 486661 (= 2*(A-1)) is not a quadratic residue mod p.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L731","category":"axiom","referenced_specs":["math_is_square","p"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_486660_not_quadratic_residue","name":"axiom_486660_not_quadratic_residue","signature":"pub proof fn axiom_486660_not_quadratic_residue()","body":"pub proof fn axiom_486660_not_quadratic_residue()\n    ensures\n        !math_is_square(486660nat),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":721,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: 486660 (= A - 2) is not a quadratic residue mod p.\nEquivalently, Legendre symbol (486660 / p) = -1.\nVerified by runtime test `test_486660_not_qr`.","math_interpretation":"Equivalently, Legendre symbol (486660 / p) = -1.","informal_interpretation":"Axiom: 486660 (= A - 2) is not a quadratic residue mod p.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L721","category":"axiom","referenced_specs":["math_is_square"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_montgomery_a_neg_is_neg_a","name":"axiom_montgomery_a_neg_is_neg_a","signature":"pub proof fn axiom_montgomery_a_neg_is_neg_a()","body":"pub proof fn axiom_montgomery_a_neg_is_neg_a()\n    ensures\n        spec_field_element(&MONTGOMERY_A_NEG) == math_field_neg(spec_field_element(&MONTGOMERY_A)),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":817,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"MONTGOMERY_A_NEG represents math_field_neg(A) where A = 486662.\nIts limbs encode p - 486662 in the 51-bit representation.\nVerified by runtime test `test_montgomery_a_neg_value`.","math_interpretation":"fe(MONTGOMERY_A_NEG) = math_field_neg(fe(MONTGOMERY_A))","informal_interpretation":"MONTGOMERY_A_NEG represents math_field_neg(A) where A = 486662.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L817","category":"axiom","referenced_specs":["math_field_neg","spec_field_element"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_montgomery_add_associative","name":"axiom_montgomery_add_associative","signature":"pub proof fn axiom_montgomery_add_associative(","body":"pub proof fn axiom_montgomery_add_associative(\n    P: MontgomeryAffine,\n    Q: MontgomeryAffine,\n    R: MontgomeryAffine,\n)\n    ensures\n        montgomery_add(montgomery_add(P, Q), R) == montgomery_add(P, montgomery_add(Q, R)),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":39,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: Montgomery addition is associative\n(P + Q) + R = P + (Q + R)","math_interpretation":"(P + Q) + R = P + (Q + R)","informal_interpretation":"Axiom: Montgomery addition is associative","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L39","category":"axiom","referenced_specs":["montgomery_add"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_montgomery_add_identity","name":"axiom_montgomery_add_identity","signature":"pub proof fn axiom_montgomery_add_identity(P: MontgomeryAffine)","body":"pub proof fn axiom_montgomery_add_identity(P: MontgomeryAffine)\n    ensures\n        montgomery_add(P, MontgomeryAffine::Infinity) == P,","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":61,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: Infinity is the identity element (right identity)\nP + ∞ = P","math_interpretation":"P + ∞ = P","informal_interpretation":"Axiom: Infinity is the identity element (right identity)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L61","category":"axiom","referenced_specs":["montgomery_add"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_montgomery_add_identity_left","name":"axiom_montgomery_add_identity_left","signature":"pub proof fn axiom_montgomery_add_identity_left(P: MontgomeryAffine)","body":"pub proof fn axiom_montgomery_add_identity_left(P: MontgomeryAffine)\n    ensures\n        montgomery_add(MontgomeryAffine::Infinity, P) == P,","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":52,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: Left identity element\n∞ + P = P","math_interpretation":"∞ + P = P","informal_interpretation":"Axiom: Left identity element","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L52","category":"axiom","referenced_specs":["montgomery_add"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_montgomery_add_inverse","name":"axiom_montgomery_add_inverse","signature":"pub proof fn axiom_montgomery_add_inverse(P: MontgomeryAffine)","body":"pub proof fn axiom_montgomery_add_inverse(P: MontgomeryAffine)\n    ensures\n        montgomery_add(P, montgomery_neg(P)) == MontgomeryAffine::Infinity,","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":70,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: every point has an inverse\nP + (-P) = ∞","math_interpretation":"P + (-P) = ∞","informal_interpretation":"Axiom: every point has an inverse","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L70","category":"axiom","referenced_specs":["montgomery_add","montgomery_neg"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_nonsquare_branch_r_sq","name":"axiom_nonsquare_branch_r_sq","signature":"proof fn axiom_nonsquare_branch_r_sq(A: nat, d: nat, d_denom: nat, r_sq: nat)","body":"proof fn axiom_nonsquare_branch_r_sq(A: nat, d: nat, d_denom: nat, r_sq: nat)\n    requires\n        A == 486662nat,\n        d_denom == math_field_add(1, math_field_mul(2, r_sq)),\n        d == math_field_mul(math_field_neg(A), math_field_inv(d_denom)),\n        math_field_neg(math_field_add(d, A)) == math_field_sub(0, 1),\n    ensures\n        r_sq == math_field_inv((2nat * 486661nat) % p()),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":933,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"Axiom: if d = -A/(1+2r²) and d+A = 1 (mod p), then r² = inv(2·(A-1)).\nVerified by runtime test `test_nonsquare_branch_identity`.","math_interpretation":"r_sq = math_field_inv((2nat * 486661nat) mod p)","informal_interpretation":"Axiom: if d = -A/(1+2r²) and d+A = 1 (mod p), then r² = inv(2·(A-1)).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L933","category":"axiom","referenced_specs":["math_field_add","math_field_inv","math_field_mul","math_field_neg","math_field_sub","p"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_xadd_projective_correct","name":"axiom_xadd_projective_correct","signature":"pub(crate) proof fn axiom_xadd_projective_correct(","body":"pub(crate) proof fn axiom_xadd_projective_correct(\n    P: MontgomeryAffine,\n    Q: MontgomeryAffine,\n    U_P: nat,\n    W_P: nat,\n    U_Q: nat,\n    W_Q: nat,\n    affine_PmQ: nat,\n)\n    requires\n// (U_P:W_P) represents P; (U_Q:W_Q) represents Q\n\n        projective_represents_montgomery_or_infinity_nat(U_P, W_P, P),\n        projective_represents_montgomery_or_infinity_nat(U_Q, W_Q, Q),\n        P != Q,\n        affine_PmQ != 0,\n        // u-coordinate is symmetric: u(P-Q) = u(Q-P) since u is invariant under negation\n        affine_PmQ == spec_u_coordinate(montgomery_sub(P, Q)) || affine_PmQ == spec_u_coordinate(\n            montgomery_sub(Q, P),\n        ),\n    ensures\n        ({\n            let (U_PpQ, W_PpQ) = spec_xadd_projective(U_P, W_P, U_Q, W_Q, affine_PmQ);\n            projective_represents_montgomery_or_infinity_nat(U_PpQ, W_PpQ, montgomery_add(P, Q))\n        }),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":242,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"**xADD Axiom**: `spec_xadd_projective` correctly computes P + Q.\n\nRequires P ≠ Q and u(P - Q) ≠ 0.","math_interpretation":"xADD(U_P:W_P, U_Q:W_Q) represents P + Q","informal_interpretation":"**xADD Axiom**: `spec_xadd_projective` correctly computes P + Q.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L242","category":"axiom","referenced_specs":["montgomery_add","montgomery_sub","projective_represents_montgomery_or_infinity_nat","spec_u_coordinate","spec_xadd_projective"]},{"id":"lemmas__montgomery_curve_lemmas__axiom_xdbl_projective_correct","name":"axiom_xdbl_projective_correct","signature":"pub(crate) proof fn axiom_xdbl_projective_correct(P: MontgomeryAffine, U: nat, W: nat)","body":"pub(crate) proof fn axiom_xdbl_projective_correct(P: MontgomeryAffine, U: nat, W: nat)\n    requires\n// (U:W) represents P: for finite points u = U/W; for ∞ we have W = 0, U ≠ 0\n\n        projective_represents_montgomery_or_infinity_nat(U, W, P),\n    ensures\n        ({\n            let (U2, W2) = spec_xdbl_projective(U, W);\n            projective_represents_montgomery_or_infinity_nat(U2, W2, montgomery_add(P, P))\n        }),","file":"curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs","line":124,"module":"lemmas::montgomery_curve_lemmas","visibility":"proof fn","doc_comment":"**xDBL Axiom**: `spec_xdbl_projective` correctly computes [2]P.\n\nIf `(U:W)` represents affine point `P`, then `xDBL(U,W)` represents `[2]P`.","math_interpretation":"xDBL(U:W) represents [2]P","informal_interpretation":"**xDBL Axiom**: `spec_xdbl_projective` correctly computes [2]P.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/lemmas/montgomery_curve_lemmas.rs#L124","category":"axiom","referenced_specs":["montgomery_add","projective_represents_montgomery_or_infinity_nat","spec_xdbl_projective"]},{"id":"specs__edwards_specs__axiom_ed25519_basepoint_canonical","name":"axiom_ed25519_basepoint_canonical","signature":"pub proof fn axiom_ed25519_basepoint_canonical()","body":"pub proof fn axiom_ed25519_basepoint_canonical()\n    ensures\n        spec_ed25519_basepoint().0 < p(),\n        spec_ed25519_basepoint().1 < p(),","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":91,"module":"specs::edwards_specs","visibility":"proof fn","doc_comment":"The Ed25519 basepoint has reduced coordinates (both < p)\n\nThis is a property of the specific basepoint constant definition from the Ed25519 spec.\nThe basepoint X and Y coordinates are canonical field elements < p.\n\n## Values\n- X = 15112221349535807912866137220509078935008241517709382056166116785143545249788\n- Y = 46316835694926478169428394003475163141307993866256225615783033603165251855960\n- p = 57896044618658097711785492504343953926634992332820282019728792003956564819949\n\nBoth X < p and Y < p by direct comparison.\n","math_interpretation":"B_x < p, B_y < p","informal_interpretation":"The Ed25519 basepoint has reduced coordinates (both < p)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L91","category":"axiom","referenced_specs":["p","spec_ed25519_basepoint"]},{"id":"specs__edwards_specs__axiom_ed25519_basepoint_table_valid","name":"axiom_ed25519_basepoint_table_valid","signature":"pub proof fn axiom_ed25519_basepoint_table_valid()","body":"pub proof fn axiom_ed25519_basepoint_table_valid()\n    ensures\n        is_valid_edwards_basepoint_table(*ED25519_BASEPOINT_TABLE, spec_ed25519_basepoint()),","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":144,"module":"specs::edwards_specs","visibility":"proof fn","doc_comment":"Axiom: ED25519_BASEPOINT_TABLE is a valid basepoint table for the Ed25519 basepoint.\nThis connects the hardcoded constant to our specification.","math_interpretation":"ED25519_BASEPOINT_TABLE is valid for B","informal_interpretation":"Axiom: ED25519_BASEPOINT_TABLE is a valid basepoint table for the Ed25519 basepoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L144","category":"axiom","referenced_specs":["is_valid_edwards_basepoint_table","spec_ed25519_basepoint"]},{"id":"specs__edwards_specs__axiom_eight_torsion_well_formed","name":"axiom_eight_torsion_well_formed","signature":"pub proof fn axiom_eight_torsion_well_formed()","body":"pub proof fn axiom_eight_torsion_well_formed()\n    ensures\n        is_well_formed_edwards_point(EIGHT_TORSION[0]),\n        is_well_formed_edwards_point(EIGHT_TORSION[1]),\n        is_well_formed_edwards_point(EIGHT_TORSION[2]),\n        is_well_formed_edwards_point(EIGHT_TORSION[3]),\n        is_well_formed_edwards_point(EIGHT_TORSION[4]),\n        is_well_formed_edwards_point(EIGHT_TORSION[5]),\n        is_well_formed_edwards_point(EIGHT_TORSION[6]),\n        is_well_formed_edwards_point(EIGHT_TORSION[7]),","file":"curve25519-dalek/src/specs/edwards_specs.rs","line":161,"module":"specs::edwards_specs","visibility":"proof fn","doc_comment":"Axiom: All 8-torsion points are well-formed.\n\nThe EIGHT_TORSION array contains the 8-torsion subgroup E[8] of the curve.\nEach element satisfies `is_well_formed_edwards_point`, which requires:\n- `is_valid_edwards_point`: Z ≠ 0, projective curve equation, X·Y = Z·T\n- `edwards_point_limbs_bounded`: all limbs < 2^52\n- `sum_of_limbs_bounded(Y, X)`: Y + X doesn't overflow\n\nThis is verified by the `test_eight_torsion_well_formed` test below.","math_interpretation":"All E[8] torsion points are well-formed","informal_interpretation":"Axiom: All 8-torsion points are well-formed.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/edwards_specs.rs#L161","category":"axiom","referenced_specs":["is_well_formed_edwards_point"]},{"id":"specs__primality_specs__axiom_p_is_prime","name":"axiom_p_is_prime","signature":"pub proof fn axiom_p_is_prime()","body":"pub proof fn axiom_p_is_prime()\n    ensures\n        is_prime(p()),","file":"curve25519-dalek/src/specs/primality_specs.rs","line":24,"module":"specs::primality_specs","visibility":"proof fn","doc_comment":"Axiom: The field modulus p() = 2^255 - 19 is prime\n\nThis is a well-known mathematical fact. The number 2^255 - 19 has been\nverified to be prime and is the foundation of the Curve25519 construction.\n\nThis axiom is the basis for field-theoretic properties like:\n- Existence of multiplicative inverses for all non-zero elements\n- Fermat's Little Theorem: x^(p-1) ≡ 1 (mod p) for x ≢ 0 (mod p)","math_interpretation":"p = 2^255 - 19 is prime","informal_interpretation":"Axiom: The field modulus p() = 2^255 - 19 is prime","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/primality_specs.rs#L24","category":"axiom","referenced_specs":["is_prime","p"]},{"id":"specs__proba_specs__axiom_from_bytes_independent","name":"axiom_from_bytes_independent","signature":"pub proof fn axiom_from_bytes_independent(","body":"pub proof fn axiom_from_bytes_independent(\n    bytes1: &[u8; 32],\n    bytes2: &[u8; 32],\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n)\n    requires\n        spec_field_element_as_nat(fe1) == bytes32_to_nat(bytes1) % pow2(255),\n        spec_field_element_as_nat(fe2) == bytes32_to_nat(bytes2) % pow2(255),\n        is_independent_uniform_bytes32(bytes1, bytes2),\n    ensures\n        is_independent_uniform_field_elements(fe1, fe2),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":157,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: `from_bytes` preserves independence.\n\nIf two 32-byte strings are sampled independently, then the corresponding\nfield elements produced by `from_bytes` are also sampled independently.","math_interpretation":"independent bytes => independent field elements","informal_interpretation":"Axiom: `from_bytes` preserves independence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L157","category":"axiom","referenced_specs":["bytes32_to_nat","is_independent_uniform_bytes32","is_independent_uniform_field_elements","spec_field_element_as_nat"]},{"id":"specs__proba_specs__axiom_from_bytes_uniform","name":"axiom_from_bytes_uniform","signature":"pub proof fn axiom_from_bytes_uniform(bytes: &[u8; 32], fe: &FieldElement)","body":"pub proof fn axiom_from_bytes_uniform(bytes: &[u8; 32], fe: &FieldElement)\n    requires\n        spec_field_element_as_nat(fe) == bytes32_to_nat(bytes) % pow2(255),\n    ensures\n        is_uniform_bytes(bytes) ==> is_uniform_field_element(fe),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":144,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Clearing bit 255 of uniform bytes preserves uniform distribution.\n\nMathematical justification:\n- If X is uniform over [0, 2^256), then X mod 2^255 is uniform over [0, 2^255)\n- This is because the high bit is independent of the lower 255 bits\n- The limb representation is a bijection from 255-bit values to FieldElement\n\nNote: There's negligible bias (19/2^255 ≈ 5.4e-77) from values in [p, 2^255)\nthat wrap when used in field arithmetic, but this is cryptographically negligible.","math_interpretation":"uniform bytes => uniform field element","informal_interpretation":"Axiom: Clearing bit 255 of uniform bytes preserves uniform distribution.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L144","category":"axiom","referenced_specs":["bytes32_to_nat","is_uniform_bytes","is_uniform_field_element","spec_field_element_as_nat"]},{"id":"specs__proba_specs__axiom_uniform_bytes_split","name":"axiom_uniform_bytes_split","signature":"pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])","body":"pub proof fn axiom_uniform_bytes_split(bytes: &[u8; 64], first: &[u8; 32], second: &[u8; 32])\n    requires\n        first@ == bytes@.subrange(0, 32),\n        second@ == bytes@.subrange(32, 64),\n        is_uniform_bytes(bytes),\n    ensures\n        is_uniform_bytes(first),\n        is_uniform_bytes(second),\n        is_independent_uniform_bytes32(first, second),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":119,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Splitting uniform bytes preserves uniformity on each half.\n\nMathematical justification:\nIf X is uniform over [0, 2^512), then the first 256 bits and last 256 bits\nare each uniform over [0, 2^256) (they are independent uniform samples).","math_interpretation":"split(uniform_64) -> (uniform_32, uniform_32, independent)","informal_interpretation":"Axiom: Splitting uniform bytes preserves uniformity on each half.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L119","category":"axiom","referenced_specs":["is_independent_uniform_bytes32","is_uniform_bytes"]},{"id":"specs__proba_specs__axiom_uniform_elligator","name":"axiom_uniform_elligator","signature":"pub proof fn axiom_uniform_elligator(fe: &FieldElement, point: &RistrettoPoint)","body":"pub proof fn axiom_uniform_elligator(fe: &FieldElement, point: &RistrettoPoint)\n    requires\n        edwards_point_as_affine(point.0) == spec_elligator_ristretto_flavor(spec_field_element(fe)),\n        is_uniform_field_element(fe),\n    ensures\n        is_uniform_over_elligator_image(point),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":187,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Elligator map on uniform field element produces uniform point\nover the Elligator IMAGE (approximately half the Ristretto group).\n\nIMPORTANT: A single Elligator call does NOT produce a uniform point over\nthe full Ristretto group. Elligator maps F_p to roughly half the curve points\n(those with a certain Jacobi symbol). See:\n- Bernstein et al., \"Elligator: Elliptic-curve points indistinguishable from uniform random strings\"\n- https://ristretto.group/formulas/elligator.html\n\nTo get uniform distribution over the FULL group, use two independent Elligator\ncalls and add the results (see `axiom_uniform_elligator_sum`).","math_interpretation":"uniform field element => uniform over Elligator image","informal_interpretation":"Axiom: Elligator map on uniform field element produces uniform point","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L187","category":"axiom","referenced_specs":["edwards_point_as_affine","is_uniform_field_element","is_uniform_over_elligator_image","spec_elligator_ristretto_flavor","spec_field_element"]},{"id":"specs__proba_specs__axiom_uniform_elligator_independent","name":"axiom_uniform_elligator_independent","signature":"pub proof fn axiom_uniform_elligator_independent(","body":"pub proof fn axiom_uniform_elligator_independent(\n    fe1: &FieldElement,\n    fe2: &FieldElement,\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n)\n    requires\n        edwards_point_as_affine(p1.0) == spec_elligator_ristretto_flavor(spec_field_element(fe1)),\n        edwards_point_as_affine(p2.0) == spec_elligator_ristretto_flavor(spec_field_element(fe2)),\n        is_independent_uniform_field_elements(fe1, fe2),\n    ensures\n        is_independent_uniform_ristretto_points(p1, p2),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":201,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Elligator preserves independence.\n\nIf two field elements are sampled independently, then applying the Elligator\nmap to each yields independently sampled points (over the Elligator image).","math_interpretation":"independent field elements => independent Ristretto points","informal_interpretation":"Axiom: Elligator preserves independence.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L201","category":"axiom","referenced_specs":["edwards_point_as_affine","is_independent_uniform_field_elements","is_independent_uniform_ristretto_points","spec_elligator_ristretto_flavor","spec_field_element"]},{"id":"specs__proba_specs__axiom_uniform_elligator_sum","name":"axiom_uniform_elligator_sum","signature":"pub proof fn axiom_uniform_elligator_sum(","body":"pub proof fn axiom_uniform_elligator_sum(\n    p1: &RistrettoPoint,\n    p2: &RistrettoPoint,\n    sum: &RistrettoPoint,\n)\n    requires\n        edwards_point_as_affine(sum.0) == edwards_add(\n            edwards_point_as_affine(p1.0).0,\n            edwards_point_as_affine(p1.0).1,\n            edwards_point_as_affine(p2.0).0,\n            edwards_point_as_affine(p2.0).1,\n        ),\n        is_uniform_over_elligator_image(p1),\n        is_uniform_over_elligator_image(p2),\n        is_independent_uniform_ristretto_points(p1, p2),\n    ensures\n        is_uniform_ristretto_point(sum),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":229,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Sum of two *independent* uniform-over-Elligator-image points\nproduces a point uniform over the FULL Ristretto group.\n\nMathematical justification (Bernstein et al., ristretto.group):\n- Elligator(fe1) is uniform over ~half the group (Elligator image)\n- Elligator(fe2) is uniform over ~half the group (independent)\n- p1 + p2 covers the full group uniformly\n\nThis is precisely why `from_uniform_bytes` uses TWO Elligator calls + addition.","math_interpretation":"P1 + P2 is uniform if P1, P2 independent from Elligator","informal_interpretation":"Axiom: Sum of two *independent* uniform-over-Elligator-image points","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L229","category":"axiom","referenced_specs":["edwards_add","edwards_point_as_affine","is_independent_uniform_ristretto_points","is_uniform_over_elligator_image","is_uniform_ristretto_point"]},{"id":"specs__proba_specs__axiom_uniform_mod_reduction","name":"axiom_uniform_mod_reduction","signature":"pub proof fn axiom_uniform_mod_reduction(input: &[u8; 64], result: &Scalar)","body":"pub proof fn axiom_uniform_mod_reduction(input: &[u8; 64], result: &Scalar)\n    requires\n// result is the reduction of input mod group_order\n\n        scalar_to_nat(result) == bytes_seq_to_nat(input@) % group_order(),\n    ensures\n        is_uniform_bytes(input) ==> is_uniform_scalar(result),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":286,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Reducing 512 uniform bits modulo L produces a nearly uniform scalar.\n\nMathematical justification:\n- Input: 64 bytes = 512 bits, uniform over [0, 2^512)\n- Output: reduced modulo L (group order ≈ 2^253)\n- Each residue r ∈ [0, L) appears floor(2^512/L) or ceil(2^512/L) times\n- Statistical distance from uniform: at most L/2^512 ≈ 2^-259 (cryptographically negligible)","math_interpretation":"X mod L is uniform over Z_L when X uniform over [0, 2^512)","informal_interpretation":"Axiom: Reducing 512 uniform bits modulo L produces a nearly uniform scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L286","category":"axiom","referenced_specs":["bytes_seq_to_nat","group_order","is_uniform_bytes","is_uniform_scalar","scalar_to_nat"]},{"id":"specs__proba_specs__axiom_uniform_point_add","name":"axiom_uniform_point_add","signature":"pub proof fn axiom_uniform_point_add(p1: &RistrettoPoint, p2: &RistrettoPoint, sum: &RistrettoPoint)","body":"pub proof fn axiom_uniform_point_add(p1: &RistrettoPoint, p2: &RistrettoPoint, sum: &RistrettoPoint)\n    requires\n        edwards_point_as_affine(sum.0) == edwards_add(\n            edwards_point_as_affine(p1.0).0,\n            edwards_point_as_affine(p1.0).1,\n            edwards_point_as_affine(p2.0).0,\n            edwards_point_as_affine(p2.0).1,\n        ),\n        is_uniform_ristretto_point(p1),\n        is_uniform_ristretto_point(p2),\n        is_independent_uniform_ristretto_points(p1, p2),\n    ensures\n        is_uniform_ristretto_point(sum),","file":"curve25519-dalek/src/specs/proba_specs.rs","line":259,"module":"specs::proba_specs","visibility":"proof fn","doc_comment":"Axiom: Sum of two *independent* uniform points is uniform (group theory property).\n\nMathematical justification:\nIn a prime-order group G, if X and Y are independent uniform elements of G,\nthen X + Y is also uniform over G. Without independence this is false\n(e.g. if Y = -X then X + Y is always the identity).","math_interpretation":"P1 + P2 is uniform if P1, P2 uniform and independent","informal_interpretation":"Axiom: Sum of two *independent* uniform points is uniform (group theory property).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/proba_specs.rs#L259","category":"axiom","referenced_specs":["edwards_add","edwards_point_as_affine","is_independent_uniform_ristretto_points","is_uniform_ristretto_point"]},{"id":"specs__ristretto_specs__axiom_ristretto_basepoint_table_valid","name":"axiom_ristretto_basepoint_table_valid","signature":"pub proof fn axiom_ristretto_basepoint_table_valid()","body":"pub proof fn axiom_ristretto_basepoint_table_valid()\n    ensures\n        is_valid_edwards_basepoint_table(\n            constants::RISTRETTO_BASEPOINT_TABLE.0,\n            spec_ristretto_basepoint(),\n        ),","file":"curve25519-dalek/src/specs/ristretto_specs.rs","line":204,"module":"specs::ristretto_specs","visibility":"proof fn","doc_comment":"Axiom: `RISTRETTO_BASEPOINT_TABLE` is a valid precomputed table for the Ristretto basepoint.\n\nSince `RistrettoBasepointTable` wraps `EdwardsBasepointTable` and\n`RISTRETTO_BASEPOINT_TABLE` is a pointer cast of `ED25519_BASEPOINT_TABLE`,\nthis follows from `axiom_ed25519_basepoint_table_valid()`.","math_interpretation":"RISTRETTO_BASEPOINT_TABLE is valid for Ristretto basepoint","informal_interpretation":"Axiom: `RISTRETTO_BASEPOINT_TABLE` is a valid precomputed table for the Ristretto basepoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/ristretto_specs.rs#L204","category":"axiom","referenced_specs":["is_valid_edwards_basepoint_table","spec_ristretto_basepoint"]},{"id":"specs__window_specs__axiom_affine_odd_multiples_of_basepoint_valid","name":"axiom_affine_odd_multiples_of_basepoint_valid","signature":"pub proof fn axiom_affine_odd_multiples_of_basepoint_valid()","body":"pub proof fn axiom_affine_odd_multiples_of_basepoint_valid()\n    ensures\n        naf_lookup_table8_affine_limbs_bounded(AFFINE_ODD_MULTIPLES_OF_BASEPOINT.0),\n        is_valid_naf_lookup_table8_affine_coords(\n            AFFINE_ODD_MULTIPLES_OF_BASEPOINT.0,\n            spec_ed25519_basepoint(),\n        ),","file":"curve25519-dalek/src/specs/window_specs.rs","line":205,"module":"specs::window_specs","visibility":"proof fn","doc_comment":"Axiom: AFFINE_ODD_MULTIPLES_OF_BASEPOINT is a valid NAF lookup table for the Ed25519 basepoint.\nThis connects the hardcoded constant to our specification.\n\nThe table contains odd multiples [1·B, 3·B, 5·B, ..., 127·B] where B is the Ed25519 basepoint.","math_interpretation":"[1*B, 3*B, ..., 127*B] table is valid","informal_interpretation":"Axiom: AFFINE_ODD_MULTIPLES_OF_BASEPOINT is a valid NAF lookup table for the Ed25519 basepoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/specs/window_specs.rs#L205","category":"axiom","referenced_specs":["is_valid_naf_lookup_table8_affine_coords","naf_lookup_table8_affine_limbs_bounded","spec_ed25519_basepoint"]}],"verified_functions":[{"name":"conditional_assign","display_name":"AffineNielsPoint::conditional_assign","impl_type":"AffineNielsPoint","contract":"fn conditional_assign(&mut self, other: &Self, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> *self == *old(self),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> *self == *other,","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":460,"module":"backend","doc_comment":"","math_interpretation":"!choice = > *self = *old(self)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L460","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"affinenielspoint__conditional_assign"},{"name":"identity","display_name":"AffineNielsPoint::identity","impl_type":"AffineNielsPoint","contract":"fn identity() -> (result: ProjectivePoint)\n    ensures\n        result == identity_projective_point_edwards(),","referenced_specs":["identity_projective_point_edwards"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":265,"module":"backend","doc_comment":"","math_interpretation":"result = identity_projective_point_edwards()","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L297","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"affinenielspoint__identity"},{"name":"neg","display_name":"AffineNielsPoint::neg","impl_type":"AffineNielsPoint","contract":"fn neg(self) -> (result:\n    AffineNielsPoint)/* requires clause in NegSpecImpl:\n   requires fe51_limbs_bounded(&self.xy2d, 51)\n*/\n\n    ensures\n// Structural: negation swaps y_plus_x and y_minus_x\n\n        result.y_plus_x == self.y_minus_x,\n        result.y_minus_x == self.y_plus_x,\n        // Mathematical: the affine point is negated (x, y) → (-x, y)\n        ({\n            let self_affine = affine_niels_point_as_affine_edwards(*self);\n            let result_affine = affine_niels_point_as_affine_edwards(result);\n            result_affine == (math_field_neg(self_affine.0), self_affine.1)\n        }),","referenced_specs":["affine_niels_point_as_affine_edwards","fe51_limbs_bounded","math_field_neg"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":1318,"module":"backend","doc_comment":"Negate an AffineNielsPoint: for Edwards point (x, y), negation is (-x, y).\nIn AffineNiels form (y+x, y-x, xy2d), this swaps y+x ↔ y-x and negates xy2d.","math_interpretation":"result.y_plus_x = self.y_minus_x","informal_interpretation":"Negate an AffineNielsPoint: for Edwards point (x, y), negation is (-x, y).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1318","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"affinenielspoint__neg"},{"name":"zeroize","display_name":"AffineNielsPoint::zeroize","impl_type":"AffineNielsPoint","contract":"fn zeroize(&mut self)\n    ensures\n// All fields are zeroed (each limb is 0)\n\n        forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":210,"module":"backend","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 5 = > self.y_minus_x.limbs[i] = 0","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L210","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"affinenielspoint__zeroize"},{"name":"as_extended","display_name":"CompletedPoint::as_extended","impl_type":"CompletedPoint","contract":"pub fn as_extended(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_completed_point(*self),\n        // preconditions for mul\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n        fe51_limbs_bounded(&self.T, 54),\n    ensures\n        is_valid_edwards_point(result),\n        is_well_formed_edwards_point(result),\n        // Explicit bounds: mul() produces 52-bounded output\n        fe51_limbs_bounded(&result.X, 52),\n        fe51_limbs_bounded(&result.Y, 52),\n        fe51_limbs_bounded(&result.Z, 52),\n        fe51_limbs_bounded(&result.T, 52),\n        spec_edwards_point(result) == spec_completed_to_extended(*self),\n        edwards_point_as_affine(result) == completed_point_as_affine_edwards(*self),","referenced_specs":["completed_point_as_affine_edwards","edwards_point_as_affine","fe51_limbs_bounded","is_valid_completed_point","is_valid_edwards_point","is_well_formed_edwards_point","spec_completed_to_extended","spec_edwards_point"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":653,"module":"backend","doc_comment":"Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n\\\\) model to the \\\\( \\mathbb P\\^3 \\\\) model.\n\nThis costs \\\\(4 \\mathrm M \\\\).","math_interpretation":"spec_edwards_point(result) = spec_completed_to_extended(*self)","informal_interpretation":"Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L653","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"completedpoint__as_extended"},{"name":"as_projective","display_name":"CompletedPoint::as_projective","impl_type":"CompletedPoint","contract":"pub fn as_projective(&self) -> (result: ProjectivePoint)\n    requires\n        is_valid_completed_point(*self),\n        // preconditions for arithmetic traits\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n        fe51_limbs_bounded(&self.T, 54),\n    ensures\n        is_valid_projective_point(result),\n        spec_projective_point_edwards(result) == spec_completed_to_projective(*self),\n        projective_point_as_affine_edwards(result) == completed_point_as_affine_edwards(*self),\n        // Limb bounds from mul() postconditions (mul produces 52-bounded output)\n        fe51_limbs_bounded(&result.X, 52),\n        fe51_limbs_bounded(&result.Y, 52),\n        fe51_limbs_bounded(&result.Z, 52),\n        // Sum bounded: X, Y each < 2^52, so sum < 2^53 < u64::MAX\n        sum_of_limbs_bounded(&result.X, &result.Y, u64::MAX),","referenced_specs":["completed_point_as_affine_edwards","fe51_limbs_bounded","is_valid_completed_point","is_valid_projective_point","projective_point_as_affine_edwards","spec_completed_to_projective","spec_projective_point_edwards","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":522,"module":"backend","doc_comment":"Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1\n\\\\) model to the \\\\( \\mathbb P\\^2 \\\\) model.\n\nThis costs \\\\(3 \\mathrm M \\\\).","math_interpretation":"projective_point_as_affine_edwards(result) = completed_point_as_affine_edwards(*self)","informal_interpretation":"Convert this point from the \\\\( \\mathbb P\\^1 \\times \\mathbb P\\^1","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L522","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"completedpoint__as_projective"},{"name":"add","display_name":"EdwardsPoint::add","impl_type":"EdwardsPoint","contract":"fn add(self, other: &'b ProjectiveNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in AddSpecImpl::add_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        fe51_limbs_bounded(&other.Y_plus_X, 54),\n        fe51_limbs_bounded(&other.Y_minus_X, 54),\n        fe51_limbs_bounded(&other.Z, 54),\n        fe51_limbs_bounded(&other.T2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards addition of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        completed_point_as_affine_edwards(result) == spec_edwards_add_projective_niels(\n            *self,\n            *other,\n        ),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),","referenced_specs":["add","add_req","completed_point_as_affine_edwards","fe51_limbs_bounded","is_valid_completed_point","is_well_formed_edwards_point","spec_edwards_add_projective_niels"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":854,"module":"backend","doc_comment":"","math_interpretation":"is_valid_completed_point(result)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L854","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__add_L854"},{"name":"add","display_name":"EdwardsPoint::add","impl_type":"EdwardsPoint","contract":"fn add(self, other: &'b AffineNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in AddSpecImpl::add_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),\n        fe51_limbs_bounded(&other.y_plus_x, 54),\n        fe51_limbs_bounded(&other.y_minus_x, 54),\n        fe51_limbs_bounded(&other.xy2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards addition of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        completed_point_as_affine_edwards(result) == spec_edwards_add_affine_niels(\n            *self,\n            *other,\n        ),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),","referenced_specs":["add","add_req","completed_point_as_affine_edwards","fe51_limbs_bounded","is_valid_completed_point","is_well_formed_edwards_point","spec_edwards_add_affine_niels","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":1068,"module":"backend","doc_comment":"","math_interpretation":"is_valid_completed_point(result)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1068","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__add_L1068"},{"name":"sub","display_name":"EdwardsPoint::sub","impl_type":"EdwardsPoint","contract":"fn sub(self, other: &'b ProjectiveNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in SubSpecImpl::sub_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        fe51_limbs_bounded(&other.Y_plus_X, 54),\n        fe51_limbs_bounded(&other.Y_minus_X, 54),\n        fe51_limbs_bounded(&other.Z, 54),\n        fe51_limbs_bounded(&other.T2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards subtraction of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        ({\n            let self_affine = edwards_point_as_affine(*self);\n            let other_affine = projective_niels_point_as_affine_edwards(*other);\n            completed_point_as_affine_edwards(result) == edwards_sub(\n                self_affine.0,\n                self_affine.1,\n                other_affine.0,\n                other_affine.1,\n            )\n        }),\n        // Limb bounds for result (from mul's 52-bit output → sub/add produce ≤54-bit)\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),","referenced_specs":["add","completed_point_as_affine_edwards","edwards_point_as_affine","edwards_sub","fe51_limbs_bounded","is_valid_completed_point","is_well_formed_edwards_point","projective_niels_point_as_affine_edwards","sub_req"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":954,"module":"backend","doc_comment":"","math_interpretation":"is_valid_completed_point(result)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L954","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__sub_L954"},{"name":"sub","display_name":"EdwardsPoint::sub","impl_type":"EdwardsPoint","contract":"fn sub(self, other: &'b AffineNielsPoint) -> (result:\n    CompletedPoint)/* VERIFICATION NOTE: requires clause is in SubSpecImpl::sub_req\n    requires\n        is_well_formed_edwards_point(*self),  // EdwardsPoint invariant: 52-bounded\n        sum_of_limbs_bounded(&self.Z, &self.Z, u64::MAX),\n        fe51_limbs_bounded(&other.y_plus_x, 54),\n        fe51_limbs_bounded(&other.y_minus_x, 54),\n        fe51_limbs_bounded(&other.xy2d, 54),\n    */\n\n    ensures\n// The result represents the Edwards subtraction of the affine forms of self and other\n\n        is_valid_completed_point(result),\n        ({\n            let self_affine = edwards_point_as_affine(*self);\n            let other_affine = affine_niels_point_as_affine_edwards(*other);\n            completed_point_as_affine_edwards(result) == edwards_sub(\n                self_affine.0,\n                self_affine.1,\n                other_affine.0,\n                other_affine.1,\n            )\n        }),","referenced_specs":["affine_niels_point_as_affine_edwards","completed_point_as_affine_edwards","edwards_point_as_affine","edwards_sub","fe51_limbs_bounded","is_valid_completed_point","is_well_formed_edwards_point","sub_req","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":1163,"module":"backend","doc_comment":"","math_interpretation":"is_valid_completed_point(result)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1163","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__sub_L1163"},{"name":"add","display_name":"FieldElement51::add","impl_type":"FieldElement51","contract":"fn add(self, _rhs: &'a FieldElement51) -> (output: FieldElement51)\n    ensures\n        output == spec_add_fe51_limbs(self, _rhs),\n        spec_field_element_as_nat(&output) == spec_field_element_as_nat(self)\n            + spec_field_element_as_nat(_rhs),\n        spec_field_element(&output) == math_field_add(\n            spec_field_element(self),\n            spec_field_element(_rhs),\n        ),\n        // Bound propagation: tighter inputs give tighter output\n        fe51_limbs_bounded(self, 51) && fe51_limbs_bounded(_rhs, 51) ==> fe51_limbs_bounded(\n            &output,\n            52,\n        ),","referenced_specs":["add","fe51_limbs_bounded","math_field_add","spec_add_fe51_limbs","spec_field_element","spec_field_element_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":229,"module":"backend","doc_comment":"","math_interpretation":"nat(output) = nat(self) + nat(_rhs)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L229","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__add"},{"name":"add_assign","display_name":"FieldElement51::add_assign","impl_type":"FieldElement51","contract":"fn add_assign(&mut self, _rhs: &'a FieldElement51)\n    requires\n        sum_of_limbs_bounded(old(self), _rhs, u64::MAX),\n    ensures\n        *self == spec_add_fe51_limbs(old(self), _rhs),\n        spec_field_element_as_nat(self) == spec_field_element_as_nat(old(self))\n            + spec_field_element_as_nat(_rhs),\n        spec_field_element(self) == math_field_add(\n            spec_field_element(old(self)),\n            spec_field_element(_rhs),\n        ),","referenced_specs":["math_field_add","spec_add_fe51_limbs","spec_field_element","spec_field_element_as_nat","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":172,"module":"backend","doc_comment":"","math_interpretation":"nat(self) = spec_field_element_as_nat(old(self)) + nat(_rhs)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L172","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__add_assign"},{"name":"as_bytes","display_name":"FieldElement51::as_bytes","impl_type":"FieldElement51","contract":"pub fn as_bytes(self) -> (r: [u8; 32])\n    ensures\n// Canonical encoding: bytes represent the field element value\n\n        bytes32_to_nat(&r) == spec_field_element(&self),","referenced_specs":["bytes32_to_nat","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":1025,"module":"backend","doc_comment":"Serialize this `FieldElement51` to a 32-byte array.  The\nencoding is canonical.","math_interpretation":"// Canonical encoding: bytes represent the field element value nat(r) = fe(self)","informal_interpretation":"Serialize this `FieldElement51` to a 32-byte array.  The","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1025","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__as_bytes"},{"name":"conditional_assign","display_name":"FieldElement51::conditional_assign","impl_type":"FieldElement51","contract":"fn conditional_assign(&mut self, other: &FieldElement51, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> (forall|i: int|\n            0 <= i < 5 ==> #[trigger] self.limbs[i] == old(self).limbs[i]),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> (forall|i: int|\n            0 <= i < 5 ==> #[trigger] self.limbs[i] == other.limbs[i]),\n        // Field element value preservation\n        !choice_is_true(choice) ==> spec_field_element(self) == spec_field_element(old(self)),\n        choice_is_true(choice) ==> spec_field_element(self) == spec_field_element(other),\n        // Boundedness preservation\n        (fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(other, 54))\n            ==> fe51_limbs_bounded(self, 54),","referenced_specs":["choice_is_true","fe51_limbs_bounded","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":738,"module":"backend","doc_comment":"","math_interpretation":"!choice = > (forall|i: int| 0 <= i < 5 = > #[trigger] self.limbs[i] = old(self).limbs[i])","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L738","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__conditional_assign"},{"name":"from_limbs","display_name":"FieldElement51::from_limbs","impl_type":"FieldElement51","contract":"pub(crate) const fn from_limbs(limbs: [u64; 5]) -> (result: FieldElement51)\n    ensures\n        (result == FieldElement51 { limbs }),","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":780,"module":"backend","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L780","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__from_limbs"},{"name":"mul","display_name":"FieldElement51::mul","impl_type":"FieldElement51","contract":"fn mul(self, _rhs: &'a FieldElement51) -> (output:\n    FieldElement51)/*  VERIFICATION NOTE:\n- PROOF BYPASS\n- REVIEW SPEC WHILE DOING THE PROOF\n*/\n\n    ensures\n        spec_field_element(&output) == math_field_mul(\n            spec_field_element(self),\n            spec_field_element(_rhs),\n        ),\n        // Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n        fe51_limbs_bounded(&output, 52),\n        // 52-bit implies 54-bit (for compatibility with callers)\n        fe51_limbs_bounded(&output, 54),","referenced_specs":["fe51_limbs_bounded","math_field_mul","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":488,"module":"backend","doc_comment":"","math_interpretation":"limbs(output) < 2^52","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L488","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"fieldelement51__mul"},{"name":"mul_assign","display_name":"FieldElement51::mul_assign","impl_type":"FieldElement51","contract":"fn mul_assign(&mut self, _rhs: &'a FieldElement51)\n    requires\n        fe51_limbs_bounded(old(self), 54),\n        fe51_limbs_bounded(_rhs, 54),\n    ensures\n        spec_field_element(self) == math_field_mul(\n            spec_field_element(old(self)),\n            spec_field_element(_rhs),\n        ),\n        fe51_limbs_bounded(self, 54),","referenced_specs":["fe51_limbs_bounded","math_field_mul","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":447,"module":"backend","doc_comment":"","math_interpretation":"fe(self) = math_field_mul( spec_field_element(old(self)), fe(_rhs), ), limbs(self) < 2^54","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L447","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__mul_assign"},{"name":"neg","display_name":"FieldElement51::neg","impl_type":"FieldElement51","contract":"fn neg(self) -> (output: FieldElement51)\n    ensures\n        spec_field_element(&output) == math_field_neg(spec_field_element(self)),\n        forall|i: int| 0 <= i < 5 ==> output.limbs[i] < (1u64 << 52),","referenced_specs":["math_field_neg","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":652,"module":"backend","doc_comment":"","math_interpretation":"fe(output) = math_field_neg(fe(self)), forall|i: int| 0 <= i < 5 = > output.limbs[i] < (1u64 << 52)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L652","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__neg"},{"name":"negate","display_name":"FieldElement51::negate","impl_type":"FieldElement51","contract":"pub fn negate(&mut self)\n    requires\n        forall|i: int| 0 <= i < 5 ==> old(self).limbs[i] < (1u64 << 54),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < (1u64 << 52),\n        // Assume we start with l = (l0, l1, l2, l3, l4).\n        // Using c0 = 2^51 - 19 and c = 2^51 - 1, we can see that\n        // ( 36028797018963664u64 - l0,\n        //   36028797018963952u64 - l1,\n        //   36028797018963952u64 - l2,\n        //   36028797018963952u64 - l3,\n        //   36028797018963952u64 - l4 )\n        // is just 16 * (c0, c, c, c, c) - l (in vector notation)\n        // Further, u64_5_as_nat((c0, c, c, c, c)) = p, so\n        // u64_5_as_nat(16 * (c0, c, c, c, c) - l) is 16p - u64_5_as_nat(l)\n        // We know u64_5_as_nat(reduce(v)) = u64_5_as_nat(v) - p * (v4 >> 51) for any v.\n        // This gives us the identity\n        // u64_5_as_nat(negate(l)) = u64_5_as_nat(reduce(16 * (c0, c, c, c, c) - l))\n        //                   = 16p - u64_5_as_nat(l) - p * ((16c - l4) >> 51)\n        // Note that (16c - l4) >> 51 is either 14 or 15, in either case < 16.\n        u64_5_as_nat(self.limbs) == 16 * p() - u64_5_as_nat(old(self).limbs) - p() * ((\n        36028797018963952u64 - old(self).limbs[4]) as u64 >> 51),\n        (u64_5_as_nat(self.limbs) + u64_5_as_nat(old(self).limbs)) % p() == 0,\n        self.limbs == spec_negate(old(self).limbs),","referenced_specs":["l0","p","spec_negate","u64_5_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":811,"module":"backend","doc_comment":"Invert the sign of this field element\n\n# Implementation Note on Limb Bounds\n\nThe implementation adds 16*p (constants around 2^55) then subtracts and reduces.\nThe math shows it can actually handle larger inputs without underflow:\n- For 52-bit limbs (< 2^52): 2^55 - 2^52 = 7*2^52 > 0 ✓ (no underflow)\n- For 54-bit limbs (< 2^54): 2^55 - 2^54 = 2^54 > 0 ✓ (no underflow)\n","math_interpretation":"- For 52-bit limbs (< 2^52): 2^55 - 2^52 = 7*2^52 > 0 ✓ (no underflow)","informal_interpretation":"Invert the sign of this field element","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L811","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__negate"},{"name":"pow2k","display_name":"FieldElement51::pow2k","impl_type":"FieldElement51","contract":"pub fn pow2k(&self, mut k: u32) -> (r: FieldElement51)\n    requires\n        k > 0,  // debug_assert!( k > 0 );\n        forall|i: int|\n            0 <= i < 5 ==> self.limbs[i] < 1u64 << 54  // 51 + b for b = 3\n        ,\n    ensures\n// Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation in reduction)\n\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n        // 52-bit implies 54-bit (for compatibility with callers)\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n        u64_5_as_nat(r.limbs) % p() == pow(\n            u64_5_as_nat(self.limbs) as int,\n            pow2(k as nat),\n        ) as nat % p(),","referenced_specs":["p","u64_5_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":1148,"module":"backend","doc_comment":"Given `k > 0`, return `self^(2^k)`.","math_interpretation":"forall|i: int| 0 <= i < 5 = > r.limbs[i] < 1u64 << 52","informal_interpretation":"Given `k > 0`, return `self^(2^k)`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1148","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__pow2k"},{"name":"reduce","display_name":"FieldElement51::reduce","impl_type":"FieldElement51","contract":"fn reduce(mut limbs: [u64; 5]) -> (r: FieldElement51)\n    ensures\n        r.limbs == spec_reduce(limbs),\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < (1u64 << 52),\n        (forall|i: int| 0 <= i < 5 ==> limbs[i] < (1u64 << 51)) ==> (r.limbs =~= limbs),\n        u64_5_as_nat(r.limbs) == u64_5_as_nat(limbs) - p() * (limbs[4] >> 51),\n        u64_5_as_nat(r.limbs) % p() == u64_5_as_nat(limbs) % p(),\n        u64_5_as_nat(r.limbs) < 2 * p(),","referenced_specs":["p","spec_reduce","u64_5_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":867,"module":"backend","doc_comment":"Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).","math_interpretation":"(forall|i: int| 0 <= i < 5 = > limbs[i] < (1u64 << 51)) = > (r.limbs =~= limbs)","informal_interpretation":"Given 64-bit input limbs, reduce to enforce the bound 2^(51 + epsilon).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L867","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__reduce"},{"name":"square","display_name":"FieldElement51::square","impl_type":"FieldElement51","contract":"pub fn square(&self) -> (r: FieldElement51)\n    requires\n// The precondition in pow2k loop propagates to here\n\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n    ensures\n// Actual bound: 2^51 + 2^13 < 2^52 (from carry propagation)\n\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 52,\n        // 52-bit implies 54-bit (for compatibility with callers)\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 54,\n        u64_5_as_nat(r.limbs) % p() == pow(u64_5_as_nat(self.limbs) as int, 2) as nat % p(),","referenced_specs":["p","u64_5_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":1309,"module":"backend","doc_comment":"Returns the square of this field element.","math_interpretation":"u64_5_as_nat(r.limbs) mod p = (u64_5_as_nat(self.limbs) )^2 mod p","informal_interpretation":"Returns the square of this field element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1309","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__square"},{"name":"square2","display_name":"FieldElement51::square2","impl_type":"FieldElement51","contract":"pub fn square2(&self) -> (r: FieldElement51)\n    requires\n// The precondition in pow2k loop propagates to here\n\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] < 1u64 << 54,\n    ensures\n        u64_5_as_nat(r.limbs) % p() == (2 * pow(u64_5_as_nat(self.limbs) as int, 2)) as nat\n            % p(),\n        // Bounds: pow2k gives 52-bounded, doubling gives 53-bounded\n        forall|i: int| 0 <= i < 5 ==> r.limbs[i] < 1u64 << 53,\n        // 53-bounded implies 54-bounded (for compatibility)\n        fe51_limbs_bounded(&r, 54),","referenced_specs":["fe51_limbs_bounded","p","u64_5_as_nat"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":1330,"module":"backend","doc_comment":"Returns 2 times the square of this field element.","math_interpretation":"u64_5_as_nat(r.limbs) mod p = (2 * (u64_5_as_nat(self.limbs) )^2) mod p","informal_interpretation":"Returns 2 times the square of this field element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L1330","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__square2"},{"name":"sub","display_name":"FieldElement51::sub","impl_type":"FieldElement51","contract":"fn sub(self, _rhs: &'a FieldElement51) -> (output:\n    FieldElement51)\n// VERIFICATION NOTE: PROOF BYPASS\n\n    ensures\n        output == spec_sub_limbs(self, _rhs),\n        spec_field_element(&output) == math_field_sub(\n            spec_field_element(self),\n            spec_field_element(_rhs),\n        ),\n        fe51_limbs_bounded(&output, 54),","referenced_specs":["fe51_limbs_bounded","math_field_sub","spec_field_element","spec_sub_limbs"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":343,"module":"backend","doc_comment":"","math_interpretation":"output = spec_sub_limbs(self, _rhs)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L343","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__sub"},{"name":"sub_assign","display_name":"FieldElement51::sub_assign","impl_type":"FieldElement51","contract":"fn sub_assign(\n    &mut self,\n    _rhs: &'a FieldElement51,\n)\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        fe51_limbs_bounded(old(self), 54) && fe51_limbs_bounded(_rhs, 54),\n    ensures\n        forall|i: int| 0 <= i < 5 ==> #[trigger] self.limbs[i] < (1u64 << 52),\n        *self == spec_sub_limbs(old(self), _rhs),\n        spec_field_element(self) == math_field_sub(\n            spec_field_element(old(self)),\n            spec_field_element(_rhs),\n        ),","referenced_specs":["fe51_limbs_bounded","math_field_sub","spec_field_element","spec_sub_limbs"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":285,"module":"backend","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 5 = > #[trigger] self.limbs[i] < (1u64 << 52)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L285","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"fieldelement51__sub_assign"},{"name":"zeroize","display_name":"FieldElement51::zeroize","impl_type":"FieldElement51","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":129,"module":"backend","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 5 = > self.limbs[i] = 0","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L129","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement51__zeroize"},{"name":"optional_multiscalar_mul_verus","display_name":"Pippenger::optional_multiscalar_mul_verus","impl_type":"Pippenger","contract":"pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where S: Borrow<Scalar>, I: Iterator<Item = S>, J: Iterator<Item = Option<EdwardsPoint>>\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some iff all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),","referenced_specs":["all_points_some","edwards_point_as_affine","is_well_formed_edwards_point","spec_optional_points_from_iter","spec_scalars_from_iter","sum_of_scalar_muls","unwrap_points"],"file":"curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs","line":219,"module":"backend","doc_comment":"Verus-compatible version of optional_multiscalar_mul.\nComputes sum(scalars[i] * points[i]) for all i where points[i] is Some.","math_interpretation":"result.is_some() < = > all_points_some(spec_optional_points_from_iter::<J>(points))","informal_interpretation":"Verus-compatible version of optional_multiscalar_mul.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/pippenger.rs#L219","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"pippenger__optional_multiscalar_mul_verus"},{"name":"conditional_assign","display_name":"ProjectiveNielsPoint::conditional_assign","impl_type":"ProjectiveNielsPoint","contract":"fn conditional_assign(&mut self, other: &Self, choice: Choice)\n    ensures\n// If choice is false, self remains unchanged\n\n        !choice_is_true(choice) ==> *self == *old(self),\n        // If choice is true, self is assigned from other\n        choice_is_true(choice) ==> *self == *other,","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":414,"module":"backend","doc_comment":"","math_interpretation":"!choice = > *self = *old(self)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L414","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivenielspoint__conditional_assign"},{"name":"identity","display_name":"ProjectiveNielsPoint::identity","impl_type":"ProjectiveNielsPoint","contract":"fn identity() -> (result: ProjectivePoint)\n    ensures\n        result == identity_projective_point_edwards(),","referenced_specs":["identity_projective_point_edwards"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":265,"module":"backend","doc_comment":"","math_interpretation":"result = identity_projective_point_edwards()","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L274","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"projectivenielspoint__identity"},{"name":"neg","display_name":"ProjectiveNielsPoint::neg","impl_type":"ProjectiveNielsPoint","contract":"fn neg(self) -> (result:\n    ProjectiveNielsPoint)/* requires clause in NegSpecImpl:\n   requires fe51_limbs_bounded(&self.T2d, 51)\n*/\n\n    ensures\n// Structural: negation swaps Y_plus_X and Y_minus_X, keeps Z\n\n        result.Y_plus_X == self.Y_minus_X,\n        result.Y_minus_X == self.Y_plus_X,\n        result.Z == self.Z,\n        // Mathematical: the affine point is negated (x, y) → (-x, y)\n        ({\n            let self_affine = projective_niels_point_as_affine_edwards(*self);\n            let result_affine = projective_niels_point_as_affine_edwards(result);\n            result_affine == (math_field_neg(self_affine.0), self_affine.1)\n        }),","referenced_specs":["fe51_limbs_bounded","math_field_neg","projective_niels_point_as_affine_edwards"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":1257,"module":"backend","doc_comment":"Negate a ProjectiveNielsPoint: for Edwards point (x, y), negation is (-x, y).\nIn Niels form (Y+X, Y-X, Z, T2d), this swaps Y+X ↔ Y-X and negates T2d.","math_interpretation":"result.Y_plus_X = self.Y_minus_X","informal_interpretation":"Negate a ProjectiveNielsPoint: for Edwards point (x, y), negation is (-x, y).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L1257","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivenielspoint__neg"},{"name":"zeroize","display_name":"ProjectiveNielsPoint::zeroize","impl_type":"ProjectiveNielsPoint","contract":"fn zeroize(&mut self)\n    ensures\n// All fields are zeroed (each limb is 0)\n\n        forall|i: int| 0 <= i < 5 ==> self.y_plus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.y_minus_x.limbs[i] == 0,\n        forall|i: int| 0 <= i < 5 ==> self.xy2d.limbs[i] == 0,","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":210,"module":"backend","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 5 = > self.y_minus_x.limbs[i] = 0","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L240","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"projectivenielspoint__zeroize"},{"name":"as_extended","display_name":"ProjectivePoint::as_extended","impl_type":"ProjectivePoint","contract":"pub fn as_extended(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_projective_point(*self),\n        // preconditions for arithmetic traits\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n    ensures\n        is_valid_edwards_point(result),\n        spec_edwards_point(result) == spec_projective_to_extended(*self),\n        edwards_point_as_affine(result) == projective_point_as_affine_edwards(*self),","referenced_specs":["edwards_point_as_affine","fe51_limbs_bounded","is_valid_edwards_point","is_valid_projective_point","projective_point_as_affine_edwards","spec_edwards_point","spec_projective_to_extended"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":489,"module":"backend","doc_comment":"Convert this point from the \\\\( \\mathbb P\\^2 \\\\) model to the\n\\\\( \\mathbb P\\^3 \\\\) model.\n\nThis costs \\\\(3 \\mathrm M + 1 \\mathrm S\\\\).","math_interpretation":"spec_edwards_point(result) = spec_projective_to_extended(*self)","informal_interpretation":"Convert this point from the \\\\( \\mathbb P\\^2 \\\\) model to the","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L489","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivepoint__as_extended"},{"name":"double","display_name":"ProjectivePoint::double","impl_type":"ProjectivePoint","contract":"pub fn double(&self) -> (result: CompletedPoint)\n    requires\n        is_valid_projective_point(*self),\n        // preconditions for arithmetic traits (ProjectivePoint invariant: 52-bounded)\n        fe51_limbs_bounded(&self.X, 52),\n        fe51_limbs_bounded(&self.Y, 52),\n        fe51_limbs_bounded(&self.Z, 52),\n        sum_of_limbs_bounded(&self.X, &self.Y, u64::MAX),\n    ensures\n        is_valid_completed_point(result),\n        // The result represents the affine doubling of self\n        completed_point_as_affine_edwards(result) == ({\n            let (x, y) = projective_point_as_affine_edwards(*self);\n            edwards_double(x, y)\n        }),\n        fe51_limbs_bounded(&result.X, 54),\n        fe51_limbs_bounded(&result.Y, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T, 54),","referenced_specs":["completed_point_as_affine_edwards","edwards_double","fe51_limbs_bounded","is_valid_completed_point","is_valid_projective_point","projective_point_as_affine_edwards","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":708,"module":"backend","doc_comment":"Double this point: return self + self","math_interpretation":"is_valid_completed_point(result)","informal_interpretation":"Double this point: return self + self","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L708","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivepoint__double"},{"name":"is_valid","display_name":"ProjectivePoint::is_valid","impl_type":"ProjectivePoint","contract":"fn is_valid(&self) -> (result: bool)\n    requires\n        fe51_limbs_bounded(&self.X, 54),\n        fe51_limbs_bounded(&self.Y, 54),\n        fe51_limbs_bounded(&self.Z, 54),\n    ensures\n        result == math_on_edwards_curve_projective(\n            spec_field_element(&self.X),\n            spec_field_element(&self.Y),\n            spec_field_element(&self.Z),\n        ),","referenced_specs":["fe51_limbs_bounded","math_on_edwards_curve_projective","spec_field_element"],"file":"curve25519-dalek/src/backend/serial/curve_models/mod.rs","line":325,"module":"backend","doc_comment":"","math_interpretation":"spec_field_element(self.Y)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/curve_models/mod.rs#L325","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivepoint__is_valid"},{"name":"add","display_name":"Scalar52::add","impl_type":"Scalar52","contract":"pub fn add(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        scalar52_to_nat(&a) < group_order(),\n        scalar52_to_nat(&b) < group_order(),\n    ensures\n        scalar52_to_nat(&s) == (scalar52_to_nat(&a) + scalar52_to_nat(&b)) % group_order(),\n        // VERIFICATION NOTE: Result is canonical\n        scalar52_to_nat(&s) < group_order(),\n        // VERIFICATION NOTE: Result has bounded limbs (from sub)\n        limbs_bounded(&s),","referenced_specs":["add","group_order","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":556,"module":"backend","doc_comment":"Compute `a + b` (mod l)","math_interpretation":"nat(s) = (nat(a) + nat(b)) mod L","informal_interpretation":"Compute `a + b` (mod l)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L525","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__add"},{"name":"as_bytes","display_name":"Scalar52::as_bytes","impl_type":"Scalar52","contract":"pub fn as_bytes(self) -> (s: [u8; 32])\n    requires\n        limbs_bounded(&self),\n    ensures\n        bytes32_to_nat(&s) == scalar52_to_nat(&self) % pow2(256),","referenced_specs":["bytes32_to_nat","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":505,"module":"backend","doc_comment":"Pack the limbs of this `Scalar52` into 32 bytes","math_interpretation":"nat(s) = nat(self) mod pow2(256)","informal_interpretation":"Pack the limbs of this `Scalar52` into 32 bytes","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L474","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__as_bytes"},{"name":"as_montgomery","display_name":"Scalar52::as_montgomery","impl_type":"Scalar52","contract":"pub fn as_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        #[trigger] (scalar52_to_nat(&result) % group_order()) == #[trigger] ((scalar52_to_nat(\n            self,\n        ) * montgomery_radix()) % group_order()),\n        // Result is canonical because RR is canonical\n        is_canonical_scalar52(&result),","referenced_specs":["group_order","is_canonical_scalar52","limb_prod_bounded_u128","limbs_bounded","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1984,"module":"backend","doc_comment":"Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`\n\n# Precondition\nRequires `limbs_bounded(self)` because `montgomery_mul` (called internally) now\nrequires both inputs to have `limbs_bounded`. This is safe because all `Scalar52`\nvalues in practice have `limbs_bounded` (from `unpack()` or other Montgomery ops).","math_interpretation":"limb_prod_bounded_u128(result.limbs, result.limbs, 5)","informal_interpretation":"Puts a Scalar52 in to Montgomery form, i.e. computes `a*R (mod l)`","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1292","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__as_montgomery"},{"name":"from_bytes","display_name":"Scalar52::from_bytes","impl_type":"Scalar52","contract":"pub fn from_bytes(bytes: &[u8; 32]) -> (s: Scalar52)\n    ensures\n        bytes32_to_nat(bytes) == scalar52_to_nat(&s),\n        limbs_bounded(&s),\n        limb_prod_bounded_u128(s.limbs, s.limbs, 5),","referenced_specs":["bytes32_to_nat","limb_prod_bounded_u128","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":164,"module":"backend","doc_comment":"Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.","math_interpretation":"nat(bytes) = nat(s), limbs_bounded(s), limb_prod_bounded_u128(s.limbs, s.limbs, 5)","informal_interpretation":"Unpack a 32 byte / 256 bit scalar into 5 52-bit limbs.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L157","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__from_bytes"},{"name":"from_bytes_wide","display_name":"Scalar52::from_bytes_wide","impl_type":"Scalar52","contract":"pub fn from_bytes_wide(bytes: &[u8; 64]) -> (s: Scalar52)\n    ensures\n// VERIFICATION NOTE: Result is canonical\n\n        is_canonical_scalar52(&s),\n        scalar52_to_nat(&s) == bytes_seq_to_nat(bytes@) % group_order(),","referenced_specs":["bytes_seq_to_nat","group_order","is_canonical_scalar52","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":235,"module":"backend","doc_comment":"Reduce a 64 byte / 512 bit scalar mod l","math_interpretation":"// VERIFICATION NOTE: Result is canonical s < L, nat(s) = bytes_seq_to_nat(bytes@) mod L","informal_interpretation":"Reduce a 64 byte / 512 bit scalar mod l","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L228","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__from_bytes_wide"},{"name":"from_montgomery","display_name":"Scalar52::from_montgomery","impl_type":"Scalar52","contract":"pub fn from_montgomery(&self) -> (result: Scalar52)\n    requires\n        limbs_bounded(self),\n    ensures\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == scalar52_to_nat(self)\n            % group_order(),\n        // Result is canonical (< group_order). This follows from montgomery_reduce's postcondition\n        is_canonical_scalar52(&result),","referenced_specs":["group_order","is_canonical_scalar52","limbs_bounded","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":2023,"module":"backend","doc_comment":"Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`\n","math_interpretation":"(nat(result) * montgomery_radix()) mod L = nat(self) mod L","informal_interpretation":"Takes a Scalar52 out of Montgomery form, i.e. computes `a/R (mod l)`","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1330","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__from_montgomery"},{"name":"index","display_name":"Scalar52::index","impl_type":"Scalar52","contract":"fn index(&self, _index: usize) -> (result: &u64)\n    requires\n        _index < 5,\n    ensures\n        result == &(self.limbs[_index as int]),","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":126,"module":"backend","doc_comment":"","math_interpretation":"result = &(self.limbs[_index ])","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L119","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__index"},{"name":"montgomery_mul","display_name":"Scalar52::montgomery_mul","impl_type":"Scalar52","contract":"pub fn montgomery_mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // At least one input must be canonical for montgomery_reduce's canonical_bound\n        is_canonical_scalar52(a) || is_canonical_scalar52(b),\n    ensures\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat(&a)\n            * scalar52_to_nat(&b)) % group_order(),\n        // Result is canonical from montgomery_reduce\n        is_canonical_scalar52(&result),","referenced_specs":["group_order","is_canonical_scalar52","limb_prod_bounded_u128","limbs_bounded","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1893,"module":"backend","doc_comment":"Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260\n\n# Preconditions\n- Both inputs must have `limbs_bounded` (ensures `input_bounds` for the product)\n- At least one input must be canonical for `montgomery_reduce`'s `canonical_bound`","math_interpretation":"(nat(result) * montgomery_radix()) mod L = (nat(a) * nat(b)) mod L","informal_interpretation":"Compute `(a * b) / R` (mod l), where R is the Montgomery modulus 2^260","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1243","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__montgomery_mul"},{"name":"montgomery_reduce","display_name":"Scalar52::montgomery_reduce","impl_type":"Scalar52","contract":"/// pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {\n///     #[inline(always)]\n///     fn part1(sum: u128) -> (u128, u64) {\n///         let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n///         ((sum + m(p, constants::L[0])) >> 52, p)\n///     }\n///     #[inline(always)]\n///     fn part2(sum: u128) -> (u128, u64) {\n///         let w = (sum as u64) & ((1u64 << 52) - 1);\n///         (sum >> 52, w)\n///     }\n///     // note: l[3] is zero, so its multiples can be skipped\n///     let l = &constants::L;\n///     // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n///     let (carry, n0) = part1(        limbs[0]);\n///     let (carry, n1) = part1(carry + limbs[1] + m(n0, l[1]));\n///     let (carry, n2) = part1(carry + limbs[2] + m(n0, l[2]) + m(n1, l[1]));\n///     let (carry, n3) = part1(carry + limbs[3]               + m(n1, l[2]) + m(n2, l[1]));\n///     let (carry, n4) = part1(carry + limbs[4] + m(n0, l[4])               + m(n2, l[2]) + m(n3, l[1]));\n///     // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n///     let (carry, r0) = part2(carry + limbs[5]               + m(n1, l[4])               + m(n3, l[2])   + m(n4, l[1]));\n///     let (carry, r1) = part2(carry + limbs[6]                             + m(n2,l[4])                  + m(n4, l[2]));\n///     let (carry, r2) = part2(carry + limbs[7]                                           + m(n3, l[4])                );\n///     let (carry, r3) = part2(carry + limbs[8]                                                           + m(n4, l[4]));\n///     let         r4 = carry as u64;\n///     // result may be >= l, so attempt to subtract l\n///     Scalar52::sub(&Scalar52([r0, r1, r2, r3, r4]), l)\n/// }\n</ORIGINAL CODE> */\n/// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n///\n/// # Preconditions\n/// - `montgomery_reduce_input_bounds(limbs)`: Per-limb bounds for overflow-safe computation\n/// - `montgomery_reduce_canonical_bound(limbs)`: T < R×L (HAC 14.32's value constraint)\n///\n/// # Postconditions (all unconditional given preconditions)\n/// - `limbs_bounded(&result)`: Result limbs are bounded (< 2^52)\n/// - `montgomery_congruent(&result, limbs)`: (result × R) ≡ T (mod L)\n/// - `is_canonical_scalar52(&result)`: result < L\n///\n/// # Note\n/// The `canonical_bound` precondition corresponds to HAC Algorithm 14.32's requirement\n/// that T < m×R for correct Montgomery reduction. This ensures intermediate < 2L,\n/// which is needed for sub's correctness and the r4 < 2^52 + L[4] bound.\n/// HAC is at https://cacr.uwaterloo.ca/hac/about/chap14.pdf\n/// The `input_bounds` precondition ensures no overflow in u128 arithmetic.\n#[inline(always)]\n#[rustfmt::skip]  // keep alignment of n* and r* calculations\npub(crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    requires\n// Per-limb bounds for overflow-safe u128 arithmetic\n\n        montgomery_reduce_input_bounds(limbs),\n        // HAC 14.32's value constraint: T < R×L ensures intermediate < 2L\n        montgomery_reduce_canonical_bound(limbs),\n    ensures\n// All postconditions are now unconditional (given preconditions)\n\n        limbs_bounded(&result),\n        montgomery_congruent(&result, limbs),\n        is_canonical_scalar52(&result),","referenced_specs":["is_canonical_scalar52","limbs_bounded","montgomery_congruent","montgomery_reduce_canonical_bound","montgomery_reduce_input_bounds","p"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1066,"module":"backend","doc_comment":"","math_interpretation":"montgomery_congruent(result, limbs)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L999","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar52__montgomery_reduce"},{"name":"montgomery_square","display_name":"Scalar52::montgomery_square","impl_type":"Scalar52","contract":"pub fn montgomery_square(&self) -> (result: Scalar52)\n    requires\n// Must be canonical for montgomery_reduce's canonical_bound\n\n        is_canonical_scalar52(self),\n    ensures\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        (scalar52_to_nat(&result) * montgomery_radix()) % group_order() == (scalar52_to_nat(\n            self,\n        ) * scalar52_to_nat(self)) % group_order(),\n        // Result is canonical from montgomery_reduce\n        is_canonical_scalar52(&result),","referenced_specs":["group_order","is_canonical_scalar52","limb_prod_bounded_u128","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1942,"module":"backend","doc_comment":"Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260\n\n# Preconditions\n- Input must be canonical for `montgomery_reduce`'s `canonical_bound`\n\nWhy `limbs_bounded` (part of canonical): `square_internal(self)[0] = self.limbs[0]²`,\nand we need `self.limbs[0]² < 2^104`, so `self.limbs[0] < 2^52`.","math_interpretation":"limb_prod_bounded_u128(result.limbs, result.limbs, 5)","informal_interpretation":"Compute `(a^2) / R` (mod l) in Montgomery form, where R is the Montgomery modulus 2^260","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1277","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__montgomery_square"},{"name":"mul","display_name":"Scalar52::mul","impl_type":"Scalar52","contract":"pub fn mul(a: &Scalar52, b: &Scalar52) -> (result: Scalar52)\n    requires\n        limbs_bounded(a),\n        limbs_bounded(b),\n        // At least one input must be canonical for montgomery_reduce's canonical_bound\n        is_canonical_scalar52(a) || is_canonical_scalar52(b),\n    ensures\n        scalar52_to_nat(&result) % group_order() == (scalar52_to_nat(&a) * scalar52_to_nat(&b))\n            % group_order(),\n        is_canonical_scalar52(&result),","referenced_specs":["group_order","is_canonical_scalar52","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1725,"module":"backend","doc_comment":"Compute `a * b` (mod l)\n\n# Preconditions\n- Both inputs must be bounded (limbs < 2^52)\n- At least one input must be canonical (< L) for verified first reduction","math_interpretation":"nat(result) mod L = (nat(a) * nat(b)) mod L, result < L","informal_interpretation":"Compute `a * b` (mod l)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1140","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__mul"},{"name":"mul_internal","display_name":"Scalar52::mul_internal","impl_type":"Scalar52","contract":"pub(crate) fn mul_internal(a: &Scalar52, b: &Scalar52) -> (z: [u128; 9])\n    requires\n        limb_prod_bounded_u128(a.limbs, b.limbs, 5),\n    ensures\n        slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&b),\n        spec_mul_internal(a, b) == z,","referenced_specs":["limb_prod_bounded_u128","scalar52_to_nat","slice128_to_nat","spec_mul_internal"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":940,"module":"backend","doc_comment":"Compute `a * b`","math_interpretation":"slice128_to_nat(z) = nat(a) * nat(b), spec_mul_internal(a, b) = z","informal_interpretation":"Compute `a * b`","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L871","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__mul_internal"},{"name":"square","display_name":"Scalar52::square","impl_type":"Scalar52","contract":"pub fn square(&self) -> (result: Scalar52)\n    requires\n// Must be canonical for montgomery_reduce's canonical_bound\n\n        is_canonical_scalar52(self),\n    ensures\n        scalar52_to_nat(&result) == (scalar52_to_nat(self) * scalar52_to_nat(self))\n            % group_order(),","referenced_specs":["group_order","is_canonical_scalar52","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1812,"module":"backend","doc_comment":"Compute `a^2` (mod l)\n\n# Preconditions\n- Input must be canonical (bounded and < L) for verified first reduction","math_interpretation":"nat(result) = (nat(self) * nat(self)) mod L","informal_interpretation":"Compute `a^2` (mod l)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1189","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__square"},{"name":"square_internal","display_name":"Scalar52::square_internal","impl_type":"Scalar52","contract":"fn square_internal(a: &Scalar52) -> [u128; 9] {\n    let aa = [\n        a[0] * 2,\n        a[1] * 2,\n        a[2] * 2,\n        a[3] * 2,\n    ];\n\n    [\n        m( a[0], a[0]),\n        m(aa[0], a[1]),\n        m(aa[0], a[2]) + m( a[1], a[1]),\n        m(aa[0], a[3]) + m(aa[1], a[2]),\n        m(aa[0], a[4]) + m(aa[1], a[3]) + m( a[2], a[2]),\n                         m(aa[1], a[4]) + m(aa[2], a[3]),\n                                          m(aa[2], a[4]) + m( a[3], a[3]),\n                                                           m(aa[3], a[4]),\n                                                                            m(a[4], a[4])\n    ]\n}\n</ORIGINAL CODE> */\n/* <VERIFICATION NOTE>\n-  refactored verified version of square_internal\n- slightly slower ?\n</VERIFICATION NOTE> */\n/// Compute `a^2`\n#[inline(always)]\n#[rustfmt::skip]  // keep alignment of calculations\npub(crate) fn square_internal(a: &Scalar52) -> (z: [u128; 9])\n    requires\n        limb_prod_bounded_u128(a.limbs, a.limbs, 5),\n    ensures\n        slice128_to_nat(&z) == scalar52_to_nat(&a) * scalar52_to_nat(&a),\n        spec_mul_internal(a, a) == z,\n        limbs_bounded(&a) ==> forall|i: int| 0 <= i < 9 ==> z[i] < 5 * (1u128 << 104),","referenced_specs":["limb_prod_bounded_u128","limbs_bounded","scalar52_to_nat","slice128_to_nat","spec_mul_internal"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":972,"module":"backend","doc_comment":"","math_interpretation":"limbs_bounded(a) = > forall|i: int| 0 <= i < 9 = > z[i] < 5 * (1u128 << 104)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L931","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__square_internal"},{"name":"sub","display_name":"Scalar52::sub","impl_type":"Scalar52","contract":"pub fn sub(a: &Scalar52, b: &Scalar52) -> (s: Scalar52)\n    requires\n// Relaxed bound: limbs 0-3 bounded, limb 4 can exceed 2^52 by up to b[4]\n\n        limbs_bounded_for_sub(a, b),\n        limbs_bounded(b),\n    ensures\n// UNCONDITIONAL: limbs are always bounded due to masking in both loops\n\n        limbs_bounded(&s),\n        // CONDITIONAL: modular correctness and canonicity only when value constraint holds\n        // -L <= (a - b) < L\n        ({\n            let diff = scalar52_to_nat(&a) as int - scalar52_to_nat(&b) as int;\n            let l = group_order() as int;\n            -l <= diff && diff < l\n        }) ==> (scalar52_to_nat(&s) == (scalar52_to_nat(&a) as int - scalar52_to_nat(&b) as int)\n            % (group_order() as int)),\n        ({\n            let diff = scalar52_to_nat(&a) as int - scalar52_to_nat(&b) as int;\n            let l = group_order() as int;\n            -l <= diff && diff < l\n        }) ==> is_canonical_scalar52(&s),","referenced_specs":["group_order","is_canonical_scalar52","limbs_bounded","limbs_bounded_for_sub","scalar52_to_nat"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":749,"module":"backend","doc_comment":"Compute `a - b` (mod l)\n\nPRECONDITION RELAXATION: `a` doesn't need to be fully bounded.\nLimbs 0-3 must be < 2^52, but limb 4 can be up to 2^52 + b[4].\nThis is needed for montgomery_reduce where the intermediate has r4 > 2^52.","math_interpretation":"limbs_bounded(s)","informal_interpretation":"Compute `a - b` (mod l)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L714","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__sub"},{"name":"zeroize","display_name":"Scalar52::zeroize","impl_type":"Scalar52","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 5 ==> self.limbs[i] == 0,","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":114,"module":"backend","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 5 = > self.limbs[i] = 0","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L107","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar52__zeroize"},{"name":"multiscalar_mul_verus","display_name":"Straus::multiscalar_mul_verus","impl_type":"Straus","contract":"pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result: EdwardsPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<EdwardsPoint>,\n    I: Iterator<Item = S>,\n    J: Iterator<Item = P>,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>(\n            points,\n        ).len(),\n        // All input points must be well-formed\n        forall|i: int|\n            0 <= i < spec_points_from_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_points_from_iter::<P, J>(points)[i],\n            ),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        edwards_point_as_affine(result) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_points_from_iter::<P, J>(points),\n        ),","referenced_specs":["edwards_point_as_affine","is_well_formed_edwards_point","spec_points_from_iter","spec_scalars_from_iter","sum_of_scalar_muls"],"file":"curve25519-dalek/src/backend/serial/scalar_mul/straus.rs","line":453,"module":"backend","doc_comment":"Verus-compatible version of multiscalar_mul (constant-time).\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nComputes sum(scalars[i] * points[i]).","math_interpretation":"spec_points_from_iter::<P, J>(points)","informal_interpretation":"Verus-compatible version of multiscalar_mul (constant-time).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L453","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"straus__multiscalar_mul_verus"},{"name":"optional_multiscalar_mul_verus","display_name":"Straus::optional_multiscalar_mul_verus","impl_type":"Straus","contract":"pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where S: Borrow<Scalar>, I: Iterator<Item = S>, J: Iterator<Item = Option<EdwardsPoint>>\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some if and only if all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),","referenced_specs":["all_points_some","edwards_point_as_affine","is_well_formed_edwards_point","spec_optional_points_from_iter","spec_scalars_from_iter","sum_of_scalar_muls","unwrap_points"],"file":"curve25519-dalek/src/backend/serial/scalar_mul/straus.rs","line":269,"module":"backend","doc_comment":"Verus-compatible version of optional_multiscalar_mul.\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nComputes sum(scalars[i] * points[i]) for all i where points[i] is Some.","math_interpretation":"result.is_some() < = > all_points_some(spec_optional_points_from_iter::<J>(points))","informal_interpretation":"Verus-compatible version of optional_multiscalar_mul.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/straus.rs#L269","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"straus__optional_multiscalar_mul_verus"},{"name":"load8_at","display_name":"load8_at","impl_type":"","contract":"pub(super) const fn load8_at(input: &[u8], i: usize) -> (r: u64)\n    requires\n        i + 7 < input.len(),\n    ensures\n        r as nat == spec_load8_at(input, i),","referenced_specs":["spec_load8_at"],"file":"curve25519-dalek/src/backend/serial/u64/field.rs","line":140,"module":"backend","doc_comment":"","math_interpretation":"r = spec_load8_at(input, i)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/field.rs#L140","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"backend__load8_at"},{"name":"m","display_name":"m","impl_type":"","contract":"fn m(x: u64, y: u64) -> (z: u128)\n    ensures\n        (z as nat) == (x as nat) * (y as nat),","referenced_specs":[],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":148,"module":"backend","doc_comment":"u64 * u64 = u128 multiply helper","math_interpretation":"u64 * u64 = u128 multiply helper","informal_interpretation":"u64 * u64 = u128 multiply helper","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L141","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"backend__m"},{"name":"mul","display_name":"mul","impl_type":"","contract":"pub(crate) fn mul(point: &EdwardsPoint, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n// as_radix_16 requires scalar.bytes[31] <= 127 (MSB clear, i.e. scalar < 2^255)\n\n        scalar.bytes[31] <= 127,\n        // Input point must be well-formed (valid coordinates with proper limb bounds)\n        is_well_formed_edwards_point(*point),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result represents scalar * point\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*point),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat"],"file":"curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs","line":29,"module":"backend","doc_comment":"Perform constant-time, variable-base scalar multiplication.\nComputes scalar * point on the Ed25519 curve.","math_interpretation":"result well-formed","informal_interpretation":"Perform constant-time, variable-base scalar multiplication.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/variable_base.rs#L29","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"backend__mul_L29"},{"name":"mul","display_name":"mul","impl_type":"","contract":"pub fn mul(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> (out: EdwardsPoint)\n    requires\n// Input point must be well-formed\n\n        is_well_formed_edwards_point(*A),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(out),\n        // Functional correctness: out = a*A + b*B where B is the Ed25519 basepoint\n        edwards_point_as_affine(out) == {\n            let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_to_nat(a));\n            let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_to_nat(b));\n            edwards_add(aA.0, aA.1, bB.0, bB.1)\n        },","referenced_specs":["edwards_add","edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs","line":42,"module":"backend","doc_comment":"Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.","math_interpretation":"out well-formed","informal_interpretation":"Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/scalar_mul/vartime_double_base.rs#L42","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"backend__mul_L42"},{"name":"part1","display_name":"part1","impl_type":"","contract":"///     fn part1(sum: u128) -> (u128, u64) {\n///         let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n///         ((sum + m(p, constants::L[0])) >> 52, p)\n///     }\n///     #[inline(always)]\n///     fn part2(sum: u128) -> (u128, u64) {\n///         let w = (sum as u64) & ((1u64 << 52) - 1);\n///         (sum >> 52, w)\n///     }\n///     // note: l[3] is zero, so its multiples can be skipped\n///     let l = &constants::L;\n///     // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n///     let (carry, n0) = part1(        limbs[0]);\n///     let (carry, n1) = part1(carry + limbs[1] + m(n0, l[1]));\n///     let (carry, n2) = part1(carry + limbs[2] + m(n0, l[2]) + m(n1, l[1]));\n///     let (carry, n3) = part1(carry + limbs[3]               + m(n1, l[2]) + m(n2, l[1]));\n///     let (carry, n4) = part1(carry + limbs[4] + m(n0, l[4])               + m(n2, l[2]) + m(n3, l[1]));\n///     // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n///     let (carry, r0) = part2(carry + limbs[5]               + m(n1, l[4])               + m(n3, l[2])   + m(n4, l[1]));\n///     let (carry, r1) = part2(carry + limbs[6]                             + m(n2,l[4])                  + m(n4, l[2]));\n///     let (carry, r2) = part2(carry + limbs[7]                                           + m(n3, l[4])                );\n///     let (carry, r3) = part2(carry + limbs[8]                                                           + m(n4, l[4]));\n///     let         r4 = carry as u64;\n///     // result may be >= l, so attempt to subtract l\n///     Scalar52::sub(&Scalar52([r0, r1, r2, r3, r4]), l)\n/// }\n</ORIGINAL CODE> */\n/// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n///\n/// # Preconditions\n/// - `montgomery_reduce_input_bounds(limbs)`: Per-limb bounds for overflow-safe computation\n/// - `montgomery_reduce_canonical_bound(limbs)`: T < R×L (HAC 14.32's value constraint)\n///\n/// # Postconditions (all unconditional given preconditions)\n/// - `limbs_bounded(&result)`: Result limbs are bounded (< 2^52)\n/// - `montgomery_congruent(&result, limbs)`: (result × R) ≡ T (mod L)\n/// - `is_canonical_scalar52(&result)`: result < L\n///\n/// # Note\n/// The `canonical_bound` precondition corresponds to HAC Algorithm 14.32's requirement\n/// that T < m×R for correct Montgomery reduction. This ensures intermediate < 2L,\n/// which is needed for sub's correctness and the r4 < 2^52 + L[4] bound.\n/// HAC is at https://cacr.uwaterloo.ca/hac/about/chap14.pdf\n/// The `input_bounds` precondition ensures no overflow in u128 arithmetic.\n#[inline(always)]\n#[rustfmt::skip]  // keep alignment of n* and r* calculations\npub(crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    requires\n// Per-limb bounds for overflow-safe u128 arithmetic\n\n        montgomery_reduce_input_bounds(limbs),\n        // HAC 14.32's value constraint: T < R×L ensures intermediate < 2L\n        montgomery_reduce_canonical_bound(limbs),\n    ensures\n// All postconditions are now unconditional (given preconditions)\n\n        limbs_bounded(&result),\n        montgomery_congruent(&result, limbs),\n        is_canonical_scalar52(&result),","referenced_specs":["is_canonical_scalar52","limbs_bounded","montgomery_congruent","montgomery_reduce_canonical_bound","montgomery_reduce_input_bounds","p"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1068,"module":"backend","doc_comment":"pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {\n#[inline(always)]","math_interpretation":"montgomery_congruent(result, limbs)","informal_interpretation":"pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1050","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"backend__part1"},{"name":"part2","display_name":"part2","impl_type":"","contract":"///     fn part2(sum: u128) -> (u128, u64) {\n///         let w = (sum as u64) & ((1u64 << 52) - 1);\n///         (sum >> 52, w)\n///     }\n///     // note: l[3] is zero, so its multiples can be skipped\n///     let l = &constants::L;\n///     // the first half computes the Montgomery adjustment factor n, and begins adding n*l to make limbs divisible by R\n///     let (carry, n0) = part1(        limbs[0]);\n///     let (carry, n1) = part1(carry + limbs[1] + m(n0, l[1]));\n///     let (carry, n2) = part1(carry + limbs[2] + m(n0, l[2]) + m(n1, l[1]));\n///     let (carry, n3) = part1(carry + limbs[3]               + m(n1, l[2]) + m(n2, l[1]));\n///     let (carry, n4) = part1(carry + limbs[4] + m(n0, l[4])               + m(n2, l[2]) + m(n3, l[1]));\n///     // limbs is divisible by R now, so we can divide by R by simply storing the upper half as the result\n///     let (carry, r0) = part2(carry + limbs[5]               + m(n1, l[4])               + m(n3, l[2])   + m(n4, l[1]));\n///     let (carry, r1) = part2(carry + limbs[6]                             + m(n2,l[4])                  + m(n4, l[2]));\n///     let (carry, r2) = part2(carry + limbs[7]                                           + m(n3, l[4])                );\n///     let (carry, r3) = part2(carry + limbs[8]                                                           + m(n4, l[4]));\n///     let         r4 = carry as u64;\n///     // result may be >= l, so attempt to subtract l\n///     Scalar52::sub(&Scalar52([r0, r1, r2, r3, r4]), l)\n/// }\n</ORIGINAL CODE> */\n/// Compute `limbs/R` (mod l), where R is the Montgomery modulus 2^260\n///\n/// # Preconditions\n/// - `montgomery_reduce_input_bounds(limbs)`: Per-limb bounds for overflow-safe computation\n/// - `montgomery_reduce_canonical_bound(limbs)`: T < R×L (HAC 14.32's value constraint)\n///\n/// # Postconditions (all unconditional given preconditions)\n/// - `limbs_bounded(&result)`: Result limbs are bounded (< 2^52)\n/// - `montgomery_congruent(&result, limbs)`: (result × R) ≡ T (mod L)\n/// - `is_canonical_scalar52(&result)`: result < L\n///\n/// # Note\n/// The `canonical_bound` precondition corresponds to HAC Algorithm 14.32's requirement\n/// that T < m×R for correct Montgomery reduction. This ensures intermediate < 2L,\n/// which is needed for sub's correctness and the r4 < 2^52 + L[4] bound.\n/// HAC is at https://cacr.uwaterloo.ca/hac/about/chap14.pdf\n/// The `input_bounds` precondition ensures no overflow in u128 arithmetic.\n#[inline(always)]\n#[rustfmt::skip]  // keep alignment of n* and r* calculations\npub(crate) fn montgomery_reduce(limbs: &[u128; 9]) -> (result: Scalar52)\n    requires\n// Per-limb bounds for overflow-safe u128 arithmetic\n\n        montgomery_reduce_input_bounds(limbs),\n        // HAC 14.32's value constraint: T < R×L ensures intermediate < 2L\n        montgomery_reduce_canonical_bound(limbs),\n    ensures\n// All postconditions are now unconditional (given preconditions)\n\n        limbs_bounded(&result),\n        montgomery_congruent(&result, limbs),\n        is_canonical_scalar52(&result),","referenced_specs":["is_canonical_scalar52","limbs_bounded","montgomery_congruent","montgomery_reduce_canonical_bound","montgomery_reduce_input_bounds"],"file":"curve25519-dalek/src/backend/serial/u64/scalar.rs","line":1073,"module":"backend","doc_comment":"pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {\n#[inline(always)]\nfn part1(sum: u128) -> (u128, u64) {\nlet p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);\n((sum + m(p, constants::L[0])) >> 52, p)\n}\n#[inline(always)]","math_interpretation":"let p = (sum as u64).wrapping_mul(constants::LFACTOR) & ((1u64 << 52) - 1);","informal_interpretation":"pub (crate) fn montgomery_reduce(limbs: &[u128; 9]) -> Scalar52 {","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/backend/serial/u64/scalar.rs#L1121","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"backend__part2"},{"name":"as_bytes","display_name":"CompressedEdwardsY::as_bytes","impl_type":"CompressedEdwardsY","contract":"pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == self.0,","referenced_specs":[],"file":"curve25519-dalek/src/edwards.rs","line":257,"module":"edwards","doc_comment":"View this `CompressedEdwardsY` as an array of bytes.","math_interpretation":"&CompressedEdwardsY -> &[u8; 32]","informal_interpretation":"Returns the byte representation of a compressed Edwards Y point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L255","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressededwardsy__as_bytes"},{"name":"ct_eq","display_name":"CompressedEdwardsY::ct_eq","impl_type":"CompressedEdwardsY","contract":"fn ct_eq(&self, other: &CompressedEdwardsY) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.0 == other.0),","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/edwards.rs","line":233,"module":"edwards","doc_comment":"","math_interpretation":"result = (self.0 = other.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L231","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"compressededwardsy__ct_eq"},{"name":"decompress","display_name":"CompressedEdwardsY::decompress","impl_type":"CompressedEdwardsY","contract":"pub fn decompress(&self) -> (result: Option<\n    EdwardsPoint,\n>)\n// The compressed point must have a valid sign bit. This is automatically\n// satisfied for points produced by `compress()`. For externally-sourced\n// bytes (e.g., from network input), callers must ensure this invariant.\n//\n// See `compressed_y_has_valid_sign_bit` in `edwards_specs.rs` for full justification.\n\n    requires\n        compressed_y_has_valid_sign_bit(&self.0),\n    ensures\n// Decompression succeeds iff the y-coordinate is valid\n\n        math_is_valid_y_coordinate(spec_field_element_from_bytes(&self.0))\n            <==> result.is_some(),\n        // When successful, the result has these properties:\n        result.is_some() ==> (\n        // The Y coordinate matches the one from the compressed representation\n        spec_field_element(&result.unwrap().Y) == spec_field_element_from_bytes(\n            &self.0,\n        )\n        // The point is valid on the Edwards curve\n         && is_valid_edwards_point(\n            result.unwrap(),\n        )\n        // The X coordinate sign bit matches the sign bit from the compressed representation\n         && spec_field_element_sign_bit(&result.unwrap().X) == (self.0[31] >> 7)),","referenced_specs":["compressed_y_has_valid_sign_bit","is_valid_edwards_point","math_is_valid_y_coordinate","spec_field_element","spec_field_element_from_bytes","spec_field_element_sign_bit"],"file":"curve25519-dalek/src/edwards.rs","line":277,"module":"edwards","doc_comment":"Attempt to decompress to an `EdwardsPoint`.\n\nReturns `None` if the input is not the \\\\(y\\\\)-coordinate of a\ncurve point.\n","math_interpretation":"[u8; 32] -> Option<P in E(F_p)>","informal_interpretation":"Decompresses a 32-byte encoding to an Edwards point (if valid).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L275","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressededwardsy__decompress"},{"name":"identity","display_name":"CompressedEdwardsY::identity","impl_type":"CompressedEdwardsY","contract":"fn identity() -> (result: CompressedEdwardsY)\n    ensures\n// Identity point has y = 1 and sign bit = 0\n\n        spec_field_element_from_bytes(&result.0) == 1,\n        (result.0[31] >> 7) == 0,","referenced_specs":["spec_field_element_from_bytes"],"file":"curve25519-dalek/src/edwards.rs","line":761,"module":"edwards","doc_comment":"","math_interpretation":"spec_field_element_from_bytes(result.0) = 1","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L749","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"compressededwardsy__identity"},{"name":"to_bytes","display_name":"CompressedEdwardsY::to_bytes","impl_type":"CompressedEdwardsY","contract":"pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,","referenced_specs":[],"file":"curve25519-dalek/src/edwards.rs","line":265,"module":"edwards","doc_comment":"Copy this `CompressedEdwardsY` to an array of bytes.","math_interpretation":"result = self.0","informal_interpretation":"Copy this `CompressedEdwardsY` to an array of bytes.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L263","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"compressededwardsy__to_bytes"},{"name":"zeroize","display_name":"CompressedEdwardsY::zeroize","impl_type":"CompressedEdwardsY","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        self.0[0]\n            == 1u8,\n// VERIFICATION NOTE: this \"zeroize\" leaves one bit equal to 1","referenced_specs":[],"file":"curve25519-dalek/src/edwards.rs","line":970,"module":"edwards","doc_comment":"Reset this `CompressedEdwardsY` to the compressed form of the identity element.","math_interpretation":"forall|i: int| 1 <= i < 32 = > #[trigger] self.0[i] = 0u8","informal_interpretation":"Reset this `CompressedEdwardsY` to the compressed form of the identity element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L958","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"compressededwardsy__zeroize"},{"name":"basepoint","display_name":"EdwardsBasepointTable::basepoint","impl_type":"EdwardsBasepointTable","contract":"fn basepoint(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result),\n        // The result is the Ed25519 basepoint B\n        edwards_point_as_affine(result) == spec_ed25519_basepoint(),","referenced_specs":["edwards_point_as_affine","is_valid_edwards_basepoint_table","is_well_formed_edwards_point","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/edwards.rs","line":3104,"module":"edwards","doc_comment":"Get the basepoint for this table as an `EdwardsPoint`.","math_interpretation":"result well-formed, // The result is the Ed25519 basepoint B aff(result) = spec_ed25519_basepoint()","informal_interpretation":"Get the basepoint for this table as an `EdwardsPoint`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3100","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardsbasepointtable__basepoint"},{"name":"create","display_name":"EdwardsBasepointTable::create","impl_type":"EdwardsBasepointTable","contract":"fn create(basepoint: &EdwardsPoint) -> (result: EdwardsBasepointTable)\n    requires\n        is_well_formed_edwards_point(*basepoint),\n    ensures\n        is_valid_edwards_basepoint_table(result, edwards_point_as_affine(*basepoint)),","referenced_specs":["edwards_point_as_affine","is_valid_edwards_basepoint_table","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2996,"module":"edwards","doc_comment":"Create a table of precomputed multiples of `basepoint`.\n\nConstructs 32 LookupTables where table.0[i] = [1·(16²)^i·B, ..., 8·(16²)^i·B]","math_interpretation":"Constructs 32 LookupTables where table.0[i] = [1·(16²)^i·B, ..., 8·(16²)^i·B]","informal_interpretation":"Create a table of precomputed multiples of `basepoint`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2992","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardsbasepointtable__create"},{"name":"mul_base","display_name":"EdwardsBasepointTable::mul_base","impl_type":"EdwardsBasepointTable","contract":"fn mul_base(&self, scalar: &Scalar) -> (result: EdwardsPoint)\n    requires\n        scalar.bytes[31] <= 127,\n        is_valid_edwards_basepoint_table(*self, spec_ed25519_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_valid_edwards_basepoint_table","is_well_formed_edwards_point","scalar_to_nat","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/edwards.rs","line":3233,"module":"edwards","doc_comment":"The computation uses Pippenger's algorithm, as described for the\nspecific case of radix-16 on page 13 of the Ed25519 paper.\n\n# Pippenger's Algorithm Generalised\n\nWrite the scalar \\\\(a\\\\) in radix-\\\\(w\\\\), where \\\\(w\\\\) is a power of\n2, with coefficients in \\\\([\\frac{-w}{2},\\frac{w}{2})\\\\), i.e.,\n$$\na = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},\n$$\nwith\n$$\n\\begin{aligned}\n\\frac{-w}{2} \\leq a_i < \\frac{w}{2}\n&&\\cdots&&\n\\frac{-w}{2} \\leq a\\_{x} \\leq \\frac{w}{2}\n\\end{aligned}\n$$\nand the number of additions, \\\\(x\\\\), is given by\n\\\\(x = \\lceil \\frac{256}{w} \\rceil\\\\). Then\n$$\na B = a\\_0 B + a\\_1 w\\^1 B + \\cdots + a\\_{x-1} w\\^{x-1} B.\n$$\nGrouping even and odd coefficients gives\n$$\n\\begin{aligned}\na B = \\quad a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B    \\\\\\\\\n+ a\\_1 w\\^1 B +& a\\_3 w\\^3 B + \\cdots + a\\_{x-1} w\\^{x-1} B    \\\\\\\\\n= \\quad(a\\_0 w\\^0 B +& a\\_2 w\\^2 B + \\cdots + a\\_{x-2} w\\^{x-2} B)   \\\\\\\\\n+ w(a\\_1 w\\^0 B +& a\\_3 w\\^2 B + \\cdots + a\\_{x-1} w\\^{x-2} B).  \\\\\\\\\n\\end{aligned}\n$$\nFor each \\\\(i = 0 \\ldots 31\\\\), we create a lookup table of\n$$\n[w\\^{2i} B, \\ldots, \\frac{w}{2}\\cdot w\\^{2i} B],\n$$\nand use it to select \\\\( y \\cdot w\\^{2i} \\cdot B \\\\) in constant time.\n\nThe radix-\\\\(w\\\\) representation requires that the scalar is bounded\nby \\\\(2\\^{255}\\\\), which is always the case.\n\nThe above algorithm is trivially generalised to other powers-of-2 radices.","math_interpretation":"a = a\\_0 + a\\_1 w\\^1 + \\cdots + a\\_{x} w\\^{x},","informal_interpretation":"The computation uses Pippenger's algorithm, as described for the","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3229","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardsbasepointtable__mul_base"},{"name":"add","display_name":"EdwardsPoint::add","impl_type":"EdwardsPoint","contract":"fn add(self, other: &'b EdwardsPoint) -> (result:\n    EdwardsPoint)/* requires clause in AddSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n        is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: affine addition law\n        ({\n            let (x1, y1) = edwards_point_as_affine(*self);\n            let (x2, y2) = edwards_point_as_affine(*other);\n            edwards_point_as_affine(result) == edwards_add(x1, y1, x2, y2)\n        }),","referenced_specs":["add","edwards_add","edwards_point_as_affine","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":1917,"module":"edwards","doc_comment":"","math_interpretation":"result well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1913","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__add_L1917"},{"name":"add_assign","display_name":"EdwardsPoint::add_assign","impl_type":"EdwardsPoint","contract":"fn add_assign(&mut self, _rhs: &'b EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*old(self)),\n        is_well_formed_edwards_point(*_rhs),\n    ensures\n        is_well_formed_edwards_point(*self),\n        // Semantic correctness: result is the addition of old(self) + rhs\n        ({\n            let (x1, y1) = edwards_point_as_affine(*old(self));\n            let (x2, y2) = edwards_point_as_affine(*_rhs);\n            edwards_point_as_affine(*self) == edwards_add(x1, y1, x2, y2)\n        }),","referenced_specs":["edwards_add","edwards_point_as_affine","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2018,"module":"edwards","doc_comment":"","math_interpretation":"self well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2014","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__add_assign"},{"name":"as_affine_niels","display_name":"EdwardsPoint::as_affine_niels","impl_type":"EdwardsPoint","contract":"pub(crate) fn as_affine_niels(&self) -> (result: AffineNielsPoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n    ensures\n        affine_niels_corresponds_to_edwards(result, *self),","referenced_specs":["affine_niels_corresponds_to_edwards","edwards_point_limbs_bounded"],"file":"curve25519-dalek/src/edwards.rs","line":1391,"module":"edwards","doc_comment":"Dehomogenize to a AffineNielsPoint.\nMainly for testing.","math_interpretation":"affine_niels_corresponds_to_edwards(result, *self)","informal_interpretation":"Dehomogenize to a AffineNielsPoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1379","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__as_affine_niels"},{"name":"as_projective","display_name":"EdwardsPoint::as_projective","impl_type":"EdwardsPoint","contract":"pub(crate) const fn as_projective(&self) -> (result: ProjectivePoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n    ensures\n        result.X == self.X,\n        result.Y == self.Y,\n        result.Z == self.Z,\n        // ProjectivePoint invariant: 52-bounded (from EdwardsPoint invariant)\n        fe51_limbs_bounded(&result.X, 52) && fe51_limbs_bounded(&result.Y, 52)\n            && fe51_limbs_bounded(&result.Z, 52),","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded"],"file":"curve25519-dalek/src/edwards.rs","line":1374,"module":"edwards","doc_comment":"Convert the representation of this point from extended\ncoordinates to projective coordinates.\n\nFree.","math_interpretation":"result.X = self.X","informal_interpretation":"Convert the representation of this point from extended","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1362","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__as_projective"},{"name":"as_projective_niels","display_name":"EdwardsPoint::as_projective_niels","impl_type":"EdwardsPoint","contract":"pub(crate) fn as_projective_niels(&self) -> (result: ProjectiveNielsPoint)\n    requires\n        edwards_point_limbs_bounded(*self),\n        sum_of_limbs_bounded(&self.Y, &self.X, u64::MAX),\n    ensures\n        projective_niels_corresponds_to_edwards(result, *self),\n        fe51_limbs_bounded(&result.Y_plus_X, 54),\n        fe51_limbs_bounded(&result.Y_minus_X, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T2d, 54),","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded","projective_niels_corresponds_to_edwards","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/edwards.rs","line":1270,"module":"edwards","doc_comment":"Convert to a ProjectiveNielsPoint","math_interpretation":"projective_niels_corresponds_to_edwards(result, *self)","informal_interpretation":"Convert to a ProjectiveNielsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1258","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__as_projective_niels"},{"name":"compress","display_name":"EdwardsPoint::compress","impl_type":"EdwardsPoint","contract":"pub fn compress(&self) -> (result: CompressedEdwardsY)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n        compressed_edwards_y_corresponds_to_edwards(result, *self),","referenced_specs":["compressed_edwards_y_corresponds_to_edwards","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":1611,"module":"edwards","doc_comment":"Compress this point to `CompressedEdwardsY` format.","math_interpretation":"P in E(F_p) -> CompressedEdwardsY","informal_interpretation":"Compresses an Edwards point to its canonical 32-byte encoding.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1599","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__compress"},{"name":"conditional_select","display_name":"EdwardsPoint::conditional_select","impl_type":"EdwardsPoint","contract":"fn conditional_select(a: &EdwardsPoint, b: &EdwardsPoint, choice: Choice) -> (result:\n    EdwardsPoint)\n    ensures\n// If choice is false (0), return a\n\n        !choice_is_true(choice) ==> result == *a,\n        // If choice is true (1), return b\n        choice_is_true(choice) ==> result == *b,\n        // Well-formedness is preserved by selection\n        is_well_formed_edwards_point(*a) && is_well_formed_edwards_point(*b)\n            ==> is_well_formed_edwards_point(result),","referenced_specs":["choice_is_true","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":1104,"module":"edwards","doc_comment":"","math_interpretation":"a well-formed && b well-formed = > result well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1092","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__conditional_select"},{"name":"ct_eq","display_name":"EdwardsPoint::ct_eq","impl_type":"EdwardsPoint","contract":"fn ct_eq(&self, other: &EdwardsPoint) -> (result:\n    Choice)/* VERIFICATION NOTE: we cannot add a \"requires\" clause to ct_eq with ConstantTimeEqSpecImpl,\n        unlike for Add trait implementations through AddSpecImpl.\n    */\n// requires self.ct_eq_req(other),\n\n    ensures\n// Two points are equal if they represent the same affine point:\n// (X/Z, Y/Z) == (X'/Z', Y'/Z')\n// This is checked by verifying X*Z' == X'*Z and Y*Z' == Y'*Z\n\n        choice_is_true(result) == (edwards_point_as_affine(*self) == edwards_point_as_affine(\n            *other,\n        )),","referenced_specs":["add","choice_is_true","ct_eq_req","edwards_point_as_affine"],"file":"curve25519-dalek/src/edwards.rs","line":1164,"module":"edwards","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1152","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__ct_eq"},{"name":"double","display_name":"EdwardsPoint::double","impl_type":"EdwardsPoint","contract":"pub(crate) fn double(&self) -> (result: EdwardsPoint)\n    requires\n        is_valid_edwards_point(*self),  // self is a valid extended Edwards point\n        edwards_point_limbs_bounded(*self),\n    ensures\n        is_valid_edwards_point(result),  // result is also a valid Edwards point\n        // Result equals the affine doubling of the input.\n        edwards_point_as_affine(result) == edwards_double(\n            edwards_point_as_affine(*self).0,\n            edwards_point_as_affine(*self).1,\n        ),","referenced_specs":["edwards_double","edwards_point_as_affine","edwards_point_limbs_bounded","is_valid_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":1845,"module":"edwards","doc_comment":"Add this point to itself.","math_interpretation":"aff(self).1","informal_interpretation":"Add this point to itself.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1841","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__double"},{"name":"identity","display_name":"EdwardsPoint::identity","impl_type":"EdwardsPoint","contract":"fn identity() -> (result: EdwardsPoint)\n    ensures\n        is_identity_edwards_point(result),\n        is_well_formed_edwards_point(result),","referenced_specs":["is_identity_edwards_point","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":898,"module":"edwards","doc_comment":"","math_interpretation":"result = O, result well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L886","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__identity"},{"name":"is_small_order","display_name":"EdwardsPoint::is_small_order","impl_type":"EdwardsPoint","contract":"pub fn is_small_order(&self) -> (result: bool)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n// A point has small order iff [8]P = O (identity)\n\n        result == (edwards_scalar_mul(edwards_point_as_affine(*self), 8)\n            == math_edwards_identity()),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","math_edwards_identity"],"file":"curve25519-dalek/src/edwards.rs","line":3731,"module":"edwards","doc_comment":"Determine if this point is of small order.\n\n# Return\n\n* `true` if `self` is in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\);\n* `false` if `self` is not in the torsion subgroup \\\\( \\mathcal E\\[8\\] \\\\).\n\n# Example\n\n```\nuse curve25519_dalek::constants;\n\n// Generator of the prime-order subgroup\nlet P = constants::ED25519_BASEPOINT_POINT;\n// Generator of the torsion subgroup\nlet Q = constants::EIGHT_TORSION[1];\n\n// P has large order\nassert_eq!(P.is_small_order(), false);\n\n// Q has small order\nassert_eq!(Q.is_small_order(), true);\n```","math_interpretation":"P in E[8]? (8-torsion test)","informal_interpretation":"Checks whether a point has small order (lies in the torsion subgroup).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3727","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__is_small_order"},{"name":"is_torsion_free","display_name":"EdwardsPoint::is_torsion_free","impl_type":"EdwardsPoint","contract":"pub fn is_torsion_free(&self) -> (result: bool)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n// A point is torsion-free iff [ℓ]P = O, where ℓ is the group order\n\n        result == (edwards_scalar_mul(edwards_point_as_affine(*self), group_order())\n            == math_edwards_identity()),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","group_order","is_well_formed_edwards_point","math_edwards_identity"],"file":"curve25519-dalek/src/edwards.rs","line":3778,"module":"edwards","doc_comment":"Determine if this point is \"torsion-free\", i.e., is contained in\nthe prime-order subgroup.\n\n# Return\n\n* `true` if `self` has zero torsion component and is in the\nprime-order subgroup;\n* `false` if `self` has a nonzero torsion component and is not\nin the prime-order subgroup.\n\n# Example\n\n```\nuse curve25519_dalek::constants;\n\n// Generator of the prime-order subgroup\nlet P = constants::ED25519_BASEPOINT_POINT;\n// Generator of the torsion subgroup\nlet Q = constants::EIGHT_TORSION[1];\n\n// P is torsion-free\nassert_eq!(P.is_torsion_free(), true);\n\n// P + Q is not torsion-free\nassert_eq!((P+Q).is_torsion_free(), false);\n```","math_interpretation":"let P = constants::ED25519_BASEPOINT_POINT;","informal_interpretation":"Determine if this point is \"torsion-free\", i.e., is contained in","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3774","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__is_torsion_free"},{"name":"is_valid","display_name":"EdwardsPoint::is_valid","impl_type":"EdwardsPoint","contract":"fn is_valid(&self) -> (result: bool)\n    requires\n        edwards_point_limbs_bounded(*self),\n        spec_field_element(&self.Z) != 0,\n    ensures\n        result == is_valid_edwards_point(*self),","referenced_specs":["edwards_point_limbs_bounded","is_valid_edwards_point","spec_field_element"],"file":"curve25519-dalek/src/edwards.rs","line":1008,"module":"edwards","doc_comment":"","math_interpretation":"result = self on curve","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L996","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__is_valid"},{"name":"mul","display_name":"EdwardsPoint::mul","impl_type":"EdwardsPoint","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    EdwardsPoint)/* requires clause in MulSpecImpl<&Scalar> for &EdwardsPoint in arithm_trait_specs.rs:\n        requires rhs.bytes[31] <= 127 && is_well_formed_edwards_point(*self)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat"],"file":"curve25519-dalek/src/edwards.rs","line":2470,"module":"edwards","doc_comment":"Scalar multiplication: compute `scalar * self`.\n\nFor scalar multiplication of a basepoint,\n`EdwardsBasepointTable` is approximately 4x faster.","math_interpretation":"result well-formed, aff(result) = edwards_scalar_mul( aff(self), nat(scalar), )","informal_interpretation":"Scalar multiplication: compute `scalar * self`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2466","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul"},{"name":"mul_assign","display_name":"EdwardsPoint::mul_assign","impl_type":"EdwardsPoint","contract":"fn mul_assign(&mut self, scalar: &'b Scalar)\n    requires\n        scalar.bytes[31] <= 127,\n        is_well_formed_edwards_point(*old(self)),\n    ensures\n        is_well_formed_edwards_point(*self),\n        edwards_point_as_affine(*self) == edwards_scalar_mul(\n            edwards_point_as_affine(*old(self)),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat"],"file":"curve25519-dalek/src/edwards.rs","line":2437,"module":"edwards","doc_comment":"","math_interpretation":"self well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2433","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_assign"},{"name":"mul_base","display_name":"EdwardsPoint::mul_base","impl_type":"EdwardsPoint","contract":"pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [scalar] * B where B is the basepoint\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/edwards.rs","line":2514,"module":"edwards","doc_comment":"Fixed-base scalar multiplication by the Ed25519 base point.\n\nUses precomputed basepoint tables when the `precomputed-tables` feature\nis enabled, trading off increased code size for ~4x better performance.","math_interpretation":"result well-formed","informal_interpretation":"Fixed-base scalar multiplication by the Ed25519 base point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2510","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_base"},{"name":"mul_base_clamped","display_name":"EdwardsPoint::mul_base_clamped","impl_type":"EdwardsPoint","contract":"pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [clamped_scalar] * B where B is the basepoint\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            spec_ed25519_basepoint(),\n            scalar_to_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_clamp_integer","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/edwards.rs","line":2573,"module":"edwards","doc_comment":"Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].","math_interpretation":"result well-formed","informal_interpretation":"Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2569","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_base_clamped"},{"name":"mul_by_cofactor","display_name":"EdwardsPoint::mul_by_cofactor","impl_type":"EdwardsPoint","contract":"pub fn mul_by_cofactor(&self) -> (result: EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [8]P\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            8,\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":3608,"module":"edwards","doc_comment":"Multiply by the cofactor: return \\\\(\\[8\\]P\\\\).","math_interpretation":"P -> [8]P (cofactor clearing)","informal_interpretation":"Multiplies a point by the cofactor (8) to clear the torsion component.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3604","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_by_cofactor"},{"name":"mul_by_pow_2","display_name":"EdwardsPoint::mul_by_pow_2","impl_type":"EdwardsPoint","contract":"pub(crate) fn mul_by_pow_2(&self, k: u32) -> (result: EdwardsPoint)\n    requires\n        k > 0,\n        is_well_formed_edwards_point(*self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = [2^k]P\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            pow2(k as nat),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":3632,"module":"edwards","doc_comment":"Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).","math_interpretation":"result well-formed","informal_interpretation":"Compute \\\\([2\\^k] P \\\\) by successive doublings. Requires \\\\( k > 0 \\\\).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L3628","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_by_pow_2"},{"name":"mul_clamped","display_name":"EdwardsPoint::mul_clamped","impl_type":"EdwardsPoint","contract":"pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n    requires\n        is_well_formed_edwards_point(self),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Result is scalar multiplication of self by the clamped scalar\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(self),\n            scalar_to_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_clamp_integer"],"file":"curve25519-dalek/src/edwards.rs","line":2538,"module":"edwards","doc_comment":"Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].","math_interpretation":"result well-formed","informal_interpretation":"Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2534","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__mul_clamped"},{"name":"multiscalar_mul_verus","display_name":"EdwardsPoint::multiscalar_mul_verus","impl_type":"EdwardsPoint","contract":"pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result: EdwardsPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<EdwardsPoint>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = P> + Clone,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_points_from_iter::<P, J>(\n            points,\n        ).len(),\n        // All input points must be well-formed\n        forall|i: int|\n            0 <= i < spec_points_from_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_points_from_iter::<P, J>(points)[i],\n            ),\n    ensures\n// Result is a well-formed Edwards point\n\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        edwards_point_as_affine(result) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_points_from_iter::<P, J>(points),\n        ),","referenced_specs":["edwards_point_as_affine","is_well_formed_edwards_point","spec_points_from_iter","spec_scalars_from_iter","sum_of_scalar_muls"],"file":"curve25519-dalek/src/edwards.rs","line":2862,"module":"edwards","doc_comment":"Verus-compatible version of multiscalar_mul (constant-time).\nUses Iterator instead of IntoIterator (Verus doesn't support I::Item projections).\nDispatches to Straus algorithm (constant-time).","math_interpretation":"spec_points_from_iter::<P, J>(points)","informal_interpretation":"Verus-compatible version of multiscalar_mul (constant-time).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2858","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__multiscalar_mul_verus"},{"name":"neg","display_name":"EdwardsPoint::neg","impl_type":"EdwardsPoint","contract":"fn neg(self) -> (result:\n    EdwardsPoint)\n// requires clause in NegSpecImpl for &EdwardsPoint above:\n//   is_well_formed_edwards_point(*self)\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(*self)),","referenced_specs":["edwards_neg","edwards_point_as_affine","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2310,"module":"edwards","doc_comment":"","math_interpretation":"P -> -P in E(F_p)","informal_interpretation":"Negates an Edwards point (group inverse).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2306","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__neg_L2310"},{"name":"neg","display_name":"EdwardsPoint::neg","impl_type":"EdwardsPoint","contract":"fn neg(self) -> (result:\n    EdwardsPoint)\n// requires clause in NegSpecImpl for EdwardsPoint above:\n//   fe51_limbs_bounded(&self.X, 52) && fe51_limbs_bounded(&self.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_neg(edwards_point_as_affine(self)),","referenced_specs":["edwards_neg","edwards_point_as_affine","fe51_limbs_bounded","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2415,"module":"edwards","doc_comment":"","math_interpretation":"P -> -P in E(F_p)","informal_interpretation":"Negates an Edwards point (group inverse).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2411","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__neg_L2415"},{"name":"nonspec_map_to_curve_verus","display_name":"EdwardsPoint::nonspec_map_to_curve_verus","impl_type":"EdwardsPoint","contract":"pub fn nonspec_map_to_curve_verus(bytes: &[u8]) -> (result: EdwardsPoint)\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = spec applied to first 32 bytes of SHA-512(input)\n        edwards_point_as_affine(result) == spec_nonspec_map_to_curve(\n            spec_sha512(bytes@).subrange(0, 32),\n        ),","referenced_specs":["edwards_point_as_affine","is_well_formed_edwards_point","spec_nonspec_map_to_curve","spec_sha512"],"file":"curve25519-dalek/src/edwards.rs","line":1765,"module":"edwards","doc_comment":"VERIFICATION NOTE: Verus-compatible version of nonspec_map_to_curve that uses SHA-512 instead of Digest.","math_interpretation":"result well-formed","informal_interpretation":"VERIFICATION NOTE: Verus-compatible version of nonspec_map_to_curve that uses SHA-512 instead of Digest.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1753","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"edwardspoint__nonspec_map_to_curve_verus"},{"name":"optional_multiscalar_mul_verus","display_name":"EdwardsPoint::optional_multiscalar_mul_verus","impl_type":"EdwardsPoint","contract":"pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    EdwardsPoint,\n>) where\n    S: Borrow<Scalar>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = Option<EdwardsPoint>> + Clone,\n\n    requires\n// Same number of scalars and points\n\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_optional_points_from_iter::<J>(\n            points,\n        ).len(),\n        // All input points (when Some) must be well-formed\n        forall|i: int|\n            0 <= i < spec_optional_points_from_iter::<J>(points).len() && (\n            #[trigger] spec_optional_points_from_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_points_from_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n// Result is Some if and only if all input points are Some\n\n        result.is_some() <==> all_points_some(spec_optional_points_from_iter::<J>(points)),\n        // If result is Some, it is a well-formed Edwards point\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap()),\n        // Semantic correctness: result = sum(scalars[i] * points[i])\n        result.is_some() ==> edwards_point_as_affine(result.unwrap()) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_points_from_iter::<J>(points)),\n        ),","referenced_specs":["all_points_some","edwards_point_as_affine","is_well_formed_edwards_point","spec_optional_points_from_iter","spec_scalars_from_iter","sum_of_scalar_muls","unwrap_points"],"file":"curve25519-dalek/src/edwards.rs","line":2781,"module":"edwards","doc_comment":"Verus-compatible version of optional_multiscalar_mul.\nUses Iterator + Clone instead of IntoIterator (Verus doesn't support I::Item projections).\nClone allows peeking at size without consuming the iterator (similar to original's size_hint).\nDispatches to Straus (size < 190) or Pippenger (size >= 190) algorithm.","math_interpretation":"result.is_some() < = > all_points_some(spec_optional_points_from_iter::<J>(points))","informal_interpretation":"Verus-compatible version of optional_multiscalar_mul.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2777","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__optional_multiscalar_mul_verus"},{"name":"sub","display_name":"EdwardsPoint::sub","impl_type":"EdwardsPoint","contract":"fn sub(self, other: &'b EdwardsPoint) -> (result:\n    EdwardsPoint)/* requires clause in SubSpecImpl<&EdwardsPoint> for &EdwardsPoint above:\n        is_well_formed_edwards_point(*self) && is_well_formed_edwards_point(*rhs)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        // Semantic correctness: affine subtraction law\n        ({\n            let (x1, y1) = edwards_point_as_affine(*self);\n            let (x2, y2) = edwards_point_as_affine(*other);\n            edwards_point_as_affine(result) == edwards_sub(x1, y1, x2, y2)\n        }),","referenced_specs":["edwards_point_as_affine","edwards_sub","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2061,"module":"edwards","doc_comment":"","math_interpretation":"let (x1, y1) = aff(self); let (x2, y2) = aff(other); aff(result) = edwards_sub(x1, y1, x2, y2)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2057","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__sub_L2061"},{"name":"sub_assign","display_name":"EdwardsPoint::sub_assign","impl_type":"EdwardsPoint","contract":"fn sub_assign(&mut self, _rhs: &'b EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*old(self)),\n        is_well_formed_edwards_point(*_rhs),\n    ensures\n        is_well_formed_edwards_point(*self),\n        // Semantic correctness: result is the subtraction of old(self) - rhs\n        ({\n            let (x1, y1) = edwards_point_as_affine(*old(self));\n            let (x2, y2) = edwards_point_as_affine(*_rhs);\n            edwards_point_as_affine(*self) == edwards_sub(x1, y1, x2, y2)\n        }),","referenced_specs":["edwards_point_as_affine","edwards_sub","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/edwards.rs","line":2156,"module":"edwards","doc_comment":"","math_interpretation":"self well-formed","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2152","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__sub_assign"},{"name":"sum","display_name":"EdwardsPoint::sum","impl_type":"EdwardsPoint","contract":"fn sum<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,","referenced_specs":[],"file":"curve25519-dalek/src/edwards.rs","line":2235,"module":"edwards","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2264","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__sum"},{"name":"to_montgomery","display_name":"EdwardsPoint::to_montgomery","impl_type":"EdwardsPoint","contract":"pub fn to_montgomery(&self) -> (result: MontgomeryPoint)\n    requires\n        is_valid_edwards_point(*self),  // Gives us z != 0 for birational map\n        fe51_limbs_bounded(&self.X, 54),\n        // Y and Z need 51-bit bounds so U = Z + Y is 52-bit bounded (< 54 for mul)\n        fe51_limbs_bounded(&self.Y, 51) && fe51_limbs_bounded(&self.Z, 51),\n        sum_of_limbs_bounded(&self.Z, &self.Y, u64::MAX),\n    ensures\n        montgomery_corresponds_to_edwards(result, *self),","referenced_specs":["fe51_limbs_bounded","is_valid_edwards_point","montgomery_corresponds_to_edwards","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/edwards.rs","line":1468,"module":"edwards","doc_comment":"Convert this `EdwardsPoint` on the Edwards model to the\ncorresponding `MontgomeryPoint` on the Montgomery model.\n\nThis function has one exceptional case; the identity point of\nthe Edwards curve is sent to the 2-torsion point \\\\((0,0)\\\\)\non the Montgomery curve.\n\nNote that this is a one-way conversion, since the Montgomery\nmodel does not retain sign information.","math_interpretation":"u = (1+y)/(1-y), birational map E -> M","informal_interpretation":"Converts an Edwards point to its Montgomery u-coordinate.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L1456","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__to_montgomery"},{"name":"vartime_double_scalar_mul_basepoint","display_name":"EdwardsPoint::vartime_double_scalar_mul_basepoint","impl_type":"EdwardsPoint","contract":"pub fn vartime_double_scalar_mul_basepoint(a: &Scalar, A: &EdwardsPoint, b: &Scalar) -> (result:\n    EdwardsPoint)\n    requires\n        is_well_formed_edwards_point(*A),\n    ensures\n        is_well_formed_edwards_point(result),\n        // Functional correctness: result = a*A + b*B where B is the Ed25519 basepoint\n        edwards_point_as_affine(result) == {\n            let aA = edwards_scalar_mul(edwards_point_as_affine(*A), scalar_to_nat(a));\n            let bB = edwards_scalar_mul(spec_ed25519_basepoint(), scalar_to_nat(b));\n            edwards_add(aA.0, aA.1, bB.0, bB.1)\n        },","referenced_specs":["edwards_add","edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ed25519_basepoint"],"file":"curve25519-dalek/src/edwards.rs","line":2735,"module":"edwards","doc_comment":"Compute \\\\(aA + bB\\\\) in variable time, where \\\\(B\\\\) is the Ed25519 basepoint.","math_interpretation":"(a,A,b) -> [a]A + [b]B, B = Ed25519 basepoint","informal_interpretation":"Computes a double scalar multiplication with the basepoint (variable-time).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2731","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"edwardspoint__vartime_double_scalar_mul_basepoint"},{"name":"zeroize","display_name":"EdwardsPoint::zeroize","impl_type":"EdwardsPoint","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 1 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        self.0[0]\n            == 1u8,\n// VERIFICATION NOTE: this \"zeroize\" leaves one bit equal to 1","referenced_specs":[],"file":"curve25519-dalek/src/edwards.rs","line":970,"module":"edwards","doc_comment":"Reset this `CompressedEdwardsY` to the compressed form of the identity element.","math_interpretation":"forall|i: int| 1 <= i < 32 = > #[trigger] self.0[i] = 0u8","informal_interpretation":"Reset this `CompressedEdwardsY` to the compressed form of the identity element.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L978","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwardspoint__zeroize"},{"name":"mul","display_name":"Scalar::mul","impl_type":"Scalar","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    EdwardsPoint)/* requires clause in MulSpecImpl<&Scalar> for &EdwardsPoint in arithm_trait_specs.rs:\n        requires rhs.bytes[31] <= 127 && is_well_formed_edwards_point(*self)\n    */\n\n    ensures\n        is_well_formed_edwards_point(result),\n        edwards_point_as_affine(result) == edwards_scalar_mul(\n            edwards_point_as_affine(*self),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat"],"file":"curve25519-dalek/src/edwards.rs","line":2470,"module":"edwards","doc_comment":"Scalar multiplication: compute `scalar * self`.\n\nFor scalar multiplication of a basepoint,\n`EdwardsBasepointTable` is approximately 4x faster.","math_interpretation":"result well-formed, aff(result) = edwards_scalar_mul( aff(self), nat(scalar), )","informal_interpretation":"Scalar multiplication: compute `scalar * self`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L2489","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__mul_L2470"},{"name":"step_1","display_name":"step_1","impl_type":"","contract":"pub(super) fn step_1(repr: &CompressedEdwardsY) -> (result: (\n    Choice,\n    FieldElement,\n    FieldElement,\n    FieldElement,\n))  // Result components: (is_valid, X, Y, Z)\n    ensures\n// The returned Y field element matches the one extracted from the compressed representation\n\n        ({\n            let (is_valid, X, Y, Z) = result;\n            spec_field_element(&Y) == spec_field_element_from_bytes(&repr.0)\n                &&\n            // The returned Z field element is 1\n            spec_field_element(&Z) == 1\n                &&\n            // The choice is true iff the Y is valid and (X, Y) is on the curve\n            (choice_is_true(is_valid) <==> math_is_valid_y_coordinate(spec_field_element(&Y)))\n                && (choice_is_true(is_valid) ==> math_on_edwards_curve(\n                spec_field_element(&X),\n                spec_field_element(&Y),\n            )) &&\n            // Limb bounds for step_2\n            // X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n            fe51_limbs_bounded(&X, 52) && fe51_limbs_bounded(&Y, 51) && fe51_limbs_bounded(\n                &Z,\n                51,\n            )\n                &&\n            // X is the non-negative root (LSB = 0) - from sqrt_ratio_i\n            // This is needed in the proof of decompress\n            spec_field_element(&X) % 2 == 0\n        }),","referenced_specs":["choice_is_true","fe51_limbs_bounded","math_is_valid_y_coordinate","math_on_edwards_curve","spec_field_element","spec_field_element_from_bytes"],"file":"curve25519-dalek/src/edwards.rs","line":352,"module":"edwards","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L350","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwards__step_1"},{"name":"step_2","display_name":"step_2","impl_type":"","contract":"pub(super) fn step_2(\n    repr: &CompressedEdwardsY,\n    mut X: FieldElement,\n    Y: FieldElement,\n    Z: FieldElement,\n) -> (result: EdwardsPoint)\n    requires\n// Limb bounds for inputs (X from sqrt_ratio_i, Y from from_bytes, Z = ONE)\n// X is 52-bit bounded from sqrt_ratio_i (relaxed from 51)\n\n        fe51_limbs_bounded(&X, 52),\n        fe51_limbs_bounded(&Y, 51),\n        fe51_limbs_bounded(&Z, 51),\n    ensures\n        spec_field_element(&result.X)\n            ==\n        // If the sign bit is 1, negate the X field element\n        if (repr.0[31] >> 7) == 1 {\n            math_field_neg(spec_field_element(&X))\n        } else {\n            spec_field_element(&X)\n        },\n        // Y and Z are unchanged\n        &result.Y == &Y && &result.Z == &Z\n            &&\n        // X is conditionally negated based on the sign bit\n        // T = X * Y (after conditional negation)\n        spec_field_element(&result.T) == math_field_mul(\n            spec_field_element(&result.X),\n            spec_field_element(&result.Y),\n        ),","referenced_specs":["fe51_limbs_bounded","math_field_mul","math_field_neg","spec_field_element"],"file":"curve25519-dalek/src/edwards.rs","line":507,"module":"edwards","doc_comment":"","math_interpretation":"spec_field_element(result.Y)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/edwards.rs#L505","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"edwards__step_2"},{"name":"batch_invert","display_name":"FieldElement::batch_invert","impl_type":"FieldElement","contract":"pub(crate) fn batch_invert(\n    inputs: &mut [FieldElement],\n)/* <VERIFICATION NOTE>\n - Refactored for Verus: Index loops instead of iterators, manual Vec construction\n - Choice type operations handled by wrappers in subtle_assumes.rs\n - PROOF BYPASSES because of trait issues and proof obligations.\n</VERIFICATION NOTE> */\n\n    requires\n        forall|i: int|\n            #![trigger old(inputs)[i]]\n            0 <= i < old(inputs).len() ==> fe51_limbs_bounded(&old(inputs)[i], 54),\n    ensures\n// Each element is replaced appropriately:\n\n        forall|i: int|\n            #![auto]\n            0 <= i < inputs.len() ==> (\n            // If input was non-zero, it's replaced with its inverse\n            ((spec_field_element(&old(inputs)[i]) != 0) ==> is_inverse_field(\n                &old(inputs)[i],\n                &inputs[i],\n            )) &&\n            // If input was zero, it remains zero\n            ((spec_field_element(&old(inputs)[i]) == 0) ==> spec_field_element(&inputs[i])\n                == 0)),","referenced_specs":["fe51_limbs_bounded","is_inverse_field","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":522,"module":"field","doc_comment":"Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.\n\nWhen an input `FieldElement` is zero, its value is unchanged.","math_interpretation":"inputs[i]","informal_interpretation":"Given a slice of pub(crate)lic `FieldElements`, replace each with its inverse.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L522","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"fieldelement__batch_invert"},{"name":"ct_eq","display_name":"FieldElement::ct_eq","impl_type":"FieldElement","contract":"fn ct_eq(&self, other: &FieldElement) -> (result:\n    Choice)/* <VERIFICATION NOTE>\n - Use wrapper functions for ConstantTimeEq and CtOption\n - DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n - Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes\n</VERIFICATION NOTE> */\n\n    ensures\n        choice_is_true(result) == (spec_fe51_to_bytes(self) == spec_fe51_to_bytes(other)),","referenced_specs":["choice_is_true","spec_fe51_to_bytes"],"file":"curve25519-dalek/src/field.rs","line":142,"module":"field","doc_comment":"Test equality between two `FieldElement`s.  Since the\ninternal representation is not canonical, the field elements\nare normalized to wire format before comparison.","math_interpretation":"result = (spec_fe51_to_bytes(self) = spec_fe51_to_bytes(other))","informal_interpretation":"Test equality between two `FieldElement`s.  Since the","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L142","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__ct_eq"},{"name":"invert","display_name":"FieldElement::invert","impl_type":"FieldElement","contract":"pub(crate) fn invert(&self) -> (result:\n    FieldElement)/* VERIFICATION NOTE:\n- Computes self^(p-2) using Fermat's Little Theorem: a^(p-1) ≡ 1 (mod p) => a^(p-2) * a ≡ 1 (mod p)\n- p-2 = 2^255 - 21 = (2^250 - 1) * 2^5 + 11\n*/\n\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// If self is non-zero, result is the multiplicative inverse: result * self ≡ 1 (mod p)\n\n        spec_field_element(self) != 0 ==> (spec_field_element(&result) * spec_field_element(\n            self,\n        )) % p() == 1,\n        // If self is zero, result is zero\n        spec_field_element(self) == 0 ==> spec_field_element(&result) == 0,\n        spec_field_element(&result) == math_field_inv(spec_field_element(self)),\n        fe51_limbs_bounded(&result, 54),","referenced_specs":["fe51_limbs_bounded","math_field_inv","p","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":733,"module":"field","doc_comment":"Given a nonzero field element, compute its inverse.\n\nThe inverse is computed as self^(p-2), since\nx^(p-2)x = x^(p-1) = 1 (mod p).\n\nThis function returns zero on input zero.","math_interpretation":"x^(p-2)x = x^(p-1) = 1 (mod p).","informal_interpretation":"Given a nonzero field element, compute its inverse.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L733","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__invert"},{"name":"invsqrt","display_name":"FieldElement::invsqrt","impl_type":"FieldElement","contract":"pub(crate) fn invsqrt(&self) -> (result: (\n    Choice,\n    FieldElement,\n))\n// VERIFICATION NOTE: PROOF BYPASS\n\n    ensures\n// When self = 0: return (false, 0)\n\n        (spec_field_element(self) == 0) ==> (!choice_is_true(result.0) && spec_field_element(\n            &result.1,\n        ) == 0),\n        // When successful and self ≠ 0: r² * self ≡ 1 (mod p)\n        (choice_is_true(result.0)) ==> is_sqrt_ratio(&FieldElement::ONE, self, &result.1),\n        // When unsuccessful and self ≠ 0: r² * self ≡ i (mod p) [nonsquare case]\n        (!choice_is_true(result.0) && spec_field_element(self) != 0) ==> is_sqrt_ratio_times_i(\n            &FieldElement::ONE,\n            self,\n            &result.1,\n        ),","referenced_specs":["choice_is_true","is_sqrt_ratio","is_sqrt_ratio_times_i","p","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":974,"module":"field","doc_comment":"Attempt to compute `sqrt(1/self)` in constant time.\n\nConvenience wrapper around `sqrt_ratio_i`.\n\nThis function always returns the nonnegative square root.\n\n# Return\n\n- `(Choice(1), +sqrt(1/self))  ` if `self` is a nonzero square;\n- `(Choice(0), zero)           ` if `self` is zero;\n- `(Choice(0), +sqrt(i/self))  ` if `self` is a nonzero nonsquare;\n","math_interpretation":"(choice_is_true(result.0)) = > is_sqrt_ratio(FieldElement::ONE, self, result.1)","informal_interpretation":"Attempt to compute `sqrt(1/self)` in constant time.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L974","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"fieldelement__invsqrt"},{"name":"is_negative","display_name":"FieldElement::is_negative","impl_type":"FieldElement","contract":"pub(crate) fn is_negative(&self) -> (result:\n    Choice)/* VERIFICATION NOTE:\n- DRAFT SPEC: spec_fe51_to_bytes is a complex spec function that should correspond to as_bytes()\n- Proof uses lemma_as_bytes_equals_spec_fe51_to_bytes to connect as_bytes() with spec_fe51_to_bytes()\n</VERIFICATION NOTE> */\n\n    ensures\n        choice_is_true(result) == (spec_fe51_to_bytes(self)[0] & 1 == 1),","referenced_specs":["choice_is_true","spec_fe51_to_bytes"],"file":"curve25519-dalek/src/field.rs","line":217,"module":"field","doc_comment":"Determine if this `FieldElement` is negative, in the sense\nused in the ed25519 paper: `x` is negative if the low bit is\nset.\n\n# Return\n\nIf negative, return `Choice(1)`.  Otherwise, return `Choice(0)`.","math_interpretation":"result = (spec_fe51_to_bytes(self)[0] & 1 = 1)","informal_interpretation":"Determine if this `FieldElement` is negative, in the sense","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L217","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__is_negative"},{"name":"is_zero","display_name":"FieldElement::is_zero","impl_type":"FieldElement","contract":"pub(crate) fn is_zero(&self) -> (result:\n    Choice)/* VERIFICATION NOTE:\n- PROOF BYPASS AND SPEC BYPASS\n- we cannot write this directly; need to find a spec function for FieldElement51::as_bytes\nensures choice_is_true(result) == (self.as_bytes() == [0u8; 32])\n- (note: maybe an all_zeroes(as_bytes(...)) is sufficient as a spec)\n</VERIFICATION NOTE> */\n\n    ensures\n// SPEC BYPASS through placeholder spec_fe51_to_bytes\n\n        choice_is_true(result) == (spec_fe51_to_bytes(self) == seq![0u8; 32]),","referenced_specs":["choice_is_true","spec_fe51_to_bytes"],"file":"curve25519-dalek/src/field.rs","line":243,"module":"field","doc_comment":"Determine if this `FieldElement` is zero.\n\n# Return\n\nIf zero, return `Choice(1)`.  Otherwise, return `Choice(0)`.","math_interpretation":"result = (spec_fe51_to_bytes(self) = seq![0u8; 32])","informal_interpretation":"Determine if this `FieldElement` is zero.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L243","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__is_zero"},{"name":"pow22501","display_name":"FieldElement::pow22501","impl_type":"FieldElement","contract":"fn pow22501(&self) -> (result: (FieldElement, FieldElement))\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// Bounded limbs (maintained by all field operations)\n\n        fe51_limbs_bounded(&result.0, 54),\n        fe51_limbs_bounded(&result.1, 54),\n        // Mathematical values\n        spec_field_element(&result.0) == (pow(\n            spec_field_element(self) as int,\n            (pow2(250) - 1) as nat,\n        ) as nat) % p(),\n        spec_field_element(&result.1) == (pow(spec_field_element(self) as int, 11) as nat)\n            % p(),","referenced_specs":["fe51_limbs_bounded","p","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":289,"module":"field","doc_comment":"Compute (self^(2^250-1), self^11), used as a helper function\nwithin invert() and pow22523().","math_interpretation":"spec_field_element(result.1) = ((fe(self) )^11 ) mod p","informal_interpretation":"Compute (self^(2^250-1), self^11), used as a helper function","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L289","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__pow22501"},{"name":"pow_p58","display_name":"FieldElement::pow_p58","impl_type":"FieldElement","contract":"fn pow_p58(&self) -> (result: FieldElement)\n    requires\n        fe51_limbs_bounded(self, 54),\n    ensures\n// Bounded limbs (maintained by all field operations)\n\n        fe51_limbs_bounded(&result, 54),\n        // Mathematical value\n        spec_field_element(&result) == (pow(\n            spec_field_element(self) as int,\n            (pow2(252) - 3) as nat,\n        ) as nat) % p(),","referenced_specs":["fe51_limbs_bounded","p","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":769,"module":"field","doc_comment":"Raise this field element to the power (p-5)/8 = 2^252 -3.","math_interpretation":"limbs(result) < 2^54","informal_interpretation":"Raise this field element to the power (p-5)/8 = 2^252 -3.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L769","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"fieldelement__pow_p58"},{"name":"sqrt_ratio_i","display_name":"FieldElement::sqrt_ratio_i","impl_type":"FieldElement","contract":"pub(crate) fn sqrt_ratio_i(u: &FieldElement, v: &FieldElement) -> (result: (\n    Choice,\n    FieldElement,\n))\n    requires\n// Input bounds for sqrt_ratio_i\n// u and v can be up to 54-bit bounded (from sub/add operations in decompress)\n\n        fe51_limbs_bounded(u, 54),\n        fe51_limbs_bounded(v, 54),\n    ensures\n// When u = 0: always return (true, 0)\n\n        (spec_field_element(u) == 0) ==> (choice_is_true(result.0) && spec_field_element(\n            &result.1,\n        ) == 0),\n        // When v = 0 but u ≠ 0: return (false, 0) [division by zero case]\n        (spec_field_element(v) == 0 && spec_field_element(u) != 0) ==> (!choice_is_true(\n            result.0,\n        ) && spec_field_element(&result.1) == 0),\n        // When successful and v ≠ 0: r² * v ≡ u (mod p)\n        (choice_is_true(result.0) && spec_field_element(v) != 0) ==> is_sqrt_ratio(\n            u,\n            v,\n            &result.1,\n        ),\n        // When unsuccessful and v ≠ 0: r² * v ≡ i*u (mod p) [nonsquare case]\n        (!choice_is_true(result.0) && spec_field_element(v) != 0 && spec_field_element(u) != 0)\n            ==> is_sqrt_ratio_times_i(u, v, &result.1),\n        // NEW: The result is always the \"non-negative\" square root (LSB = 0)\n        // This is a fundamental property of sqrt_ratio_i that the original code\n        // relies on for decompression sign bit handling\n        spec_field_element(&result.1) % 2 == 0,\n        // Limb bounds: result is 52-bit bounded (from conditional_negate)\n        fe51_limbs_bounded(\n            &result.1,\n            52,\n        ),\n// VERIFICATION NOTE: PROOF BYPASS","referenced_specs":["add","choice_is_true","fe51_limbs_bounded","is_sqrt_ratio","is_sqrt_ratio_times_i","p","spec_field_element"],"file":"curve25519-dalek/src/field.rs","line":852,"module":"field","doc_comment":"Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`\nor `sqrt(i*u/v)` in constant time.\n\nThis function always returns the nonnegative square root.\n\n# Return\n\n- `(Choice(1), +sqrt(u/v))  ` if `v` is nonzero and `u/v` is square;\n- `(Choice(1), zero)        ` if `u` is zero;\n- `(Choice(0), zero)        ` if `v` is zero and `u` is nonzero;\n- `(Choice(0), +sqrt(i*u/v))` if `u/v` is nonsquare (so `i*u/v` is square).\n","math_interpretation":"(!choice_is_true(result.0) && fe(v) != 0 && fe(u) != 0) = > is_sqrt_ratio_times_i(u, v, result.1)","informal_interpretation":"Given `FieldElements` `u` and `v`, compute either `sqrt(u/v)`","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/field.rs#L852","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"fieldelement__sqrt_ratio_i"},{"name":"as_bytes","display_name":"MontgomeryPoint::as_bytes","impl_type":"MontgomeryPoint","contract":"pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == &self.0,","referenced_specs":[],"file":"curve25519-dalek/src/montgomery.rs","line":982,"module":"montgomery","doc_comment":"View this `MontgomeryPoint` as an array of bytes.","math_interpretation":"result = self.0","informal_interpretation":"View this `MontgomeryPoint` as an array of bytes.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L978","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomerypoint__as_bytes"},{"name":"ct_eq","display_name":"MontgomeryPoint::ct_eq","impl_type":"MontgomeryPoint","contract":"fn ct_eq(&self, other: &MontgomeryPoint) -> (result: Choice)\n    ensures\n// Two MontgomeryPoints are equal if their u-coordinates are equal mod p\n\n        choice_is_true(result) == (spec_field_element_from_bytes(&self.0)\n            == spec_field_element_from_bytes(&other.0)),","referenced_specs":["choice_is_true","p","spec_field_element_from_bytes"],"file":"curve25519-dalek/src/montgomery.rs","line":135,"module":"montgomery","doc_comment":"","math_interpretation":"result = (spec_field_element_from_bytes(self.0) = spec_field_element_from_bytes(other.0))","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L131","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__ct_eq"},{"name":"hash","display_name":"MontgomeryPoint::hash","impl_type":"MontgomeryPoint","contract":"fn hash<H: Hasher>(&self, state: &mut H)\n    ensures/*  VERIFICATION NOTE:\n         (1) The actual postcondition is: *state == spec_state_after_hash_montgomery(initial_state, self)\n             where initial_state is the value of *state before this call.\n             However, Verus doesn't support old() on &mut types in ensures clauses.\n             The property is for now established via assumes in the function body (lines 192-194).\n        (2) The spec is completed by axiom_hash_is_canonical: equal field elements hash identically. */\n\n        true,","referenced_specs":["spec_state_after_hash_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":204,"module":"montgomery","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L200","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__hash"},{"name":"identity","display_name":"MontgomeryPoint::identity","impl_type":"MontgomeryPoint","contract":"fn identity() -> (result: MontgomeryPoint)\n    ensures\n// The identity point has u-coordinate = 0\n\n        spec_montgomery(result) == 0,","referenced_specs":["spec_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":234,"module":"montgomery","doc_comment":"Return the group identity element, which has order 4.","math_interpretation":"// The identity point has u-coordinate = 0 spec_montgomery(result) = 0","informal_interpretation":"Return the group identity element, which has order 4.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L230","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__identity"},{"name":"mul","display_name":"MontgomeryPoint::mul","impl_type":"MontgomeryPoint","contract":"fn mul(self, scalar: &Scalar) -> (result: MontgomeryPoint)\n    ensures\n// The canonical Montgomery lift point P corresponding to this u-coordinate\n// is multiplied by the unreduced scalar value\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*self));\n            let n_unreduced = scalar_to_nat(scalar);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),","referenced_specs":["canonical_montgomery_lift","montgomery_scalar_mul","scalar_to_nat","spec_montgomery","spec_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":2396,"module":"montgomery","doc_comment":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n","math_interpretation":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)","informal_interpretation":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2001","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__mul"},{"name":"mul_assign","display_name":"MontgomeryPoint::mul_assign","impl_type":"MontgomeryPoint","contract":"fn mul_assign(&mut self, scalar: &Scalar)\n    requires\n        is_valid_montgomery_point(*old(self)),\n    ensures\n// Result represents [n]old(self) where n is the UNREDUCED scalar value\n// Uses canonical Montgomery lift\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*old(self)));\n            let n_unreduced = scalar_to_nat(scalar);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(*self) == spec_u_coordinate(R)\n        }),","referenced_specs":["canonical_montgomery_lift","is_valid_montgomery_point","montgomery_scalar_mul","scalar_to_nat","spec_montgomery","spec_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":2438,"module":"montgomery","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2043","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomerypoint__mul_assign"},{"name":"mul_base","display_name":"MontgomeryPoint::mul_base","impl_type":"MontgomeryPoint","contract":"pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_valid_montgomery_point(result),\n        // Functional correctness: result.u = [scalar] * basepoint (u-coordinate)\n        // Use scalar_to_nat (not spec_scalar) to match implementation behavior\n        spec_montgomery(result) == montgomery_scalar_mul_u(\n            spec_x25519_basepoint_u(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["is_valid_montgomery_point","montgomery_scalar_mul_u","scalar_to_nat","spec_montgomery","spec_x25519_basepoint_u"],"file":"curve25519-dalek/src/montgomery.rs","line":278,"module":"montgomery","doc_comment":"Fixed-base scalar multiplication (i.e. multiplication by the base point).","math_interpretation":"is_valid_montgomery_point(result)","informal_interpretation":"Fixed-base scalar multiplication (i.e. multiplication by the base point).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L274","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__mul_base"},{"name":"mul_base_clamped","display_name":"MontgomeryPoint::mul_base_clamped","impl_type":"MontgomeryPoint","contract":"pub fn mul_base_clamped(bytes: [u8; 32]) -> (result: Self)\n    ensures\n        is_valid_montgomery_point(result),\n        // Functional correctness: result.u = [clamp(bytes)] * basepoint (u-coordinate)\n        // Use scalar_to_nat (not spec_scalar) because clamped values are in [2^254, 2^255)\n        // which exceeds group_order ℓ ≈ 2^252, so spec_scalar would incorrectly reduce\n        spec_montgomery(result) == montgomery_scalar_mul_u(\n            spec_x25519_basepoint_u(),\n            scalar_to_nat(&Scalar { bytes: spec_clamp_integer(bytes) }),\n        ),","referenced_specs":["group_order","is_valid_montgomery_point","montgomery_scalar_mul_u","scalar_to_nat","spec_clamp_integer","spec_montgomery","spec_x25519_basepoint_u"],"file":"curve25519-dalek/src/montgomery.rs","line":350,"module":"montgomery","doc_comment":"Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].","math_interpretation":"is_valid_montgomery_point(result)","informal_interpretation":"Multiply the basepoint by `clamp_integer(bytes)`. For a description of clamping, see","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L346","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":false,"has_proof":false,"id":"montgomerypoint__mul_base_clamped"},{"name":"mul_bits_be","display_name":"MontgomeryPoint::mul_bits_be","impl_type":"MontgomeryPoint","contract":"pub fn mul_bits_be(&self, bits: impl Iterator<Item = bool>) -> MontgomeryPoint {\n    // Algorithm 8 of Costello-Smith 2017\n    let affine_u = FieldElement::from_bytes(&self.0);\n    let mut x0 = ProjectivePoint::identity();\n    let mut x1 = ProjectivePoint { U: affine_u, W: FieldElement::ONE };\n\n    // Go through the bits from most to least significant, using a sliding window of 2\n    let mut prev_bit = false;\n    for cur_bit in bits {\n        let choice: u8 = (prev_bit ^ cur_bit) as u8;\n\n        debug_assert!(choice == 0 || choice == 1);\n\n        ProjectivePoint::conditional_swap(&mut x0, &mut x1, choice.into());\n        differential_add_and_double(&mut x0, &mut x1, &affine_u);\n\n        prev_bit = cur_bit;\n    }\n    // The final value of prev_bit above is scalar.bits()[0], i.e., the LSB of scalar\n    ProjectivePoint::conditional_swap(&mut x0, &mut x1, Choice::from(prev_bit as u8));\n    // Don't leave the bit in the stack\n    #[cfg(feature = \"zeroize\")]\n    prev_bit.zeroize();\n\n    x0.as_affine()\n}\n</ORIGINAL CODE>\n*/\n/// Version of mul_bits_be that takes a slice of bits instead of an iterator.\n/// This version uses a while loop instead of for-loop to be Verus-compatible.\n///\n/// Given `self` \\\\( = u\\_0(P) \\\\), and a big-endian bit representation of an integer\n/// \\\\(n\\\\) as a slice, return \\\\( u\\_0(\\[n\\]P) \\\\).\n///\n// VERIFICATION NOTE: refactored mul_bits_be code\npub fn mul_bits_be(&self, bits: &[bool]) -> (result: MontgomeryPoint)\n    requires\n        bits.len() <= 255,\n        is_valid_montgomery_point(*self),\n    ensures\n        ({\n            // Let P be the canonical affine lift of input u-coordinate\n            let P = canonical_montgomery_lift(spec_montgomery(*self));\n            let n = bits_be_to_nat(bits, bits@.len() as int);\n            let R = montgomery_scalar_mul(P, n);\n\n            // result encodes u([n]P)\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),","referenced_specs":["bits_be_to_nat","canonical_montgomery_lift","is_valid_montgomery_point","montgomery_scalar_mul","spec_montgomery","spec_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":385,"module":"montgomery","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L416","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomerypoint__mul_bits_be"},{"name":"mul_clamped","display_name":"MontgomeryPoint::mul_clamped","impl_type":"MontgomeryPoint","contract":"pub fn mul_clamped(self, bytes: [u8; 32]) -> (result: Self)\n    requires\n        is_valid_montgomery_point(self),\n    ensures/* VERIFICATION NOTE: Result represents [n]self where n is the clamped integer value\n  The corresponding scalar is not reduced modulo the group order. */\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(self));\n            let clamped_bytes = spec_clamp_integer(bytes);\n            let n = bytes32_to_nat(&clamped_bytes);\n            let R = montgomery_scalar_mul(P, n);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),","referenced_specs":["bytes32_to_nat","canonical_montgomery_lift","is_valid_montgomery_point","montgomery_scalar_mul","spec_clamp_integer","spec_montgomery","spec_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":312,"module":"montgomery","doc_comment":"Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see\n[`clamp_integer`].","math_interpretation":"","informal_interpretation":"Multiply this point by `clamp_integer(bytes)`. For a description of clamping, see","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L308","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomerypoint__mul_clamped"},{"name":"to_bytes","display_name":"MontgomeryPoint::to_bytes","impl_type":"MontgomeryPoint","contract":"pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,","referenced_specs":[],"file":"curve25519-dalek/src/montgomery.rs","line":990,"module":"montgomery","doc_comment":"Convert this `MontgomeryPoint` to an array of bytes.","math_interpretation":"result = self.0","informal_interpretation":"Convert this `MontgomeryPoint` to an array of bytes.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L986","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomerypoint__to_bytes"},{"name":"to_edwards","display_name":"MontgomeryPoint::to_edwards","impl_type":"MontgomeryPoint","contract":"pub fn to_edwards(&self, sign: u8) -> (result: Option<EdwardsPoint>)\n    ensures\n        match result {\n            Some(edwards) => montgomery_corresponds_to_edwards(*self, edwards)\n                && is_well_formed_edwards_point(edwards) && edwards_point_as_affine(edwards)\n                == spec_montgomery_to_edwards_affine_with_sign(spec_montgomery(*self), sign),\n            None => is_equal_to_minus_one(spec_montgomery(*self)),\n        },","referenced_specs":["edwards_point_as_affine","is_equal_to_minus_one","is_well_formed_edwards_point","montgomery_corresponds_to_edwards","spec_montgomery","spec_montgomery_to_edwards_affine_with_sign"],"file":"curve25519-dalek/src/montgomery.rs","line":1013,"module":"montgomery","doc_comment":"Attempt to convert to an `EdwardsPoint`, using the supplied\nchoice of sign for the `EdwardsPoint`.\n\n# Inputs\n\n* `sign`: a `u8` donating the desired sign of the resulting\n`EdwardsPoint`.  `0` denotes positive and `1` negative.\n\n# Return\n\n* `Some(EdwardsPoint)` if `self` is the \\\\(u\\\\)-coordinate of a\npoint on (the Montgomery form of) Curve25519;\n\n* `None` if `self` is the \\\\(u\\\\)-coordinate of a point on the\ntwist of (the Montgomery form of) Curve25519;\n","math_interpretation":"u -> (x,y) in E(F_p), birational map M -> E","informal_interpretation":"Converts a Montgomery point to its Edwards representation (with sign).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1009","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"montgomerypoint__to_edwards"},{"name":"zeroize","display_name":"MontgomeryPoint::zeroize","impl_type":"MontgomeryPoint","contract":"fn zeroize(&mut self)\n    ensures\n// All bytes are zero\n\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,\n        // The u-coordinate is 0 (identity point)\n        spec_montgomery(*self) == 0,","referenced_specs":["spec_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":258,"module":"montgomery","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 32 = > #[trigger] self.0[i] = 0u8","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L254","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomerypoint__zeroize"},{"name":"as_affine","display_name":"ProjectivePoint::as_affine","impl_type":"ProjectivePoint","contract":"pub fn as_affine(&self) -> (result: MontgomeryPoint)\n    requires\n        fe51_limbs_bounded(&self.U, 54),\n        fe51_limbs_bounded(&self.W, 54),\n    ensures\n// For projective point (U:W), the affine u-coordinate is u = U/W (or 0 if W=0)\n\n        spec_montgomery(result) == {\n            let u_proj = spec_field_element(&self.U);\n            let w_proj = spec_field_element(&self.W);\n            if w_proj == 0 {\n                0\n            } else {\n                math_field_mul(u_proj, math_field_inv(w_proj))\n            }\n        },","referenced_specs":["fe51_limbs_bounded","math_field_inv","math_field_mul","spec_field_element","spec_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":1684,"module":"montgomery","doc_comment":"Dehomogenize this point to affine coordinates.\n\n# Return\n\n* \\\\( u = U / W \\\\) if \\\\( W \\neq 0 \\\\);\n* \\\\( 0 \\\\) if \\\\( W \\eq 0 \\\\);\n\n# Specification\nThe resulting MontgomeryPoint has u-coordinate equal to U/W (or 0 if W=0)","math_interpretation":"* \\\\( u = U / W \\\\) if \\\\( W \\neq 0 \\\\);","informal_interpretation":"Dehomogenize this point to affine coordinates.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1289","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"projectivepoint__as_affine"},{"name":"identity","display_name":"ProjectivePoint::identity","impl_type":"ProjectivePoint","contract":"fn identity() -> (result: MontgomeryPoint)\n    ensures\n// The identity point has u-coordinate = 0\n\n        spec_montgomery(result) == 0,","referenced_specs":["spec_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":234,"module":"montgomery","doc_comment":"Return the group identity element, which has order 4.","math_interpretation":"// The identity point has u-coordinate = 0 spec_montgomery(result) = 0","informal_interpretation":"Return the group identity element, which has order 4.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1174","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"projectivepoint__identity"},{"name":"mul","display_name":"Scalar::mul","impl_type":"Scalar","contract":"fn mul(self, scalar: &Scalar) -> (result: MontgomeryPoint)\n    ensures\n// The canonical Montgomery lift point P corresponding to this u-coordinate\n// is multiplied by the unreduced scalar value\n\n        ({\n            let P = canonical_montgomery_lift(spec_montgomery(*self));\n            let n_unreduced = scalar_to_nat(scalar);\n            let R = montgomery_scalar_mul(P, n_unreduced);\n            spec_montgomery(result) == spec_u_coordinate(R)\n        }),","referenced_specs":["canonical_montgomery_lift","montgomery_scalar_mul","scalar_to_nat","spec_montgomery","spec_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":2396,"module":"montgomery","doc_comment":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)\n","math_interpretation":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)","informal_interpretation":"Given `self` \\\\( = u\\_0(P) \\\\), and a `Scalar` \\\\(n\\\\), return \\\\( u\\_0(\\[n\\]P) \\\\)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L2069","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__mul_L2396"},{"name":"differential_add_and_double","display_name":"differential_add_and_double","impl_type":"","contract":"fn differential_add_and_double(\n    P: &mut ProjectivePoint,\n    Q: &mut ProjectivePoint,\n    affine_PmQ: &FieldElement,\n)\n    requires\n// Bounds needed for the underlying field operations\n\n        fe51_limbs_bounded(&old(P).U, 52),\n        fe51_limbs_bounded(&old(P).W, 52),\n        fe51_limbs_bounded(&old(Q).U, 52),\n        fe51_limbs_bounded(&old(Q).W, 52),\n        // This matches the invariant maintained by the caller (mul_bits_be)\n        fe51_limbs_bounded(affine_PmQ, 51),\n        is_valid_u_coordinate(spec_field_element(affine_PmQ)),\n    ensures\n// === Bounds preserved for callers ===\n\n        fe51_limbs_bounded(&P.U, 52),\n        fe51_limbs_bounded(&P.W, 52),\n        fe51_limbs_bounded(&Q.U, 52),\n        fe51_limbs_bounded(&Q.W, 52),\n        // Degenerate case: if u(P-Q)=0 and both inputs have u=0, outputs preserve u=0.\n        (spec_field_element(affine_PmQ) == 0 && spec_projective_u_coordinate(*old(P)) == 0\n            && spec_projective_u_coordinate(*old(Q)) == 0) ==> (spec_projective_u_coordinate(*P)\n            == 0 && spec_projective_u_coordinate(*Q) == 0),\n        // Montgomery ladder step: P' = [2]P (xDBL), Q' = P + Q (xADD).\n        // Case 1: P = [k]B, Q = [k+1]B  ==>  P' = [2k]B, Q' = [2k+1]B\n        ({\n            let B = canonical_montgomery_lift(spec_field_element(affine_PmQ));\n            forall|k: nat|\n                spec_field_element(affine_PmQ) != 0\n                    && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(P),\n                    montgomery_scalar_mul(B, k),\n                ) && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(Q),\n                    montgomery_scalar_mul(B, k + 1),\n                ) ==> {\n                    &&& projective_represents_montgomery_or_infinity(\n                        *P,\n                        montgomery_scalar_mul(B, 2 * k),\n                    )\n                    &&& projective_represents_montgomery_or_infinity(\n                        *Q,\n                        montgomery_scalar_mul(B, 2 * k + 1),\n                    )\n                }\n        }),\n        // Case 2 (swapped): P = [k+1]B, Q = [k]B  ==>  P' = [2k+2]B, Q' = [2k+1]B\n        ({\n            let B = canonical_montgomery_lift(spec_field_element(affine_PmQ));\n            forall|k: nat|\n                spec_field_element(affine_PmQ) != 0\n                    && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(P),\n                    montgomery_scalar_mul(B, k + 1),\n                ) && #[trigger] projective_represents_montgomery_or_infinity(\n                    *old(Q),\n                    montgomery_scalar_mul(B, k),\n                ) ==> {\n                    &&& projective_represents_montgomery_or_infinity(\n                        *P,\n                        montgomery_scalar_mul(B, 2 * k + 2),\n                    )\n                    &&& projective_represents_montgomery_or_infinity(\n                        *Q,\n                        montgomery_scalar_mul(B, 2 * k + 1),\n                    )\n                }\n        }),","referenced_specs":["canonical_montgomery_lift","fe51_limbs_bounded","is_valid_u_coordinate","montgomery_scalar_mul","projective_represents_montgomery_or_infinity","spec_field_element","spec_projective_u_coordinate"],"file":"curve25519-dalek/src/montgomery.rs","line":1733,"module":"montgomery","doc_comment":"Perform the double-and-add step of the Montgomery ladder.\n\nGiven projective points\n\\\\( (U\\_P : W\\_P) = u(P) \\\\),\n\\\\( (U\\_Q : W\\_Q) = u(Q) \\\\),\nand the affine difference\n\\\\(      u\\_{P-Q} = u(P-Q) \\\\), set\n$$\n(U\\_P : W\\_P) \\gets u(\\[2\\]P)\n$$\nand\n$$\n(U\\_Q : W\\_Q) \\gets u(P + Q).\n$$","math_interpretation":"\\\\( (U\\_P : W\\_P) = u(P) \\\\),","informal_interpretation":"Perform the double-and-add step of the Montgomery ladder.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1338","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"montgomery__differential_add_and_double"},{"name":"elligator_encode","display_name":"elligator_encode","impl_type":"","contract":"pub(crate) fn elligator_encode(r_0: &FieldElement) -> (result: MontgomeryPoint)\n    requires\n        fe51_limbs_bounded(r_0, 51),\n    ensures\n        spec_montgomery(result) == spec_elligator_encode(spec_field_element(r_0)),\n        spec_montgomery(result) < p(),\n        !is_equal_to_minus_one(spec_montgomery(result)),","referenced_specs":["fe51_limbs_bounded","is_equal_to_minus_one","p","spec_elligator_encode","spec_field_element","spec_montgomery"],"file":"curve25519-dalek/src/montgomery.rs","line":1085,"module":"montgomery","doc_comment":"Perform the Elligator2 mapping to a Montgomery point.\n\nSee <https://tools.ietf.org/html/draft-irtf-cfrg-hash-to-curve-10#section-6.7.1>\nAlso: RFC 9380 Section 6.7.1","math_interpretation":"spec_montgomery(result) = spec_elligator_encode(fe(r_0))","informal_interpretation":"Perform the Elligator2 mapping to a Montgomery point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/montgomery.rs#L1073","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"montgomery__elligator_encode"},{"name":"efgh","display_name":"BatchCompressState::efgh","impl_type":"BatchCompressState","contract":"fn efgh(&self) -> (result: FieldElement)\n    requires\n        fe51_limbs_bounded(&self.eg, 54),\n        fe51_limbs_bounded(&self.fh, 54),\n    ensures\n        fe51_limbs_bounded(&result, 54),\n        spec_field_element(&result) == math_field_mul(\n            spec_field_element(&self.eg),\n            spec_field_element(&self.fh),\n        ),","referenced_specs":["fe51_limbs_bounded","math_field_mul","spec_field_element"],"file":"curve25519-dalek/src/ristretto.rs","line":731,"module":"ristretto","doc_comment":"","math_interpretation":"spec_field_element(self.fh)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L731","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"batchcompressstate__efgh"},{"name":"from","display_name":"BatchCompressState::from","impl_type":"BatchCompressState","contract":"fn from(P: &'a RistrettoPoint) -> (result:\n    BatchCompressState)/* Expected requires (if Verus supported from_req):\n        is_well_formed_edwards_point(P.0),\n    */\n\n    ensures\n        fe51_limbs_bounded(&result.eg, 54),\n        fe51_limbs_bounded(&result.fh, 54),\n        // e = 2*X*Y\n        spec_field_element(&result.e) == math_field_mul(\n            2,\n            math_field_mul(spec_field_element(&P.0.X), spec_field_element(&P.0.Y)),\n        ),\n        // f = Z^2 + d*T^2\n        spec_field_element(&result.f) == math_field_add(\n            math_field_square(spec_field_element(&P.0.Z)),\n            math_field_mul(\n                spec_field_element(&constants::EDWARDS_D),\n                math_field_square(spec_field_element(&P.0.T)),\n            ),\n        ),\n        // g = Y^2 + X^2 (a = -1)\n        spec_field_element(&result.g) == math_field_add(\n            math_field_square(spec_field_element(&P.0.Y)),\n            math_field_square(spec_field_element(&P.0.X)),\n        ),\n        // h = Z^2 - d*T^2\n        spec_field_element(&result.h) == math_field_sub(\n            math_field_square(spec_field_element(&P.0.Z)),\n            math_field_mul(\n                spec_field_element(&constants::EDWARDS_D),\n                math_field_square(spec_field_element(&P.0.T)),\n            ),\n        ),\n        // eg = e * g, fh = f * h\n        spec_field_element(&result.eg) == math_field_mul(\n            spec_field_element(&result.e),\n            spec_field_element(&result.g),\n        ),\n        spec_field_element(&result.fh) == math_field_mul(\n            spec_field_element(&result.f),\n            spec_field_element(&result.h),\n        ),","referenced_specs":["fe51_limbs_bounded","from_req","is_well_formed_edwards_point","math_field_add","math_field_mul","math_field_square","math_field_sub","spec_field_element"],"file":"curve25519-dalek/src/ristretto.rs","line":749,"module":"ristretto","doc_comment":"","math_interpretation":"math_field_mul(spec_field_element(P.0.X), spec_field_element(P.0.Y))","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L749","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"batchcompressstate__from"},{"name":"as_bytes","display_name":"CompressedRistretto::as_bytes","impl_type":"CompressedRistretto","contract":"pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        *result == self.0,","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":274,"module":"ristretto","doc_comment":"View this `CompressedRistretto` as an array of bytes.","math_interpretation":"&CompressedRistretto -> &[u8; 32]","informal_interpretation":"Returns the byte representation of a compressed Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L274","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressedristretto__as_bytes"},{"name":"ct_eq","display_name":"CompressedRistretto::ct_eq","impl_type":"CompressedRistretto","contract":"fn ct_eq(&self, other: &CompressedRistretto) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.0 == other.0),","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/ristretto.rs","line":254,"module":"ristretto","doc_comment":"","math_interpretation":"a =? b (constant-time byte comparison)","informal_interpretation":"Constant-time equality comparison of two compressed Ristretto points.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L254","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressedristretto__ct_eq"},{"name":"decompress","display_name":"CompressedRistretto::decompress","impl_type":"CompressedRistretto","contract":"pub fn decompress(&self) -> (result: Option<RistrettoPoint>)\n    ensures\n// Spec alignment: result matches spec-level decoding\n\n        result == spec_ristretto_decompress(self.0),\n        // If decompression succeeds, the result is a well-formed Edwards point\n        // (well-formed includes: valid on curve, limbs bounded, sum bounded)\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),\n        // On success, the decoded point lies in the even subgroup\n        result.is_some() ==> is_in_even_subgroup(result.unwrap().0),","referenced_specs":["is_in_even_subgroup","is_well_formed_edwards_point","spec_ristretto_decompress"],"file":"curve25519-dalek/src/ristretto.rs","line":332,"module":"ristretto","doc_comment":"Attempt to decompress to an `RistrettoPoint`.\n\n# Return\n\n- `Some(RistrettoPoint)` if `self` was the canonical encoding of a point;\n\n- `None` if `self` was not the canonical encoding of a point.","math_interpretation":"[u8; 32] -> Option<P in E/~>, Ristretto decoding","informal_interpretation":"Decompresses a Ristretto encoding to a point (if valid).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L332","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"compressedristretto__decompress"},{"name":"from_slice","display_name":"CompressedRistretto::from_slice","impl_type":"CompressedRistretto","contract":"pub fn from_slice(bytes: &[u8]) -> (result: Result<CompressedRistretto, TryFromSliceError>)\n    ensures\n        bytes@.len() == 32 ==> matches!(result, Ok(_)),\n        bytes@.len() != 32 ==> matches!(result, Err(_)),\n        match result {\n            Ok(point) => point.0@ == bytes@,\n            Err(_) => true,\n        },","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":288,"module":"ristretto","doc_comment":"Construct a `CompressedRistretto` from a slice of bytes.\n\n# Errors\n\nReturns [`TryFromSliceError`] if the input `bytes` slice does not have\na length of 32.","math_interpretation":"&[u8] -> CompressedRistretto","informal_interpretation":"Constructs a compressed Ristretto point from a byte slice.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L288","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"compressedristretto__from_slice"},{"name":"identity","display_name":"CompressedRistretto::identity","impl_type":"CompressedRistretto","contract":"fn identity() -> (result: CompressedRistretto)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> result.0[i] == 0u8,","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":316,"module":"ristretto","doc_comment":"","math_interpretation":"Encode(O) -> CompressedRistretto","informal_interpretation":"Returns the compressed identity Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L316","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressedristretto__identity"},{"name":"to_bytes","display_name":"CompressedRistretto::to_bytes","impl_type":"CompressedRistretto","contract":"pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.0,","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":266,"module":"ristretto","doc_comment":"Copy the bytes of this `CompressedRistretto`.","math_interpretation":"CompressedRistretto -> [u8; 32]","informal_interpretation":"Returns the byte array of a compressed Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L266","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"compressedristretto__to_bytes"},{"name":"zeroize","display_name":"CompressedRistretto::zeroize","impl_type":"CompressedRistretto","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":2397,"module":"ristretto","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 32 = > #[trigger] self.0[i] = 0u8","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2397","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"compressedristretto__zeroize"},{"name":"basepoint","display_name":"RistrettoBasepointTable::basepoint","impl_type":"RistrettoBasepointTable","contract":"pub fn basepoint(&self) -> (result: RistrettoPoint)\n    requires\n        is_valid_edwards_basepoint_table(self.0, spec_ristretto_basepoint()),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // The result is the Ristretto basepoint B\n        edwards_point_as_affine(result.0) == spec_ristretto_basepoint(),","referenced_specs":["edwards_point_as_affine","is_valid_edwards_basepoint_table","is_well_formed_edwards_point","spec_ristretto_basepoint"],"file":"curve25519-dalek/src/ristretto.rs","line":2233,"module":"ristretto","doc_comment":"Get the basepoint for this table as a `RistrettoPoint`.","math_interpretation":"edwards_point_as_affine(result.0) = spec_ristretto_basepoint()","informal_interpretation":"Get the basepoint for this table as a `RistrettoPoint`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2233","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettobasepointtable__basepoint"},{"name":"create","display_name":"RistrettoBasepointTable::create","impl_type":"RistrettoBasepointTable","contract":"pub fn create(basepoint: &RistrettoPoint) -> (result: RistrettoBasepointTable)\n    requires\n        is_well_formed_edwards_point(basepoint.0),\n    ensures\n        is_valid_edwards_basepoint_table(result.0, edwards_point_as_affine(basepoint.0)),","referenced_specs":["edwards_point_as_affine","is_valid_edwards_basepoint_table","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":2223,"module":"ristretto","doc_comment":"Create a precomputed table of multiples of the given `basepoint`.","math_interpretation":"is_valid_edwards_basepoint_table(result.0, edwards_point_as_affine(basepoint.0))","informal_interpretation":"Create a precomputed table of multiples of the given `basepoint`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2223","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettobasepointtable__create"},{"name":"mul","display_name":"RistrettoBasepointTable::mul","impl_type":"RistrettoBasepointTable","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)/* requires clause in MulSpecImpl<&Scalar> for &RistrettoBasepointTable in arithm_trait_specs.rs:\n    requires scalar.bytes[31] <= 127\n*/\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ristretto_basepoint"],"file":"curve25519-dalek/src/ristretto.rs","line":2176,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2176","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettobasepointtable__mul"},{"name":"add","display_name":"RistrettoPoint::add","impl_type":"RistrettoPoint","contract":"fn add(self, other: &'b RistrettoPoint) -> (result:\n    RistrettoPoint)\n// requires (from AddSpecImpl::add_req): is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_add(\n            edwards_point_as_affine(self.0).0,\n            edwards_point_as_affine(self.0).1,\n            edwards_point_as_affine(other.0).0,\n            edwards_point_as_affine(other.0).1,\n        ),","referenced_specs":["add","add_req","edwards_add","edwards_point_as_affine","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1504,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1504","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__add"},{"name":"add_assign","display_name":"RistrettoPoint::add_assign","impl_type":"RistrettoPoint","contract":"fn add_assign(&mut self, _rhs: &RistrettoPoint)\n    requires\n        is_well_formed_edwards_point(old(self).0),\n        is_well_formed_edwards_point(_rhs.0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = old(self) + rhs\n        edwards_point_as_affine(self.0) == edwards_add(\n            edwards_point_as_affine(old(self).0).0,\n            edwards_point_as_affine(old(self).0).1,\n            edwards_point_as_affine(_rhs.0).0,\n            edwards_point_as_affine(_rhs.0).1,\n        ),","referenced_specs":["edwards_add","edwards_point_as_affine","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1529,"module":"ristretto","doc_comment":"","math_interpretation":"edwards_point_as_affine(old(self).0).1","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1529","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__add_assign"},{"name":"compress","display_name":"RistrettoPoint::compress","impl_type":"RistrettoPoint","contract":"pub fn compress(&self) -> (result: CompressedRistretto)\n    ensures\n        result.0 == spec_ristretto_compress(*self),","referenced_specs":["spec_ristretto_compress"],"file":"curve25519-dalek/src/ristretto.rs","line":654,"module":"ristretto","doc_comment":"Compress this point using the Ristretto encoding.","math_interpretation":"P in E/~ -> [u8; 32], Ristretto encoding","informal_interpretation":"Compresses a Ristretto point to its canonical 32-byte encoding.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L654","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristrettopoint__compress"},{"name":"conditional_select","display_name":"RistrettoPoint::conditional_select","impl_type":"RistrettoPoint","contract":"fn conditional_select(a: &RistrettoPoint, b: &RistrettoPoint, choice: Choice) -> (result:\n    RistrettoPoint)\n    ensures\n// If choice is false (0), return a\n\n        !choice_is_true(choice) ==> result.0 == a.0,\n        // If choice is true (1), return b\n        choice_is_true(choice) ==> result.0 == b.0,","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/ristretto.rs","line":2275,"module":"ristretto","doc_comment":"Conditionally select between `self` and `other`.\n\n# Example\n\n```\nuse subtle::ConditionallySelectable;\nuse subtle::Choice;\n#\n# use curve25519_dalek::traits::Identity;\n# use curve25519_dalek::ristretto::RistrettoPoint;\n# use curve25519_dalek::constants;\n# fn main() {\n\nlet A = RistrettoPoint::identity();\nlet B = constants::RISTRETTO_BASEPOINT_POINT;\n\nlet mut P = A;\n\nP = RistrettoPoint::conditional_select(&A, &B, Choice::from(0));\nassert_eq!(P, A);\nP = RistrettoPoint::conditional_select(&A, &B, Choice::from(1));\nassert_eq!(P, B);\n# }\n```","math_interpretation":"let A = RistrettoPoint::identity();","informal_interpretation":"Conditionally select between `self` and `other`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2275","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__conditional_select"},{"name":"ct_eq","display_name":"RistrettoPoint::ct_eq","impl_type":"RistrettoPoint","contract":"fn ct_eq(&self, other: &RistrettoPoint) -> (result:\n    Choice)/* requires clause in ConstantTimeEqSpecImplRistretto:\n       is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0) */\n\n    ensures\n// Two Ristretto points are equal iff they are in the same equivalence class\n\n        choice_is_true(result) == ristretto_equivalent(self.0, other.0),","referenced_specs":["choice_is_true","is_well_formed_edwards_point","ristretto_equivalent"],"file":"curve25519-dalek/src/ristretto.rs","line":1455,"module":"ristretto","doc_comment":"Test equality between two `RistrettoPoint`s.\n\n# Returns\n\n* `Choice(1)` if the two `RistrettoPoint`s are equal;\n* `Choice(0)` otherwise.","math_interpretation":"result = ristretto_equivalent(self.0, other.0)","informal_interpretation":"Test equality between two `RistrettoPoint`s.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1455","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristrettopoint__ct_eq"},{"name":"default","display_name":"RistrettoPoint::default","impl_type":"RistrettoPoint","contract":"fn default() -> (result: RistrettoPoint)\n    ensures\n        is_identity_edwards_point(result.0),\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),","referenced_specs":["is_identity_edwards_point","is_in_even_subgroup","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1412,"module":"ristretto","doc_comment":"","math_interpretation":"O (identity in E/~)","informal_interpretation":"Returns the default (identity) Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1412","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__default"},{"name":"double_and_compress_batch_verus","display_name":"RistrettoPoint::double_and_compress_batch_verus","impl_type":"RistrettoPoint","contract":"pub fn double_and_compress_batch_verus(points: &[RistrettoPoint]) -> (result: Vec<\n    CompressedRistretto,\n>)\n    requires\n        forall|i: int|\n            0 <= i < points@.len() ==> is_well_formed_edwards_point(#[trigger] points@[i].0),\n    ensures\n        result@.len() == points@.len(),\n        // Functional correctness: each result[i] = compress(2 * points[i])\n        forall|i: int|\n            0 <= i < result@.len() ==> {\n                let point_affine = edwards_point_as_affine(#[trigger] points@[i].0);\n                let doubled_affine = edwards_double(point_affine.0, point_affine.1);\n                #[trigger] result@[i].0@ == spec_ristretto_compress_affine(\n                    doubled_affine.0,\n                    doubled_affine.1,\n                )@\n            },","referenced_specs":["edwards_double","edwards_point_as_affine","is_well_formed_edwards_point","spec_ristretto_compress_affine"],"file":"curve25519-dalek/src/ristretto.rs","line":925,"module":"ristretto","doc_comment":"Verus-compatible version that takes a slice instead of IntoIterator.\nUse this for verification; the original double_and_compress_batch API is external_body.\n\nREFACTORING FOR VERUS:\n- Iterator patterns (.map().collect()) replaced with explicit while loops\n- IntoIterator trait replaced with concrete slice type\n- Vec to slice conversion wrapped in external_body helper (batch_invert_vec)\n- Closures replaced with inline code using Verus-compatible wrappers\n(conditional_assign_generic, conditional_negate_field_element, negate_field)\n\nSpec: each output[i] = compress(2 * points[i])","math_interpretation":"result@.len() = points@.len()","informal_interpretation":"Verus-compatible version that takes a slice instead of IntoIterator.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L925","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristrettopoint__double_and_compress_batch_verus"},{"name":"from_hash_verus","display_name":"RistrettoPoint::from_hash_verus","impl_type":"RistrettoPoint","contract":"pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(&hash_bytes),\n        // Uniform hash output produces uniformly distributed point\n        is_uniform_bytes(&hash_bytes) ==> is_uniform_ristretto_point(&result),","referenced_specs":["edwards_point_as_affine","is_in_even_subgroup","is_uniform_bytes","is_uniform_ristretto_point","is_well_formed_edwards_point","spec_ristretto_from_uniform_bytes"],"file":"curve25519-dalek/src/ristretto.rs","line":1308,"module":"ristretto","doc_comment":"Verus-compatible version of from_hash that takes finalized hash bytes directly.\n\nThis function is designed for Verus verification. It takes the 64-byte\nhash output directly, avoiding GenericArray complexity.\n\n# Inputs\n\n* `hash_bytes`: 64-byte hash output (e.g., from SHA-512)\n\n# Returns\n\nA RistrettoPoint derived from the hash","math_interpretation":"edwards_point_as_affine(result.0) = spec_ristretto_from_uniform_bytes(hash_bytes)","informal_interpretation":"Verus-compatible version of from_hash that takes finalized hash bytes directly.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1308","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__from_hash_verus"},{"name":"hash_from_bytes_verus","display_name":"RistrettoPoint::hash_from_bytes_verus","impl_type":"RistrettoPoint","contract":"pub fn hash_from_bytes_verus(input: &[u8]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        // Uniform input bytes produce uniformly distributed point\n        is_uniform_bytes(input) ==> is_uniform_ristretto_point(&result),","referenced_specs":["is_in_even_subgroup","is_uniform_bytes","is_uniform_ristretto_point","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1259,"module":"ristretto","doc_comment":"Verus-compatible version of hash_from_bytes that uses SHA-512.\n\nThis function is designed for Verus verification and directly computes\na SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n\n# Inputs\n\n* `input`: a byte slice to hash\n\n# Returns\n\nA RistrettoPoint derived from the hash","math_interpretation":"is_uniform_bytes(input) = > is_uniform_ristretto_point(result)","informal_interpretation":"Verus-compatible version of hash_from_bytes that uses SHA-512.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1259","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__hash_from_bytes_verus"},{"name":"identity","display_name":"RistrettoPoint::identity","impl_type":"RistrettoPoint","contract":"fn identity() -> (result: RistrettoPoint)\n    ensures\n        is_identity_edwards_point(result.0),\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),","referenced_specs":["is_identity_edwards_point","is_in_even_subgroup","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1398,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1398","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristrettopoint__identity"},{"name":"mul","display_name":"RistrettoPoint::mul","impl_type":"RistrettoPoint","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)\n// requires clause inherited from MulSpecImpl::mul_req:\n//   scalar.bytes[31] <= 127 && is_well_formed_edwards_point(self.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            edwards_point_as_affine(self.0),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","mul_req","scalar_to_nat"],"file":"curve25519-dalek/src/ristretto.rs","line":1825,"module":"ristretto","doc_comment":"Scalar multiplication: compute `scalar * self`.","math_interpretation":"(n,P) -> [n]P in E/~, scalar mult","informal_interpretation":"Scalar multiplication of a Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1825","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__mul"},{"name":"mul_assign","display_name":"RistrettoPoint::mul_assign","impl_type":"RistrettoPoint","contract":"fn mul_assign(&mut self, scalar: &'b Scalar)\n    requires\n        scalar.bytes[31] <= 127,\n        is_well_formed_edwards_point(old(self).0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = [scalar] * old(self)\n        edwards_point_as_affine(self.0) == edwards_scalar_mul(\n            edwards_point_as_affine(old(self).0),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat"],"file":"curve25519-dalek/src/ristretto.rs","line":1801,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(self.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1801","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__mul_assign"},{"name":"mul_base","display_name":"RistrettoPoint::mul_base","impl_type":"RistrettoPoint","contract":"pub fn mul_base(scalar: &Scalar) -> (result: Self)\n    requires\n        scalar.bytes[31] <= 127,\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B where B is the Ristretto basepoint\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ristretto_basepoint"],"file":"curve25519-dalek/src/ristretto.rs","line":1868,"module":"ristretto","doc_comment":"Fixed-base scalar multiplication by the Ristretto base point.\n\nUses precomputed basepoint tables when the `precomputed-tables` feature\nis enabled, trading off increased code size for ~4x better performance.","math_interpretation":"n -> [n]B, B = Ristretto basepoint","informal_interpretation":"Scalar multiplication of the Ristretto basepoint.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1868","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristrettopoint__mul_base"},{"name":"multiscalar_mul_verus","display_name":"RistrettoPoint::multiscalar_mul_verus","impl_type":"RistrettoPoint","contract":"pub fn multiscalar_mul_verus<S, P, I, J>(scalars: I, points: J) -> (result:\n    RistrettoPoint) where\n    S: Borrow<Scalar>,\n    P: Borrow<RistrettoPoint>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = P> + Clone,\n\n    requires\n        spec_scalars_from_iter::<S, I>(scalars).len() == spec_edwards_from_ristretto_iter::<\n            P,\n            J,\n        >(points).len(),\n        forall|i: int|\n            0 <= i < spec_edwards_from_ristretto_iter::<P, J>(points).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_edwards_from_ristretto_iter::<P, J>(points)[i],\n            ),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            spec_edwards_from_ristretto_iter::<P, J>(points),\n        ),","referenced_specs":["edwards_point_as_affine","is_well_formed_edwards_point","spec_edwards_from_ristretto_iter","spec_scalars_from_iter","sum_of_scalar_muls"],"file":"curve25519-dalek/src/ristretto.rs","line":1971,"module":"ristretto","doc_comment":"Verus-compatible version of multiscalar_mul (constant-time).\nDelegates to EdwardsPoint::multiscalar_mul_verus.","math_interpretation":"spec_edwards_from_ristretto_iter::<P, J>(points)","informal_interpretation":"Verus-compatible version of multiscalar_mul (constant-time).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1971","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__multiscalar_mul_verus"},{"name":"neg","display_name":"RistrettoPoint::neg","impl_type":"RistrettoPoint","contract":"fn neg(self) -> (result:\n    RistrettoPoint)\n// requires clause inherited from NegSpecImpl::neg_req:\n//   fe51_limbs_bounded(&self.0.X, 52) && fe51_limbs_bounded(&self.0.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),","referenced_specs":["edwards_neg","edwards_point_as_affine","fe51_limbs_bounded","is_well_formed_edwards_point","neg_req"],"file":"curve25519-dalek/src/ristretto.rs","line":1767,"module":"ristretto","doc_comment":"","math_interpretation":"P -> -P in E/~","informal_interpretation":"Negates a Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1767","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__neg_L1767"},{"name":"neg","display_name":"RistrettoPoint::neg","impl_type":"RistrettoPoint","contract":"fn neg(self) -> (result:\n    RistrettoPoint)\n// requires clause inherited from NegSpecImpl::neg_req:\n//   fe51_limbs_bounded(&self.0.X, 52) && fe51_limbs_bounded(&self.0.T, 52)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_neg(edwards_point_as_affine(self.0)),","referenced_specs":["edwards_neg","edwards_point_as_affine","fe51_limbs_bounded","is_well_formed_edwards_point","neg_req"],"file":"curve25519-dalek/src/ristretto.rs","line":1767,"module":"ristretto","doc_comment":"","math_interpretation":"P -> -P in E/~","informal_interpretation":"Negates a Ristretto point.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1785","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__neg_L1767"},{"name":"optional_multiscalar_mul_verus","display_name":"RistrettoPoint::optional_multiscalar_mul_verus","impl_type":"RistrettoPoint","contract":"pub fn optional_multiscalar_mul_verus<S, I, J>(scalars: I, points: J) -> (result: Option<\n    RistrettoPoint,\n>) where\n    S: Borrow<Scalar>,\n    I: Iterator<Item = S> + Clone,\n    J: Iterator<Item = Option<RistrettoPoint>> + Clone,\n\n    requires\n        spec_scalars_from_iter::<S, I>(scalars).len()\n            == spec_optional_edwards_from_ristretto_iter::<J>(points).len(),\n        forall|i: int|\n            0 <= i < spec_optional_edwards_from_ristretto_iter::<J>(points).len() && (\n            #[trigger] spec_optional_edwards_from_ristretto_iter::<J>(points)[i]).is_some()\n                ==> is_well_formed_edwards_point(\n                spec_optional_edwards_from_ristretto_iter::<J>(points)[i].unwrap(),\n            ),\n    ensures\n        result.is_some() <==> all_points_some(\n            spec_optional_edwards_from_ristretto_iter::<J>(points),\n        ),\n        result.is_some() ==> is_well_formed_edwards_point(result.unwrap().0),\n        result.is_some() ==> edwards_point_as_affine(result.unwrap().0) == sum_of_scalar_muls(\n            spec_scalars_from_iter::<S, I>(scalars),\n            unwrap_points(spec_optional_edwards_from_ristretto_iter::<J>(points)),\n        ),","referenced_specs":["all_points_some","edwards_point_as_affine","is_well_formed_edwards_point","spec_optional_edwards_from_ristretto_iter","spec_scalars_from_iter","sum_of_scalar_muls","unwrap_points"],"file":"curve25519-dalek/src/ristretto.rs","line":2025,"module":"ristretto","doc_comment":"Verus-compatible version of optional_multiscalar_mul.\nDelegates to EdwardsPoint::optional_multiscalar_mul_verus.","math_interpretation":"unwrap_points(spec_optional_edwards_from_ristretto_iter::<J>(points))","informal_interpretation":"Verus-compatible version of optional_multiscalar_mul.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2025","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__optional_multiscalar_mul_verus"},{"name":"sub","display_name":"RistrettoPoint::sub","impl_type":"RistrettoPoint","contract":"fn sub(self, other: &'b RistrettoPoint) -> (result:\n    RistrettoPoint)\n// requires (from SubSpecImpl::sub_req): is_well_formed_edwards_point(self.0) && is_well_formed_edwards_point(other.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_sub(\n            edwards_point_as_affine(self.0).0,\n            edwards_point_as_affine(self.0).1,\n            edwards_point_as_affine(other.0).0,\n            edwards_point_as_affine(other.0).1,\n        ),","referenced_specs":["edwards_point_as_affine","edwards_sub","is_well_formed_edwards_point","sub_req"],"file":"curve25519-dalek/src/ristretto.rs","line":1558,"module":"ristretto","doc_comment":"","math_interpretation":"(P,Q) -> P - Q in E/~","informal_interpretation":"Subtracts two Ristretto points.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1558","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"ristrettopoint__sub"},{"name":"sub_assign","display_name":"RistrettoPoint::sub_assign","impl_type":"RistrettoPoint","contract":"fn sub_assign(&mut self, _rhs: &RistrettoPoint)\n    requires\n        is_well_formed_edwards_point(old(self).0),\n        is_well_formed_edwards_point(_rhs.0),\n    ensures\n        is_well_formed_edwards_point(self.0),\n        // Functional correctness: self = old(self) - rhs\n        edwards_point_as_affine(self.0) == edwards_sub(\n            edwards_point_as_affine(old(self).0).0,\n            edwards_point_as_affine(old(self).0).1,\n            edwards_point_as_affine(_rhs.0).0,\n            edwards_point_as_affine(_rhs.0).1,\n        ),","referenced_specs":["edwards_point_as_affine","edwards_sub","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1583,"module":"ristretto","doc_comment":"","math_interpretation":"edwards_point_as_affine(old(self).0).1","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1583","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__sub_assign"},{"name":"sum","display_name":"RistrettoPoint::sum","impl_type":"RistrettoPoint","contract":"fn sum<I>(iter: I) -> (result: Self) where I: Iterator<Item = T>\n    requires\n        forall|i: int|\n            0 <= i < spec_edwards_from_ristretto_iter::<T, I>(iter).len()\n                ==> is_well_formed_edwards_point(\n                #[trigger] spec_edwards_from_ristretto_iter::<T, I>(iter)[i],\n            ),\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == sum_of_points(\n            spec_edwards_from_ristretto_iter::<T, I>(iter),\n        ),","referenced_specs":["edwards_point_as_affine","is_well_formed_edwards_point","spec_edwards_from_ristretto_iter","sum_of_points"],"file":"curve25519-dalek/src/ristretto.rs","line":1686,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1686","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__sum"},{"name":"zeroize","display_name":"RistrettoPoint::zeroize","impl_type":"RistrettoPoint","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.0[i] == 0u8,","referenced_specs":[],"file":"curve25519-dalek/src/ristretto.rs","line":2397,"module":"ristretto","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 32 = > #[trigger] self.0[i] = 0u8","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2407","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristrettopoint__zeroize"},{"name":"mul","display_name":"Scalar::mul","impl_type":"Scalar","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)\n// requires clause inherited from MulSpecImpl::mul_req:\n//   scalar.bytes[31] <= 127 && is_well_formed_edwards_point(self.0)\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            edwards_point_as_affine(self.0),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","mul_req","scalar_to_nat"],"file":"curve25519-dalek/src/ristretto.rs","line":1825,"module":"ristretto","doc_comment":"Scalar multiplication: compute `scalar * self`.","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"Scalar multiplication: compute `scalar * self`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1846","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__mul_L1825"},{"name":"mul","display_name":"Scalar::mul","impl_type":"Scalar","contract":"fn mul(self, scalar: &'b Scalar) -> (result:\n    RistrettoPoint)/* requires clause in MulSpecImpl<&Scalar> for &RistrettoBasepointTable in arithm_trait_specs.rs:\n    requires scalar.bytes[31] <= 127\n*/\n\n    ensures\n        is_well_formed_edwards_point(result.0),\n        // Functional correctness: result = [scalar] * B\n        edwards_point_as_affine(result.0) == edwards_scalar_mul(\n            spec_ristretto_basepoint(),\n            scalar_to_nat(scalar),\n        ),","referenced_specs":["edwards_point_as_affine","edwards_scalar_mul","is_well_formed_edwards_point","scalar_to_nat","spec_ristretto_basepoint"],"file":"curve25519-dalek/src/ristretto.rs","line":2176,"module":"ristretto","doc_comment":"","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L2200","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__mul_L2176"},{"name":"coset4","display_name":"coset4","impl_type":"","contract":"fn coset4(&self) -> (result: [EdwardsPoint; 4])\n    requires\n        is_well_formed_edwards_point(self.0),\n    ensures\n        is_well_formed_edwards_point(result[0]),\n        is_well_formed_edwards_point(result[1]),\n        is_well_formed_edwards_point(result[2]),\n        is_well_formed_edwards_point(result[3]),\n        is_ristretto_coset(result, self.0),","referenced_specs":["is_ristretto_coset","is_well_formed_edwards_point"],"file":"curve25519-dalek/src/ristretto.rs","line":1085,"module":"ristretto","doc_comment":"Return the coset self + E\\[4\\], for debugging.\n\nThe result represents the Ristretto equivalence class of self -\nall 4 points map to the same Ristretto point.","math_interpretation":"is_well_formed_edwards_point(result[0])","informal_interpretation":"Return the coset self + E\\[4\\], for debugging.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1085","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"ristretto__coset4"},{"name":"elligator_ristretto_flavor","display_name":"elligator_ristretto_flavor","impl_type":"","contract":"pub(crate) fn elligator_ristretto_flavor(r_0: &FieldElement) -> (result: RistrettoPoint)\n    ensures\n// The result is the Elligator map applied to r_0\n\n        edwards_point_as_affine(result.0) == spec_elligator_ristretto_flavor(\n            spec_field_element(r_0),\n        ),\n        // The result is a valid Ristretto point: well-formed and in the even subgroup\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),","referenced_specs":["edwards_point_as_affine","is_in_even_subgroup","is_well_formed_edwards_point","spec_elligator_ristretto_flavor","spec_field_element"],"file":"curve25519-dalek/src/ristretto.rs","line":1115,"module":"ristretto","doc_comment":"Computes the Ristretto Elligator map. This is the\n[`MAP`](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448-04#section-4.3.4)\nfunction defined in the Ristretto spec.\n\n# Note\n\nThis method is not public because it's just used for hashing\nto a point -- proper elligator support is deferred for now.","math_interpretation":"is_well_formed_edwards_point(result.0)","informal_interpretation":"Computes the Ristretto Elligator map. This is the","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1115","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"ristretto__elligator_ristretto_flavor"},{"name":"from_uniform_bytes","display_name":"from_uniform_bytes","impl_type":"","contract":"pub fn from_uniform_bytes(bytes: &[u8; 64]) -> (result: RistrettoPoint)\n    ensures\n        is_well_formed_edwards_point(result.0),\n        is_in_even_subgroup(result.0),\n        edwards_point_as_affine(result.0) == spec_ristretto_from_uniform_bytes(bytes),\n        // Uniform input bytes produce uniformly distributed point\n        is_uniform_bytes(bytes) ==> is_uniform_ristretto_point(&result),","referenced_specs":["edwards_point_as_affine","is_in_even_subgroup","is_uniform_bytes","is_uniform_ristretto_point","is_well_formed_edwards_point","spec_ristretto_from_uniform_bytes"],"file":"curve25519-dalek/src/ristretto.rs","line":1331,"module":"ristretto","doc_comment":"Construct a `RistrettoPoint` from 64 bytes of data.\n\nIf the input bytes are uniformly distributed, the resulting\npoint will be uniformly distributed over the group, and its\ndiscrete log with respect to other points should be unknown.\n\n# Implementation\n\nThis function splits the input array into two 32-byte halves,\ntakes the low 255 bits of each half mod p, applies the\nRistretto-flavored Elligator map to each, and adds the results.","math_interpretation":"edwards_point_as_affine(result.0) = spec_ristretto_from_uniform_bytes(bytes)","informal_interpretation":"Construct a `RistrettoPoint` from 64 bytes of data.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L1331","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"ristretto__from_uniform_bytes"},{"name":"step_1","display_name":"step_1","impl_type":"","contract":"pub(super) fn step_1(repr: &CompressedRistretto) -> (result: (Choice, Choice, FieldElement))\n    ensures\n// s has 51-bit limb bounds (ensured by from_bytes)\n\n        fe51_limbs_bounded(&result.2, 51),\n        // Parsed value matches the bytes-to-field-element spec\n        spec_field_element(&result.2) == spec_field_element_from_bytes(&repr.0),\n        // s_encoding_is_canonical: true iff re-encoding s gives the original bytes\n        choice_is_true(result.0) == (spec_fe51_to_bytes(&result.2) == repr.0@),\n        // s_is_negative: true iff low bit of canonical encoding is 1\n        choice_is_true(result.1) == (spec_fe51_to_bytes(&result.2)[0] & 1 == 1),\n        // s_is_negative matches the math-level sign bit of the decoded value\n        choice_is_true(result.1) == math_is_negative(spec_field_element_from_bytes(&repr.0)),","referenced_specs":["choice_is_true","fe51_limbs_bounded","math_is_negative","spec_fe51_to_bytes","spec_field_element","spec_field_element_from_bytes"],"file":"curve25519-dalek/src/ristretto.rs","line":385,"module":"ristretto","doc_comment":"Decompress step 1: Parse and validate the Ristretto encoding.\n\nReturns (s_encoding_is_canonical, s_is_negative, s) where:\n- s_encoding_is_canonical: true iff input bytes are canonical (< p)\n- s_is_negative: true iff s has its low bit set\n- s: the field element decoded from the compressed representation","math_interpretation":"choice_is_true(result.1) = math_is_negative(spec_field_element_from_bytes(repr.0))","informal_interpretation":"Decompress step 1: Parse and validate the Ristretto encoding.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L385","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"ristretto__step_1"},{"name":"step_2","display_name":"step_2","impl_type":"","contract":"pub(super) fn step_2(s: FieldElement) -> (result: (Choice, Choice, Choice, RistrettoPoint))\n    ensures\n// Z is set to ONE by construction\n\n        spec_field_element(&result.3.0.Z) == 1,\n        // T is the product of X and Y in affine form (Z = 1)\n        spec_field_element(&result.3.0.T) == math_field_mul(\n            spec_field_element(&result.3.0.X),\n            spec_field_element(&result.3.0.Y),\n        ),\n        // If decoding succeeds, the output point is well-formed and in the even subgroup\n        choice_is_true(result.0) ==> is_well_formed_edwards_point(result.3.0),\n        choice_is_true(result.0) ==> is_in_even_subgroup(result.3.0),\n        // t_is_negative reflects the sign bit of T\n        choice_is_true(result.1) == math_is_negative(spec_field_element(&result.3.0.T)),\n        // y_is_zero reflects whether Y is zero\n        choice_is_true(result.2) == (spec_field_element(&result.3.0.Y) == 0),","referenced_specs":["choice_is_true","is_in_even_subgroup","is_well_formed_edwards_point","math_field_mul","math_is_negative","spec_field_element"],"file":"curve25519-dalek/src/ristretto.rs","line":435,"module":"ristretto","doc_comment":"Decompress step 2: Compute the Edwards point from the field element s.\n\nReturns (ok, t_is_negative, y_is_zero, point) where:\n- ok: true iff the sqrt_ratio succeeded (s encodes a valid point)\n- t_is_negative: true iff T coordinate has low bit set\n- y_is_zero: true iff Y coordinate is zero\n- point: the computed RistrettoPoint","math_interpretation":"choice_is_true(result.1) = math_is_negative(spec_field_element(result.3.0.T))","informal_interpretation":"Decompress step 2: Compute the Edwards point from the field element s.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/ristretto.rs#L435","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"ristretto__step_2"},{"name":"add","display_name":"Scalar::add","impl_type":"Scalar","contract":"fn add(self, _rhs: &'a Scalar) -> (result: Scalar)\n    ensures\n        bytes32_to_nat(&result.bytes) == (bytes32_to_nat(&self.bytes) + bytes32_to_nat(\n            &_rhs.bytes,\n        )) % group_order(),\n        is_canonical_scalar(&result),","referenced_specs":["add","bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":662,"module":"scalar","doc_comment":"","math_interpretation":"nat(result) = (nat(self) + bytes32_to_nat( _rhs.bytes, )) mod L, result < L","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L662","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__add"},{"name":"add_assign","display_name":"Scalar::add_assign","impl_type":"Scalar","contract":"fn add_assign(&mut self, _rhs: &'a Scalar)\n    requires\n        is_canonical_scalar(old(self)),\n        is_canonical_scalar(_rhs),\n    ensures\n        bytes32_to_nat(&self.bytes) == (bytes32_to_nat(&old(self).bytes) + bytes32_to_nat(\n            &_rhs.bytes,\n        )) % group_order(),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":698,"module":"scalar","doc_comment":"","math_interpretation":"nat(self) = (bytes32_to_nat(old(self).bytes) + bytes32_to_nat( _rhs.bytes, )) mod L","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L728","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__add_assign"},{"name":"as_bytes","display_name":"Scalar::as_bytes","impl_type":"Scalar","contract":"pub const fn as_bytes(&self) -> (result: &[u8; 32])\n    ensures\n        result == &self.bytes,\n        scalar_to_nat(self) == bytes32_to_nat(&result),","referenced_specs":["bytes32_to_nat","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1605,"module":"scalar","doc_comment":"View the little-endian byte encoding of the integer representing this Scalar.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet s: Scalar = Scalar::ZERO;\n\nassert!(s.as_bytes() == &[0u8; 32]);\n```","math_interpretation":"&Scalar -> &[u8; 32]","informal_interpretation":"Returns a reference to the scalar's byte representation.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1619","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__as_bytes"},{"name":"as_radix_16","display_name":"Scalar::as_radix_16","impl_type":"Scalar","contract":"pub(crate) fn as_radix_16(&self) -> (result: [i8; 64])\n    requires\n// Top bit must be clear (scalar < 2^255)\n\n        self.bytes[31] <= 127,\n    ensures\n// Result digits are in valid range\n\n        is_valid_radix_16(&result),\n        // Simple bounds: all digits in [-8, 8] for easy access\n        radix_16_all_bounded(&result),\n        // Reconstruction property: digits reconstruct the scalar value\n        reconstruct_radix_16(result@) == scalar_to_nat(self) as int,","referenced_specs":["is_valid_radix_16","radix_16_all_bounded","reconstruct","reconstruct_radix_16","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":2443,"module":"scalar","doc_comment":"Write this scalar in radix 16, with coefficients in \\\\([-8,8)\\\\),\ni.e., compute \\\\(a\\_i\\\\) such that\n$$\na = a\\_0 + a\\_1 16\\^1 + \\cdots + a_{63} 16\\^{63},\n$$\nwith \\\\(-8 \\leq a_i < 8\\\\) for \\\\(0 \\leq i < 63\\\\) and \\\\(-8 \\leq a_{63} \\leq 8\\\\).\n\nThe largest value that can be decomposed like this is just over \\\\(2^{255}\\\\). Thus, in\norder to not error, the top bit MUST NOT be set, i.e., `Self` MUST be less than\n\\\\(2^{255}\\\\).","math_interpretation":"a = a\\_0 + a\\_1 16\\^1 + \\cdots + a_{63} 16\\^{63},","informal_interpretation":"Write this scalar in radix 16, with coefficients in \\\\([-8,8)\\\\),","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2456","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__as_radix_16"},{"name":"as_radix_2w","display_name":"Scalar::as_radix_2w","impl_type":"Scalar","contract":"pub(crate) fn as_radix_2w(&self, w: usize) -> (result:\n    [i8; 64])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        4 <= w <= 8,\n        // For w=4 (radix 16), top bit must be clear\n        w == 4 ==> self.bytes[31] <= 127,\n    ensures\n        ({\n            let digits_count = if w < 8 {\n                (256 + (w as int) - 1) / (w as int)\n            } else {\n                (256 + (w as int) - 1) / (w as int) + 1\n            };\n            // Result digits are in valid range for the given window size\n            is_valid_radix_2w(&result, w as nat, digits_count as nat)\n                &&\n            // Reconstruction property: digits reconstruct the scalar value\n            reconstruct_radix_2w(result@.take(digits_count), w as nat) == scalar_to_nat(\n                self,\n            ) as int\n        }),","referenced_specs":["is_valid_radix_2w","reconstruct","reconstruct_radix_2w","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":2701,"module":"scalar","doc_comment":"Creates a representation of a Scalar in radix \\\\( 2^w \\\\) with \\\\(w = 4, 5, 6, 7, 8\\\\) for\nuse with the Pippenger algorithm. Higher radixes are not supported to save cache space.\nRadix 256 is near-optimal even for very large inputs.\n\nRadix below 16 or above 256 is prohibited.\nThis method returns digits in a fixed-sized array, excess digits are zeroes.\n\nFor radix 16, `Self` must be less than \\\\(2^{255}\\\\). This is because most integers larger\nthan \\\\(2^{255}\\\\) are unrepresentable in the form described below for \\\\(w = 4\\\\). This\nwould be true for \\\\(w = 8\\\\) as well, but it is compensated for by increasing the size\nhint by 1.\n\n## Scalar representation\n\nRadix \\\\(2\\^w\\\\), with \\\\(n = ceil(256/w)\\\\) coefficients in \\\\([-(2\\^w)/2,(2\\^w)/2)\\\\),\ni.e., scalar is represented using digits \\\\(a\\_i\\\\) such that\n$$\na = a\\_0 + a\\_1 2\\^1w + \\cdots + a_{n-1} 2\\^{w*(n-1)},\n$$\nwith \\\\(-2\\^w/2 \\leq a_i < 2\\^w/2\\\\) for \\\\(0 \\leq i < (n-1)\\\\) and \\\\(-2\\^w/2 \\leq a_{n-1} \\leq 2\\^w/2\\\\).\n","math_interpretation":"Radix \\\\(2\\^w\\\\), with \\\\(n = ceil(256/w)\\\\) coefficients in \\\\([-(2\\^w)/2,(2\\^w)/2)\\\\),","informal_interpretation":"Creates a representation of a Scalar in radix \\\\( 2^w \\\\) with \\\\(w = 4, 5, 6, 7, 8\\\\) for","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2590","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__as_radix_2w"},{"name":"batch_invert","display_name":"Scalar::batch_invert","impl_type":"Scalar","contract":"pub fn batch_invert(inputs: &mut [Scalar]) -> (result:\n    Scalar)/* <VERIFICATION NOTE>\n Refactored for Verus: Index loops instead of iterators, manual Vec construction, ..\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the modular inverse of the product of all original inputs\n\n        is_inverse_of_nat(&result, product_of_scalars(old(inputs)@)),\n        // Each input is replaced with its inverse\n        forall|i: int|\n            0 <= i < inputs.len() ==> #[trigger] is_inverse(\n                &(#[trigger] old(inputs)[i]),\n                &(#[trigger] inputs[i]),\n            ),","referenced_specs":["is_inverse","is_inverse_of_nat","product_of_scalars"],"file":"curve25519-dalek/src/scalar.rs","line":1725,"module":"scalar","doc_comment":"Given a slice of nonzero (possibly secret) `Scalar`s,\ncompute their inverses in a batch.\n\n# Return\n\nEach element of `inputs` is replaced by its inverse.\n\nThe product of all inverses is returned.\n\n# Warning\n\nAll input `Scalars` **MUST** be nonzero.  If you cannot\n*prove* that this is the case, you **SHOULD NOT USE THIS\nFUNCTION**.\n\n# Example\n\n```\n# use curve25519_dalek::scalar::Scalar;\n# fn main() {\nlet mut scalars = [\nScalar::from(3u64),\nScalar::from(5u64),\nScalar::from(7u64),\nScalar::from(11u64),\n];\n\nlet allinv = Scalar::batch_invert(&mut scalars);\n\nassert_eq!(allinv, Scalar::from(3*5*7*11u64).invert());\nassert_eq!(scalars[0], Scalar::from(3u64).invert());\nassert_eq!(scalars[1], Scalar::from(5u64).invert());\nassert_eq!(scalars[2], Scalar::from(7u64).invert());\nassert_eq!(scalars[3], Scalar::from(11u64).invert());\n# }\n```","math_interpretation":"let mut scalars = [","informal_interpretation":"Given a slice of nonzero (possibly secret) `Scalar`s,","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1739","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__batch_invert"},{"name":"bits_le","display_name":"Scalar::bits_le","impl_type":"Scalar","contract":"pub(crate) fn bits_le(&self) -> impl DoubleEndedIterator<Item = bool> + '_ {\n    /* <VERIFICATION NOTE>\n    - Opaque types like Iterator not supported in Verus yet\n    - see bits_le_verus below for a Verus-compatible version\n    </VERIFICATION NOTE> */\n    (0..256).map(|i| {\n        // As i runs from 0..256, the bottom 3 bits index the bit, while the upper bits index\n        // the byte. Since self.bytes is little-endian at the byte level, this iterator is\n        // little-endian on the bit level\n        ((self.bytes[i >> 3] >> (i & 7)) & 1u8) == 1\n    })\n}\n</ORIGINAL CODE> */\n/// Get the bits of the scalar as an array, in little-endian order\n/* <VERIFICATION NOTE>\n     This is a Verus-compatible version of bits_le from above that returns an array instead of an iterator\n    </VERIFICATION NOTE> */\n#[allow(dead_code)]\npub(crate) fn bits_le(&self) -> (result: [bool; 256])\n    ensures\n        bits_to_nat(&result) == bytes32_to_nat(&self.bytes),","referenced_specs":["bits_to_nat","bytes32_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":2167,"module":"scalar","doc_comment":"","math_interpretation":"bits_to_nat(result) = nat(self)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2198","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__bits_le"},{"name":"ct_eq","display_name":"Scalar::ct_eq","impl_type":"Scalar","contract":"fn ct_eq(&self, other: &Self) -> (result: Choice)\n    ensures\n        choice_is_true(result) == (self.bytes == other.bytes),","referenced_specs":["choice_is_true"],"file":"curve25519-dalek/src/scalar.rs","line":463,"module":"scalar","doc_comment":"","math_interpretation":"a =? b in Z/LZ (constant-time)","informal_interpretation":"Constant-time equality comparison of two scalars.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L457","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__ct_eq"},{"name":"from","display_name":"Scalar::from","impl_type":"Scalar","contract":"fn from(x: u8) -> (result: Scalar)\n    ensures\n        scalar_to_nat(&result) == x as nat,","referenced_specs":["scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1125,"module":"scalar","doc_comment":"","math_interpretation":"n: u64 -> Scalar(n mod L)","informal_interpretation":"Converts a u64 integer to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1139","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_L1125"},{"name":"from","display_name":"Scalar::from","impl_type":"Scalar","contract":"fn from(x: u8) -> (result: Scalar)\n    ensures\n        scalar_to_nat(&result) == x as nat,","referenced_specs":["scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1125,"module":"scalar","doc_comment":"","math_interpretation":"n: u64 -> Scalar(n mod L)","informal_interpretation":"Converts a u64 integer to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1159","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_L1125"},{"name":"from","display_name":"Scalar::from","impl_type":"Scalar","contract":"fn from(x: u32) -> (result: Scalar)\n    ensures\n        scalar_to_nat(&result) == x as nat,","referenced_specs":["scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1181,"module":"scalar","doc_comment":"","math_interpretation":"n: u64 -> Scalar(n mod L)","informal_interpretation":"Converts a u64 integer to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1195","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_L1181"},{"name":"from","display_name":"Scalar::from","impl_type":"Scalar","contract":"fn from(x: u64) -> (result: Scalar)\n    ensures\n        scalar_to_nat(&result) == x as nat,","referenced_specs":["scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1235,"module":"scalar","doc_comment":"Construct a scalar from the given `u64`.\n\n# Inputs\n\nAn `u64` to convert to a `Scalar`.\n\n# Returns\n\nA `Scalar` corresponding to the input `u64`.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet fourtytwo = Scalar::from(42u64);\nlet six = Scalar::from(6u64);\nlet seven = Scalar::from(7u64);\n\nassert!(fourtytwo == six * seven);\n```","math_interpretation":"n: u64 -> Scalar(n mod L)","informal_interpretation":"Converts a u64 integer to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1249","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_L1235"},{"name":"from","display_name":"Scalar::from","impl_type":"Scalar","contract":"fn from(x: u128) -> (result: Scalar)\n    ensures\n        scalar_to_nat(&result) == x as nat,","referenced_specs":["scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1267,"module":"scalar","doc_comment":"","math_interpretation":"n: u64 -> Scalar(n mod L)","informal_interpretation":"Converts a u64 integer to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1281","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_L1267"},{"name":"from_bytes_mod_order","display_name":"Scalar::from_bytes_mod_order","impl_type":"Scalar","contract":"pub fn from_bytes_mod_order(bytes: [u8; 32]) -> (result: Scalar)\n    ensures\n// Result is equivalent to input modulo the group order\n\n        bytes32_to_nat(&result.bytes) % group_order() == bytes32_to_nat(&bytes) % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":264,"module":"scalar","doc_comment":"Construct a `Scalar` by reducing a 256-bit little-endian integer\nmodulo the group order \\\\( \\ell \\\\).","math_interpretation":"b -> LE(b) mod L, L = group order","informal_interpretation":"Constructs a Scalar by reducing a 256-bit integer modulo the group order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L258","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_bytes_mod_order"},{"name":"from_bytes_mod_order_wide","display_name":"Scalar::from_bytes_mod_order_wide","impl_type":"Scalar","contract":"pub fn from_bytes_mod_order_wide(input: &[u8; 64]) -> (result: Scalar)\n    ensures\n        bytes32_to_nat(&result.bytes) % group_order() == bytes_seq_to_nat(input@)\n            % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),\n        // Uniformity: reducing 512 uniform bits mod L (≈2^253) produces nearly uniform scalar.\n        // Bias: at most L/2^512 ≈ 2^-259 statistical distance from uniform (cryptographically negligible).\n        is_uniform_bytes(input) ==> is_uniform_scalar(&result),","referenced_specs":["bytes32_to_nat","bytes_seq_to_nat","group_order","is_canonical_scalar","is_uniform_bytes","is_uniform_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":293,"module":"scalar","doc_comment":"","math_interpretation":"b: [u8;64] -> LE(b) mod L","informal_interpretation":"Constructs a Scalar by reducing a 512-bit integer modulo the group order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L287","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_bytes_mod_order_wide"},{"name":"from_canonical_bytes","display_name":"Scalar::from_canonical_bytes","impl_type":"Scalar","contract":"pub fn from_canonical_bytes(bytes: [u8; 32]) -> (result: CtOption<Scalar>)\n    ensures\n        bytes32_to_nat(&bytes) < group_order() ==> ct_option_has_value(result),\n        bytes32_to_nat(&bytes) >= group_order() ==> !ct_option_has_value(result),\n        ct_option_has_value(result) ==> bytes32_to_nat(&ct_option_value(result).bytes)\n            % group_order() == bytes32_to_nat(&bytes) % group_order(),","referenced_specs":["bytes32_to_nat","ct_option_has_value","ct_option_value","group_order"],"file":"curve25519-dalek/src/scalar.rs","line":356,"module":"scalar","doc_comment":"","math_interpretation":"b -> Some(s) if LE(b) < L else None","informal_interpretation":"Constructs a Scalar from canonical bytes (rejects non-canonical).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L350","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__from_canonical_bytes"},{"name":"from_hash_verus","display_name":"Scalar::from_hash_verus","impl_type":"Scalar","contract":"pub fn from_hash_verus(hash_bytes: [u8; 64]) -> (result: Scalar)\n    ensures\n        is_uniform_bytes(&hash_bytes) ==> is_uniform_scalar(&result),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),","referenced_specs":["is_canonical_scalar","is_uniform_bytes","is_uniform_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":1564,"module":"scalar","doc_comment":"Verus-compatible version of from_hash that takes pre-finalized hash bytes.\n\nThis function is designed for Verus verification and takes a byte array directly\ninstead of a generic Digest type. For regular code, use `from_hash` instead.\n\n# Inputs\n\n* `hash_bytes`: a 64-byte array representing the output of a hash function\n\n# Returns\n\nA scalar reduced modulo the group order","math_interpretation":"h: [u8;64] -> LE(h) mod L","informal_interpretation":"Constructs a Scalar from a 64-byte hash output reduced mod L.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1578","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"scalar__from_hash_verus"},{"name":"hash_from_bytes_verus","display_name":"Scalar::hash_from_bytes_verus","impl_type":"Scalar","contract":"pub fn hash_from_bytes_verus(input: &[u8]) -> (result: Scalar)\n    ensures\n        is_uniform_bytes(input) ==> is_uniform_scalar(&result),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),","referenced_specs":["is_canonical_scalar","is_uniform_bytes","is_uniform_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":1489,"module":"scalar","doc_comment":"Verus-compatible version of hash_from_bytes that uses SHA-512.\n\nThis function is designed for Verus verification and directly computes\na SHA-512 hash. For regular code with generic hash functions, use `hash_from_bytes` instead.\n\n# Inputs\n\n* `input`: a byte slice to hash\n\n# Returns\n\nA scalar reduced modulo the group order","math_interpretation":"input -> SHA-512(input) mod L","informal_interpretation":"Hashes input bytes with SHA-512 and reduces to a Scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1503","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__hash_from_bytes_verus"},{"name":"index","display_name":"Scalar::index","impl_type":"Scalar","contract":"fn index(&self, _index: usize) -> (result: &u8)\n    requires\n        _index < 32,\n    ensures\n        result == &self.bytes[_index as int],","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":481,"module":"scalar","doc_comment":"Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.","math_interpretation":"result = self.bytes[_index ]","informal_interpretation":"Index the bytes of the representative for this `Scalar`.  Mutation is not permitted.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L475","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__index"},{"name":"invert","display_name":"Scalar::invert","impl_type":"Scalar","contract":"pub fn invert(&self) -> (result: Scalar)\n    requires\n        is_canonical_scalar(self),\n    ensures\n// Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n        (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n        is_canonical_scalar(&result),","referenced_specs":["group_order","is_canonical_scalar","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1653,"module":"scalar","doc_comment":"Given a nonzero `Scalar`, compute its multiplicative inverse.\n\n# Warning\n\n`self` **MUST** be nonzero.  If you cannot\n*prove* that this is the case, you **SHOULD NOT USE THIS\nFUNCTION**.\n\n# Returns\n\nThe multiplicative inverse of the this `Scalar`.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\n// x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\nlet X: Scalar = Scalar::from_bytes_mod_order([\n0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n]);\n// 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\nlet XINV: Scalar = Scalar::from_bytes_mod_order([\n0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n]);\n\nlet inv_X: Scalar = X.invert();\nassert!(XINV == inv_X);\nlet should_be_one: Scalar = &inv_X * &X;\nassert!(should_be_one == Scalar::ONE);\n```","math_interpretation":"s -> s^(-1) mod L, multiplicative inverse","informal_interpretation":"Computes the multiplicative inverse of a scalar modulo the group order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1667","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__invert"},{"name":"is_canonical","display_name":"Scalar::is_canonical","impl_type":"Scalar","contract":"fn is_canonical(&self) -> (result: Choice)\n    ensures\n// Result is true iff the scalar satisfies Scalar invariants #1 and #2\n\n        choice_is_true(result) == is_canonical_scalar(self),","referenced_specs":["choice_is_true","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":2999,"module":"scalar","doc_comment":"Check whether this `Scalar` is the canonical representative mod \\\\(\\ell\\\\). This is not\npublic because any `Scalar` that is publicly observed is reduced, by scalar invariant #2.","math_interpretation":"// Result is true iff the scalar satisfies Scalar invariants #1 and #2 result = self < L","informal_interpretation":"Check whether this `Scalar` is the canonical representative mod \\\\(\\ell\\\\). This is not","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2877","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__is_canonical"},{"name":"mul","display_name":"Scalar::mul","impl_type":"Scalar","contract":"fn mul(self, _rhs: &'b Scalar) -> (result: Scalar)\n    ensures\n        bytes32_to_nat(&result.bytes) % group_order() == (bytes32_to_nat(&self.bytes)\n            * bytes32_to_nat(&_rhs.bytes)) % group_order(),\n        is_canonical_scalar(&result),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":580,"module":"scalar","doc_comment":"","math_interpretation":"nat(result) mod L = (nat(self) * nat(_rhs)) mod L, result < L","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L578","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__mul_L580"},{"name":"mul_assign","display_name":"Scalar::mul_assign","impl_type":"Scalar","contract":"fn mul_assign(&mut self, _rhs: &'a Scalar)\n    requires\n        is_canonical_scalar(old(self)),\n        is_canonical_scalar(_rhs),\n    ensures\n        bytes32_to_nat(&self.bytes) % group_order() == (bytes32_to_nat(&old(self).bytes)\n            * bytes32_to_nat(&_rhs.bytes)) % group_order(),\n        is_canonical_scalar(self),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":501,"module":"scalar","doc_comment":"","math_interpretation":"nat(self) mod L = (bytes32_to_nat(old(self).bytes) * nat(_rhs)) mod L, self < L","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L495","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__mul_assign"},{"name":"neg","display_name":"Scalar::neg","impl_type":"Scalar","contract":"fn neg(self) -> (result: Scalar)\n    ensures\n        (scalar_to_nat(self) + scalar_to_nat(&result)) % group_order() == 0,","referenced_specs":["group_order","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":857,"module":"scalar","doc_comment":"","math_interpretation":"s -> -s mod L","informal_interpretation":"Negates a scalar modulo the group order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L884","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__neg_L857"},{"name":"neg","display_name":"Scalar::neg","impl_type":"Scalar","contract":"fn neg(self) -> (result: Scalar)\n    ensures\n        (scalar_to_nat(&self) + scalar_to_nat(&result)) % group_order() == 0,","referenced_specs":["group_order","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":961,"module":"scalar","doc_comment":"","math_interpretation":"s -> -s mod L","informal_interpretation":"Negates a scalar modulo the group order.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L975","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__neg_L961"},{"name":"non_adjacent_form","display_name":"Scalar::non_adjacent_form","impl_type":"Scalar","contract":"pub(crate) fn non_adjacent_form(&self, w: usize) -> (result:\n    [i8; 256])\n// VERIFICATION NOTE: PROOF BYPASS\n\n    requires\n        2 <= w <= 8,\n    ensures\n// result encodes the same integer\n\n        reconstruct(result@) == scalar_to_nat(self) as int,\n        // result digits follow NAF rules\n        is_valid_naf(result@, w as nat),","referenced_specs":["is_valid_naf","reconstruct","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":2305,"module":"scalar","doc_comment":"Compute a width-\\\\(w\\\\) \"Non-Adjacent Form\" of this scalar.\n\nA width-\\\\(w\\\\) NAF of a positive integer \\\\(k\\\\) is an expression\n$$\nk = \\sum_{i=0}\\^m n\\_i 2\\^i,\n$$\nwhere each nonzero\ncoefficient \\\\(n\\_i\\\\) is odd and bounded by \\\\(|n\\_i| < 2\\^{w-1}\\\\),\n\\\\(n\\_{m-1}\\\\) is nonzero, and at most one of any \\\\(w\\\\) consecutive\ncoefficients is nonzero.  (Hankerson, Menezes, Vanstone; def 3.32).\n\nThe length of the NAF is at most one more than the length of\nthe binary representation of \\\\(k\\\\).  This is why the\n`Scalar` type maintains an invariant (invariant #1) that the top bit is\n\\\\(0\\\\), so that the NAF of a scalar has at most 256 digits.\n\nIntuitively, this is like a binary expansion, except that we\nallow some coefficients to grow in magnitude up to\n\\\\(2\\^{w-1}\\\\) so that the nonzero coefficients are as sparse\nas possible.\n\nWhen doing scalar multiplication, we can then use a lookup\ntable of precomputed multiples of a point to add the nonzero\nterms \\\\( k_i P \\\\).  Using signed digits cuts the table size\nin half, and using odd digits cuts the table size in half\nagain.\n\nTo compute a \\\\(w\\\\)-NAF, we use a modification of Algorithm 3.35 of HMV:\n\n1. \\\\( i \\gets 0 \\\\)\n2. While \\\\( k \\ge 1 \\\\):\n1. If \\\\(k\\\\) is odd, \\\\( n_i \\gets k \\operatorname{mods} 2^w \\\\), \\\\( k \\gets k - n_i \\\\).\n2. If \\\\(k\\\\) is even, \\\\( n_i \\gets 0 \\\\).\n3. \\\\( k \\gets k / 2 \\\\), \\\\( i \\gets i + 1 \\\\).\n3. Return \\\\( n_0, n_1, ... , \\\\)\n\nHere \\\\( \\bar x = x \\operatorname{mods} 2^w \\\\) means the\n\\\\( \\bar x \\\\) with \\\\( \\bar x \\equiv x \\pmod{2^w} \\\\) and\n\\\\( -2^{w-1} \\leq \\bar x < 2^{w-1} \\\\).\n\nWe implement this by scanning across the bits of \\\\(k\\\\) from\nleast-significant bit to most-significant-bit.\nWrite the bits of \\\\(k\\\\) as\n$$\nk = \\sum\\_{i=0}\\^m k\\_i 2^i,\n$$\nand split the sum as\n$$\nk = \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n$$\nwhere the first part is \\\\( k \\mod 2^w \\\\).\n\nIf \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w < 2^{w-1} \\\\), then we emit\n\\\\( n_0 = k \\mod 2^w \\\\).  Instead of computing\n\\\\( k - n_0 \\\\), we just advance \\\\(w\\\\) bits and reindex.\n\nIf \\\\( k \\mod 2^w\\\\) is odd, and \\\\( k \\mod 2^w \\ge 2^{w-1} \\\\), then\n\\\\( n_0 = k \\operatorname{mods} 2^w = k \\mod 2^w - 2^w \\\\).\nThe quantity \\\\( k - n_0 \\\\) is\n$$\n\\begin{aligned}\nk - n_0 &= \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n- \\sum\\_{i=0}^{w-1} k\\_i 2^i + 2^w \\\\\\\\\n&= 2^w + 2^w \\sum\\_{i=0} k\\_{i+w} 2^i\n\\end{aligned}\n$$\nso instead of computing the subtraction, we can set a carry\nbit, advance \\\\(w\\\\) bits, and reindex.\n\nIf \\\\( k \\mod 2^w\\\\) is even, we emit \\\\(0\\\\), advance 1 bit\nand reindex.  In fact, by setting all digits to \\\\(0\\\\)\ninitially, we don't need to emit anything.","math_interpretation":"k = \\sum_{i=0}\\^m n\\_i 2\\^i,","informal_interpretation":"Compute a width-\\\\(w\\\\) \"Non-Adjacent Form\" of this scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2318","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__non_adjacent_form"},{"name":"reduce","display_name":"Scalar::reduce","impl_type":"Scalar","contract":"fn reduce(&self) -> (result: Scalar)\n    ensures\n// Result is equivalent to input modulo the group order\n\n        bytes32_to_nat(&result.bytes) % group_order() == bytes32_to_nat(&self.bytes)\n            % group_order(),\n        // Result satisfies Scalar invariants #1 and #2\n        is_canonical_scalar(&result),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":2917,"module":"scalar","doc_comment":"Reduce this `Scalar` modulo \\\\(\\ell\\\\).","math_interpretation":"nat(result) mod L = nat(self) mod L","informal_interpretation":"Reduce this `Scalar` modulo \\\\(\\ell\\\\).","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2805","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__reduce"},{"name":"sub","display_name":"Scalar::sub","impl_type":"Scalar","contract":"fn sub(self, _rhs: &'b Scalar) -> (result:\n    Scalar)/* VERIFICATION NOTE: preconditions are added to the SpecImpl above\n    requires\n        is_canonical_scalar(self),\n        is_canonical_scalar(rhs)\n    */\n\n    ensures\n        bytes32_to_nat(&result.bytes) % group_order() == (bytes32_to_nat(&self.bytes)\n            - bytes32_to_nat(&_rhs.bytes)) % (group_order() as int),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":736,"module":"scalar","doc_comment":"","math_interpretation":"nat(result) mod L = (nat(self) - nat(_rhs)) mod (L )","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L763","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__sub"},{"name":"sub_assign","display_name":"Scalar::sub_assign","impl_type":"Scalar","contract":"fn sub_assign(&mut self, _rhs: &'a Scalar)\n    requires\n        is_canonical_scalar(old(self)),\n        is_canonical_scalar(_rhs),\n    ensures\n        bytes32_to_nat(&self.bytes) % group_order() == (bytes32_to_nat(&old(self).bytes)\n            - bytes32_to_nat(&_rhs.bytes)) % (group_order() as int),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar"],"file":"curve25519-dalek/src/scalar.rs","line":821,"module":"scalar","doc_comment":"","math_interpretation":"nat(self) mod L = (bytes32_to_nat(old(self).bytes) - nat(_rhs)) mod (L )","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L848","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__sub_assign"},{"name":"sum","display_name":"Scalar::sum","impl_type":"Scalar","contract":"fn sum<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":1030,"module":"scalar","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1059","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__sum"},{"name":"to_bytes","display_name":"Scalar::to_bytes","impl_type":"Scalar","contract":"pub const fn to_bytes(&self) -> (result: [u8; 32])\n    ensures\n        result == self.bytes,\n        scalar_to_nat(self) == bytes32_to_nat(&result),","referenced_specs":["bytes32_to_nat","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1586,"module":"scalar","doc_comment":"Convert this `Scalar` to its underlying sequence of bytes.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\nlet s: Scalar = Scalar::ZERO;\n\nassert!(s.to_bytes() == [0u8; 32]);\n```","math_interpretation":"s in Z/LZ -> [u8; 32] little-endian","informal_interpretation":"Returns the canonical byte encoding of a scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1600","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"scalar__to_bytes"},{"name":"to_radix_2w_size_hint","display_name":"Scalar::to_radix_2w_size_hint","impl_type":"Scalar","contract":"pub(crate) fn to_radix_2w_size_hint(w: usize) -> usize\n    requires\n        4 <= w <= 8,\n    returns\n        if w < 8 {\n            (256 + w - 1) / (w as int)\n        } else {\n            (256 + w - 1) / (w as int) + 1\n        } as usize,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":2642,"module":"scalar","doc_comment":"Returns a size hint indicating how many entries of the return\nvalue of `to_radix_2w` are nonzero.","math_interpretation":"","informal_interpretation":"Returns a size hint indicating how many entries of the return","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2531","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__to_radix_2w_size_hint"},{"name":"unpack","display_name":"Scalar::unpack","impl_type":"Scalar","contract":"pub fn unpack(&self) -> (result:\n    UnpackedScalar)\n// VERIFICATION NOTE: VERIFIED (changed pub(crate) to pub)\n\n    ensures\n        limbs_bounded(&result),\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        scalar52_to_nat(&result) == bytes32_to_nat(&self.bytes),\n        is_canonical_scalar(self) ==> is_canonical_scalar52(&result),","referenced_specs":["bytes32_to_nat","is_canonical_scalar","is_canonical_scalar52","limb_prod_bounded_u128","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":2902,"module":"scalar","doc_comment":"Unpack this `Scalar` to an `UnpackedScalar` for faster arithmetic.","math_interpretation":"nat(result) = nat(self)","informal_interpretation":"Unpack this `Scalar` to an `UnpackedScalar` for faster arithmetic.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2791","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__unpack"},{"name":"zeroize","display_name":"Scalar::zeroize","impl_type":"Scalar","contract":"fn zeroize(&mut self)\n    ensures\n        forall|i: int| 0 <= i < 32 ==> #[trigger] self.bytes[i] == 0u8,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":1303,"module":"scalar","doc_comment":"","math_interpretation":"forall|i: int| 0 <= i < 32 = > #[trigger] self.bytes[i] = 0u8","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1317","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__zeroize"},{"name":"invert","display_name":"UnpackedScalar::invert","impl_type":"UnpackedScalar","contract":"pub fn invert(&self) -> (result: Scalar)\n    requires\n        is_canonical_scalar(self),\n    ensures\n// Result is the multiplicative inverse: result * self ≡ 1 (mod group_order)\n\n        (scalar_to_nat(&result) * scalar_to_nat(self)) % group_order() == 1,\n        is_canonical_scalar(&result),","referenced_specs":["group_order","is_canonical_scalar","scalar_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":1653,"module":"scalar","doc_comment":"Given a nonzero `Scalar`, compute its multiplicative inverse.\n\n# Warning\n\n`self` **MUST** be nonzero.  If you cannot\n*prove* that this is the case, you **SHOULD NOT USE THIS\nFUNCTION**.\n\n# Returns\n\nThe multiplicative inverse of the this `Scalar`.\n\n# Example\n\n```\nuse curve25519_dalek::scalar::Scalar;\n\n// x = 2238329342913194256032495932344128051776374960164957527413114840482143558222\nlet X: Scalar = Scalar::from_bytes_mod_order([\n0x4e, 0x5a, 0xb4, 0x34, 0x5d, 0x47, 0x08, 0x84,\n0x59, 0x13, 0xb4, 0x64, 0x1b, 0xc2, 0x7d, 0x52,\n0x52, 0xa5, 0x85, 0x10, 0x1b, 0xcc, 0x42, 0x44,\n0xd4, 0x49, 0xf4, 0xa8, 0x79, 0xd9, 0xf2, 0x04,\n]);\n// 1/x = 6859937278830797291664592131120606308688036382723378951768035303146619657244\nlet XINV: Scalar = Scalar::from_bytes_mod_order([\n0x1c, 0xdc, 0x17, 0xfc, 0xe0, 0xe9, 0xa5, 0xbb,\n0xd9, 0x24, 0x7e, 0x56, 0xbb, 0x01, 0x63, 0x47,\n0xbb, 0xba, 0x31, 0xed, 0xd5, 0xa9, 0xbb, 0x96,\n0xd5, 0x0b, 0xcd, 0x7a, 0x3f, 0x96, 0x2a, 0x0f,\n]);\n\nlet inv_X: Scalar = X.invert();\nassert!(XINV == inv_X);\nlet should_be_one: Scalar = &inv_X * &X;\nassert!(should_be_one == Scalar::ONE);\n```","math_interpretation":"// x = 2238329342913194256032495932344128051776374960164957527413114840482143558222","informal_interpretation":"Given a nonzero `Scalar`, compute its multiplicative inverse.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3180","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":true,"id":"unpackedscalar__invert"},{"name":"montgomery_invert","display_name":"UnpackedScalar::montgomery_invert","impl_type":"UnpackedScalar","contract":"pub fn montgomery_invert(&self) -> (result:\n    UnpackedScalar)/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n// Must be canonical for montgomery_square/montgomery_mul\n\n        is_canonical_scalar52(self),\n    ensures\n        limb_prod_bounded_u128(result.limbs, result.limbs, 5),\n        // Output is canonical\n        is_canonical_scalar52(&result),\n        (scalar52_to_nat(&result) * scalar52_to_nat(self)) % group_order() == (\n        montgomery_radix() * montgomery_radix())\n            % group_order(),\n// Equivalent to: from_montgomery(result) * from_montgomery(self) ≡ 1 (mod L)\n// Expressed in Montgomery form: (result/R) * (self/R) ≡ 1, i.e., result * self ≡ R² (mod L)","referenced_specs":["group_order","is_canonical_scalar52","limb_prod_bounded_u128","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":3221,"module":"scalar","doc_comment":"Inverts an UnpackedScalar in Montgomery form.\n\n# Preconditions\n- Input must be canonical for `montgomery_square`/`montgomery_mul`\n","math_interpretation":"(nat(result) * nat(self)) mod L = ( montgomery_radix() * montgomery_radix()) mod L","informal_interpretation":"Inverts an UnpackedScalar in Montgomery form.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3090","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"unpackedscalar__montgomery_invert"},{"name":"pack","display_name":"UnpackedScalar::pack","impl_type":"UnpackedScalar","contract":"fn pack(&self) -> (result: Scalar)\n    requires\n        limbs_bounded(self),\n    ensures\n        bytes32_to_nat(&result.bytes) == scalar52_to_nat(self) % pow2(256),\n        // VERIFICATION NOTE: If input is canonical (< group order), output satisfies Scalar invariants\n        scalar52_to_nat(self) < group_order() ==> is_canonical_scalar(&result),","referenced_specs":["bytes32_to_nat","group_order","is_canonical_scalar","limbs_bounded","scalar52_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":3137,"module":"scalar","doc_comment":"Pack the limbs of this `UnpackedScalar` into a `Scalar`.","math_interpretation":"nat(result) = nat(self) mod pow2(256)","informal_interpretation":"Pack the limbs of this `UnpackedScalar` into a `Scalar`.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3010","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"unpackedscalar__pack"},{"name":"bot_half","display_name":"bot_half","impl_type":"","contract":"fn bot_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the lower 4 bits (lower nibble) of x\n\n        result == x % 16,\n        // Result is in range [0, 15]\n        result <= 15,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":2124,"module":"scalar","doc_comment":"","math_interpretation":"result = x mod 16","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2137","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__bot_half"},{"name":"clamp_integer","display_name":"clamp_integer","impl_type":"","contract":"pub const fn clamp_integer(bytes: [u8; 32]) -> (result: [u8; 32])\n    ensures\n// Result is a valid clamped integer for X25519\n\n        is_clamped_integer(&result),\n        // The result matches the spec function\n        result == spec_clamp_integer(bytes),\n        // All bytes except 0 and 31 remain unchanged\n        forall|i: int| 1 <= i < 31 ==> #[trigger] result[i] == bytes[i],\n        // Low byte preserves bits 3-7\n        result[0] & 0b1111_1000 == bytes[0] & 0b1111_1000,\n        // High byte preserves bits 0-5\n        result[31] & 0b0011_1111 == bytes[31] & 0b0011_1111,","referenced_specs":["is_clamped_integer","spec_clamp_integer"],"file":"curve25519-dalek/src/scalar.rs","line":3573,"module":"scalar","doc_comment":"_Clamps_ the given little-endian representation of a 32-byte integer. Clamping the value puts\nit in the range:\n\n**n ∈ 2^254 + 8\\*{0, 1, 2, 3, . . ., 2^251 − 1}**\n\n# Explanation of clamping\n\nFor Curve25519, h = 8, and multiplying by 8 is the same as a binary left-shift by 3 bits.\nIf you take a secret scalar value between 2^251 and 2^252 – 1 and left-shift by 3 bits\nthen you end up with a 255-bit number with the most significant bit set to 1 and\nthe least-significant three bits set to 0.\n\nThe Curve25519 clamping operation takes **an arbitrary 256-bit random value** and\nclears the most-significant bit (making it a 255-bit number), sets the next bit, and then\nclears the 3 least-significant bits. In other words, it directly creates a scalar value that is\nin the right form and pre-multiplied by the cofactor.\n\nSee [here](https://neilmadden.blog/2020/05/28/whats-the-curve25519-clamping-all-about/) for\nmore details.","math_interpretation":"clamp: clear bits 0-2 and 255, set bit 254","informal_interpretation":"Clamps a 32-byte integer for use as an X25519 scalar.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3439","category":"tracked","is_public":true,"is_libsignal":true,"has_spec":true,"has_proof":false,"id":"scalar__clamp_integer"},{"name":"product","display_name":"product","impl_type":"","contract":"fn product<I>(iter: I) -> Self\nwhere\n    I: Iterator<Item = T>,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":1002,"module":"scalar","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L1028","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__product"},{"name":"read_le_u64_into","display_name":"read_le_u64_into","impl_type":"","contract":"fn read_le_u64_into(src: &[u8], dst: &mut [u64])/* VERIFICATION NOTE:\nPROOF BYPASS\n*/\n\n    requires\n        src.len() == 8 * old(dst).len(),\n    ensures\n        dst.len() == old(dst).len(),\n        forall|i: int|\n            0 <= i < dst.len() ==> {\n                let byte_seq = Seq::new(8, |j: int| src[i * 8 + j] as u8);\n                #[trigger] dst[i] as nat == bytes_seq_to_nat(byte_seq)\n            },","referenced_specs":["bytes_seq_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":3494,"module":"scalar","doc_comment":"Read one or more u64s stored as little endian bytes.\n\n## Panics\nPanics if `src.len() != 8 * dst.len()`.","math_interpretation":"Panics if `src.len() != 8 * dst.len()`.","informal_interpretation":"Read one or more u64s stored as little endian bytes.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L3359","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"scalar__read_le_u64_into"},{"name":"square_multiply","display_name":"square_multiply","impl_type":"","contract":"fn square_multiply(\n    y: &mut UnpackedScalar,\n    squarings: usize,\n    x: &UnpackedScalar,\n)/*  VERIFICATION NOTE:\n- This function was initially inside the body of montgomery_invert, but was moved outside for Verus\n*/\n\n    requires\n// Both inputs must be canonical for montgomery_square/montgomery_mul\n\n        is_canonical_scalar52(old(y)),\n        is_canonical_scalar52(x),\n    ensures\n        limb_prod_bounded_u128(y.limbs, y.limbs, 5),\n        // Output is canonical\n        is_canonical_scalar52(y),\n        // VERIFICATION NOTE: Changed postcondition from the original incorrect version\n        // which used `montgomery_radix()` instead of `pow(montgomery_radix(), pow2(squarings))`\n        (scalar52_to_nat(y) * pow(montgomery_radix() as int, pow2(squarings as nat)) as nat)\n            % group_order() == (pow(scalar52_to_nat(old(y)) as int, pow2(squarings as nat))\n            * scalar52_to_nat(x)) % (group_order() as int),","referenced_specs":["group_order","is_canonical_scalar52","limb_prod_bounded_u128","montgomery_radix","scalar52_to_nat"],"file":"curve25519-dalek/src/scalar.rs","line":3021,"module":"scalar","doc_comment":"","math_interpretation":"limb_prod_bounded_u128(y.limbs, y.limbs, 5)","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2899","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__square_multiply"},{"name":"top_half","display_name":"top_half","impl_type":"","contract":"fn top_half(x: u8) -> (result:\n    u8)/* <VERIFICATION NOTE>\n- Adjust the spec as needed for the proof of as_radix_16\n</VERIFICATION NOTE> */\n\n    ensures\n// Result is the upper 4 bits (upper nibble) of x\n\n        result == x / 16,\n        // Result is in range [0, 15]\n        result <= 15,","referenced_specs":[],"file":"curve25519-dalek/src/scalar.rs","line":2144,"module":"scalar","doc_comment":"","math_interpretation":"result = x / 16","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/scalar.rs#L2157","category":"tracked","is_public":false,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"scalar__top_half"},{"name":"from","display_name":"LookupTable<AffineNielsPoint>::from","impl_type":"LookupTable<AffineNielsPoint>","contract":"fn from(P: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*P),\n    */\n\n    ensures\n        is_valid_lookup_table_affine(result.0, *P, 8 as nat),\n        // All entries have bounded limbs\n        lookup_table_affine_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_lookup_table_affine","lookup_table_affine_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":360,"module":"window","doc_comment":"Create a lookup table from an EdwardsPoint (affine version)\nConstructs [P, 2P, 3P, ..., Size*P]","math_interpretation":"is_valid_lookup_table_affine(result.0, *P, 8 )","informal_interpretation":"Create a lookup table from an EdwardsPoint (affine version)","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L360","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"lookuptable_affinenielspoint__from"},{"name":"select","display_name":"LookupTable<AffineNielsPoint>::select","impl_type":"LookupTable<AffineNielsPoint>","contract":"pub fn select(&self, x: i8) -> (result: T)\n    ensures\n        (x > 0 ==> result == self.0[(x - 1) as int]),\n        // Generic T prevented type-specific specs for x == 0 and x < 0","referenced_specs":[],"file":"curve25519-dalek/src/window.rs","line":86,"module":"window","doc_comment":"","math_interpretation":"(x > 0 = > result = self.0[(x - 1) ])","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L103","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"lookuptable_affinenielspoint__select"},{"name":"from","display_name":"LookupTable<ProjectiveNielsPoint>::from","impl_type":"LookupTable<ProjectiveNielsPoint>","contract":"fn from(P: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*P),\n        sum_of_limbs_bounded(&P.Y, &P.X, u64::MAX),\n    */\n\n    ensures\n        is_valid_lookup_table_projective(result.0, *P, 8 as nat),\n        // All table entries have bounded limbs for subsequent arithmetic\n        lookup_table_projective_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_lookup_table_projective","lookup_table_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":291,"module":"window","doc_comment":"Create a lookup table from an EdwardsPoint\nConstructs [P, 2P, 3P, ..., Size*P]","math_interpretation":"is_valid_lookup_table_projective(result.0, *P, 8 )","informal_interpretation":"Create a lookup table from an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L291","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"lookuptable_projectivenielspoint__from"},{"name":"select","display_name":"LookupTable<ProjectiveNielsPoint>::select","impl_type":"LookupTable<ProjectiveNielsPoint>","contract":"pub fn select(&self, x: i8) -> (result: ProjectiveNielsPoint)\n    requires\n        -8 <= x,\n        x <= 8,\n        // Table entries must have bounded limbs\n        lookup_table_projective_limbs_bounded(self.0),\n    ensures\n// Formal specification for all cases:\n\n        (x > 0 ==> result == self.0[(x - 1) as int]),\n        (x == 0 ==> result == identity_projective_niels()),\n        (x < 0 ==> result == negate_projective_niels(self.0[((-x) - 1) as int])),\n        // Limb bounds for the result (derived from table bounds)\n        fe51_limbs_bounded(&result.Y_plus_X, 54),\n        fe51_limbs_bounded(&result.Y_minus_X, 54),\n        fe51_limbs_bounded(&result.Z, 54),\n        fe51_limbs_bounded(&result.T2d, 54),","referenced_specs":["fe51_limbs_bounded","identity_projective_niels","lookup_table_projective_limbs_bounded","negate_projective_niels"],"file":"curve25519-dalek/src/window.rs","line":158,"module":"window","doc_comment":"Given \\\\(-8 \\leq x \\leq 8\\\\), return \\\\(xP\\\\) in constant time.\n\nWhere P is the base point that was used to create this lookup table.\nThis table stores [P, 2P, 3P, ..., 8P] (for radix-16).","math_interpretation":"(x < 0 = > result = negate_projective_niels(self.0[((-x) - 1) ]))","informal_interpretation":"Given \\\\(-8 \\leq x \\leq 8\\\\), return \\\\(xP\\\\) in constant time.","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L158","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"lookuptable_projectivenielspoint__select"},{"name":"from","display_name":"NafLookupTable5::from","impl_type":"NafLookupTable5","contract":"fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table5_projective(result.0, *A),\n        naf_lookup_table5_projective_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table5_projective","naf_lookup_table5_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":540,"module":"window","doc_comment":"Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)","math_interpretation":"naf_lookup_table5_projective_limbs_bounded(result.0)","informal_interpretation":"Create a NAF lookup table from an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L540","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"naflookuptable5__from_L540"},{"name":"from","display_name":"NafLookupTable5::from","impl_type":"NafLookupTable5","contract":"fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table5_affine(result.0, *A),\n        naf_lookup_table5_affine_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table5_affine","naf_lookup_table5_affine_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":598,"module":"window","doc_comment":"Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)","math_interpretation":"is_valid_naf_lookup_table5_affine(result.0, *A), naf_lookup_table5_affine_limbs_bounded(result.0)","informal_interpretation":"Create a NAF lookup table from an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L598","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"naflookuptable5__from_L598"},{"name":"select","display_name":"NafLookupTable5<AffineNielsPoint>::select","impl_type":"NafLookupTable5<AffineNielsPoint>","contract":"pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 16);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable5<ProjectiveNielsPoint>\nimpl NafLookupTable5<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable5<AffineNielsPoint>\nimpl NafLookupTable5<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\nimpl<T: Copy> Clone for NafLookupTable5<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nverus! {\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_projective(result.0, *A),\n     naf_lookup_table5_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_projective(result.0, *A));\n     assume(naf_lookup_table5_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_affine(result.0, *A),\n     naf_lookup_table5_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_affine(result.0, *A));\n     assume(naf_lookup_table5_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!\nverus! {\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n/* VERIFICATION NOTE:\n   - Changed from pub(crate) to pub to allow Verus verification\n     of requires/ensures clauses that reference self.0.\n   - Removed Clone from #[derive(Copy, Clone)] because Verus does not support\n     autoderive Clone for arrays. Manual Clone impl provided outside verus! macro.\n\n   ORIGINAL CODE:\n   #[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n   #[derive(Copy, Clone)]\n   pub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n*/\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy)]\npub struct NafLookupTable8<T>(pub [T; 64]);\n\n/* VERIFICATION NOTE: Replaced generic NafLookupTable8<T>::select with concrete implementations\n   to allow type-specific specs.\n\n   ORIGINAL CODE:\n   impl<T: Copy> NafLookupTable8<T> {\npub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table5_affine","is_valid_naf_lookup_table5_projective","is_valid_naf_lookup_table8_affine","is_valid_naf_lookup_table8_projective","is_well_formed_edwards_point","naf_lookup_table5_affine_limbs_bounded","naf_lookup_table5_projective_limbs_bounded","naf_lookup_table8_affine_limbs_bounded","naf_lookup_table8_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":464,"module":"window","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L501","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"naflookuptable5_affinenielspoint__select"},{"name":"select","display_name":"NafLookupTable5<ProjectiveNielsPoint>::select","impl_type":"NafLookupTable5<ProjectiveNielsPoint>","contract":"pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 16);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable5<ProjectiveNielsPoint>\nimpl NafLookupTable5<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable5<AffineNielsPoint>\nimpl NafLookupTable5<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^4 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, 7A, 9A, 11A, 13A, 15A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 16,  // x in {1, 3, 5, 7, 9, 11, 13, 15}\n     naf_lookup_table5_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 16);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\nimpl<T: Copy> Clone for NafLookupTable5<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\nimpl<T: Debug> Debug for NafLookupTable5<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n write!(f, \"NafLookupTable5({:?})\", self.0)\n    }\n}\n\nverus! {\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_projective(result.0, *A),\n     naf_lookup_table5_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_projective(result.0, *A));\n     assume(naf_lookup_table5_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable5<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table5_affine(result.0, *A),\n     naf_lookup_table5_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();8];\n let A2 = A.double();\n\n for i in 0..7 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A]\n let result = NafLookupTable5(Ai);\n proof {\n     assume(is_valid_naf_lookup_table5_affine(result.0, *A));\n     assume(naf_lookup_table5_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!\nverus! {\n\n/// Holds stuff up to 8. The only time we use tables this big is for precomputed basepoint tables\n/// and multiscalar multiplication (which requires alloc).\n/* VERIFICATION NOTE:\n   - Changed from pub(crate) to pub to allow Verus verification\n     of requires/ensures clauses that reference self.0.\n   - Removed Clone from #[derive(Copy, Clone)] because Verus does not support\n     autoderive Clone for arrays. Manual Clone impl provided outside verus! macro.\n\n   ORIGINAL CODE:\n   #[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n   #[derive(Copy, Clone)]\n   pub(crate) struct NafLookupTable8<T>(pub(crate) [T; 64]);\n*/\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\n#[derive(Copy)]\npub struct NafLookupTable8<T>(pub [T; 64]);\n\n/* VERIFICATION NOTE: Replaced generic NafLookupTable8<T>::select with concrete implementations\n   to allow type-specific specs.\n\n   ORIGINAL CODE:\n   impl<T: Copy> NafLookupTable8<T> {\npub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table5_affine","is_valid_naf_lookup_table5_projective","is_valid_naf_lookup_table8_affine","is_valid_naf_lookup_table8_projective","is_well_formed_edwards_point","naf_lookup_table5_affine_limbs_bounded","naf_lookup_table5_projective_limbs_bounded","naf_lookup_table8_affine_limbs_bounded","naf_lookup_table8_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":464,"module":"window","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L476","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"naflookuptable5_projectivenielspoint__select"},{"name":"from","display_name":"NafLookupTable8::from","impl_type":"NafLookupTable8","contract":"fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table8_projective(result.0, *A),\n        naf_lookup_table8_projective_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table8_projective","naf_lookup_table8_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":764,"module":"window","doc_comment":"Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)","math_interpretation":"naf_lookup_table8_projective_limbs_bounded(result.0)","informal_interpretation":"Create a NAF lookup table from an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L764","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"naflookuptable8__from_L764"},{"name":"from","display_name":"NafLookupTable8::from","impl_type":"NafLookupTable8","contract":"fn from(A: &'a EdwardsPoint) -> (result:\n    Self)/* Expected requires (if Verus supported from_req):\n        edwards_point_limbs_bounded(*A),\n        sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n        is_valid_edwards_point(*A),\n    */\n\n    ensures\n        is_valid_naf_lookup_table8_affine(result.0, *A),\n        naf_lookup_table8_affine_limbs_bounded(result.0),","referenced_specs":["edwards_point_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table8_affine","naf_lookup_table8_affine_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":823,"module":"window","doc_comment":"Create a NAF lookup table from an EdwardsPoint\nConstructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)","math_interpretation":"is_valid_naf_lookup_table8_affine(result.0, *A), naf_lookup_table8_affine_limbs_bounded(result.0)","informal_interpretation":"Create a NAF lookup table from an EdwardsPoint","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L823","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":false,"id":"naflookuptable8__from_L823"},{"name":"select","display_name":"NafLookupTable8<AffineNielsPoint>::select","impl_type":"NafLookupTable8<AffineNielsPoint>","contract":"pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table8_affine","is_valid_naf_lookup_table8_projective","is_well_formed_edwards_point","naf_lookup_table8_affine_limbs_bounded","naf_lookup_table8_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":679,"module":"window","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L718","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"naflookuptable8_affinenielspoint__select"},{"name":"select","display_name":"NafLookupTable8<ProjectiveNielsPoint>::select","impl_type":"NafLookupTable8<ProjectiveNielsPoint>","contract":"pub fn select(&self, x: usize) -> T {\n    debug_assert_eq!(x & 1, 1);\n    debug_assert!(x < 128);\n    self.0[x / 2]\n}\n   }\n*/\n\n/// Concrete select implementation for NafLookupTable8<ProjectiveNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<ProjectiveNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: ProjectiveNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_projective_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.Y_plus_X, 54),\n     fe51_limbs_bounded(&result.Y_minus_X, 54),\n     fe51_limbs_bounded(&result.Z, 54),\n     fe51_limbs_bounded(&result.T2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n/// Concrete select implementation for NafLookupTable8<AffineNielsPoint>\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl NafLookupTable8<AffineNielsPoint> {\n    /// Given public, odd \\\\( x \\\\) with \\\\( 0 < x < 2^7 \\\\), return \\\\(xA\\\\).\n    /// Table stores [1A, 3A, 5A, ..., 127A], so table[x/2] = x*A.\n    pub fn select(&self, x: usize) -> (result: AffineNielsPoint)\n requires\n     x & 1 == 1,  // x is odd\n     x < 128,  // x in {1, 3, 5, ..., 127}\n     naf_lookup_table8_affine_limbs_bounded(self.0),\n ensures\n     result == self.0[(x / 2) as int],\n     fe51_limbs_bounded(&result.y_plus_x, 54),\n     fe51_limbs_bounded(&result.y_minus_x, 54),\n     fe51_limbs_bounded(&result.xy2d, 54),\n    {\n #[cfg(not(verus_keep_ghost))]\n {\n     debug_assert_eq!(x & 1, 1);\n     debug_assert!(x < 128);\n }\n self.0[x / 2]\n    }\n}\n\n} // verus!\n// Manual Clone impl since derive(Clone) is not supported inside verus macro for arrays\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Copy> Clone for NafLookupTable8<T> {\n    fn clone(&self) -> Self {\n *self\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<T: Debug> Debug for NafLookupTable8<T> {\n    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {\n writeln!(f, \"NafLookupTable8([\")?;\n for i in 0..64 {\n     writeln!(f, \"\\t{:?},\", &self.0[i])?;\n }\n write!(f, \"])\")\n    }\n}\n\nverus! {\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<ProjectiveNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_projective(result.0, *A),\n     naf_lookup_table8_projective_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_projective_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_plus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Y_minus_X, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].Z, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].T2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_projective_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_projective_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_projective(result.0, *A));\n     assume(naf_lookup_table8_projective_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n#[cfg(any(feature = \"precomputed-tables\", feature = \"alloc\"))]\nimpl<'a> From<&'a EdwardsPoint> for NafLookupTable8<AffineNielsPoint> {\n    /// Create a NAF lookup table from an EdwardsPoint\n    /// Constructs [A, 3A, 5A, 7A, ..., 127A] (odd multiples)\n    fn from(A: &'a EdwardsPoint) -> (result:\n Self)/* Expected requires (if Verus supported from_req):\n     edwards_point_limbs_bounded(*A),\n     sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX),\n     is_valid_edwards_point(*A),\n */\n\n ensures\n     is_valid_naf_lookup_table8_affine(result.0, *A),\n     naf_lookup_table8_affine_limbs_bounded(result.0),\n    {\n // Preconditions assumed here since Verus does not support from_req\n proof {\n     assume(edwards_point_limbs_bounded(*A));\n     assume(sum_of_limbs_bounded(&A.Y, &A.X, u64::MAX));\n     assume(is_valid_edwards_point(*A));\n }\n\n let mut Ai = [A.as_affine_niels();64];\n let A2 = A.double();\n\n for i in 0..63 {\n     proof {\n         // A2 is 2*A, need to be well-formed for addition\n         assume(is_well_formed_edwards_point(A2));\n         // Additional requirement for EdwardsPoint + AffineNielsPoint\n         assume(sum_of_limbs_bounded(&A2.Z, &A2.Z, u64::MAX));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_plus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].y_minus_x, 54));\n         assume(fe51_limbs_bounded(&&Ai[i as int].xy2d, 54));\n     }\n     // ORIGINAL CODE: Ai[i + 1] = (&A2 + &Ai[i]).as_extended().as_affine_niels();\n     let sum = &A2 + &Ai[i];\n     proof {\n         assume(fe51_limbs_bounded(&sum.X, 54));\n         assume(fe51_limbs_bounded(&sum.Y, 54));\n         assume(fe51_limbs_bounded(&sum.Z, 54));\n         assume(fe51_limbs_bounded(&sum.T, 54));\n     }\n     let extended = sum.as_extended();\n     proof {\n         assume(edwards_point_limbs_bounded(extended));\n         assume(sum_of_limbs_bounded(&extended.Y, &extended.X, u64::MAX));\n     }\n     Ai[i + 1] = extended.as_affine_niels();\n }\n // Now Ai = [A, 3A, 5A, 7A, 9A, 11A, 13A, 15A, ..., 127A]\n let result = NafLookupTable8(Ai);\n proof {\n     assume(is_valid_naf_lookup_table8_affine(result.0, *A));\n     assume(naf_lookup_table8_affine_limbs_bounded(result.0));\n }\n result\n    }\n}\n\n} // verus!","referenced_specs":["edwards_point_limbs_bounded","fe51_limbs_bounded","from_req","is_valid_edwards_point","is_valid_naf_lookup_table8_affine","is_valid_naf_lookup_table8_projective","is_well_formed_edwards_point","naf_lookup_table8_affine_limbs_bounded","naf_lookup_table8_projective_limbs_bounded","sum_of_limbs_bounded"],"file":"curve25519-dalek/src/window.rs","line":679,"module":"window","doc_comment":"","math_interpretation":"","informal_interpretation":"","github_link":"https://github.com/Beneficial-AI-Foundation/dalek-lite/blob/main/curve25519-dalek/src/window.rs#L692","category":"tracked","is_public":true,"is_libsignal":false,"has_spec":true,"has_proof":true,"id":"naflookuptable8_projectivenielspoint__select"}]}