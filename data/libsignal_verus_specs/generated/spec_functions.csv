spec_function,source_path,source_line,definition,doc_comment,math_interpretation,informal_interpretation
u8_32_as_nat,curve25519-dalek/src/specs/core_specs.rs,20,pub open spec fn u8_32_as_nat(bytes: &[u8; 32]) -> nat {\n    (bytes[ 0] as nat) * pow2( 0 * 8) +\n    (bytes[ 1] as nat) * pow2( 1 * 8) +\n    (bytes[ 2] as nat) * pow2( 2 * 8) +\n    (bytes[ 3] as nat) * pow2( 3 * 8) +\n    (bytes[ 4] as nat) * pow2( 4 * 8) +\n    (bytes[ 5] as nat) * pow2( 5 * 8) +\n    (bytes[ 6] as nat) * pow2( 6 * 8) +\n    (bytes[ 7] as nat) * pow2( 7 * 8) +\n    (bytes[ 8] as nat) * pow2( 8 * 8) +\n    (bytes[ 9] as nat) * pow2( 9 * 8) +\n    (bytes[10] as nat) * pow2(10 * 8) +\n    (bytes[11] as nat) * pow2(11 * 8) +\n    (bytes[12] as nat) * pow2(12 * 8) +\n    (bytes[13] as nat) * pow2(13 * 8) +\n    (bytes[14] as nat) * pow2(14 * 8) +\n    (bytes[15] as nat) * pow2(15 * 8) +\n    (bytes[16] as nat) * pow2(16 * 8) +\n    (bytes[17] as nat) * pow2(17 * 8) +\n    (bytes[18] as nat) * pow2(18 * 8) +\n    (bytes[19] as nat) * pow2(19 * 8) +\n    (bytes[20] as nat) * pow2(20 * 8) +\n    (bytes[21] as nat) * pow2(21 * 8) +\n    (bytes[22] as nat) * pow2(22 * 8) +\n    (bytes[23] as nat) * pow2(23 * 8) +\n    (bytes[24] as nat) * pow2(24 * 8) +\n    (bytes[25] as nat) * pow2(25 * 8) +\n    (bytes[26] as nat) * pow2(26 * 8) +\n    (bytes[27] as nat) * pow2(27 * 8) +\n    (bytes[28] as nat) * pow2(28 * 8) +\n    (bytes[29] as nat) * pow2(29 * 8) +\n    (bytes[30] as nat) * pow2(30 * 8) +\n    (bytes[31] as nat) * pow2(31 * 8)\n},"Convert a 32-byte array to its natural number representation (little-endian).\n\nThis function interprets a byte array as a 256-bit little-endian integer:\nbytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ... + bytes[31] * 2^248\n\nIMPORTANT: This explicit 32-term form is kept for SMT solver efficiency.\nFor generic arrays, use `bytes_seq_as_nat(bytes@)` directly.","sum_i b[i] * 2^(8i), little-endian 256-bit",Interprets a 32-byte little-endian array as a natural number.
bytes_seq_as_nat,curve25519-dalek/src/specs/core_specs.rs,118,"pub open spec fn bytes_seq_as_nat(bytes: Seq<u8>) -> nat\n    decreases bytes.len(),\n{\n    if bytes.len() == 0 {\n        0\n    } else {\n        (bytes[0] as nat) + pow2(8) * bytes_seq_as_nat(bytes.skip(1))\n    }\n}",Little-endian natural value of an arbitrary-length byte sequence.\nComputes: bytes[0] + bytes[1] * 2^8 + bytes[2] * 2^16 + ...,"sum_i b[i] * 2^(8i), variable-length",Interprets a sequence of bytes as a natural number in little-endian order.
compressed_edwards_y_corresponds_to_edwards,curve25519-dalek/src/specs/edwards_specs.rs,480,"pub open spec fn compressed_edwards_y_corresponds_to_edwards(\n    compressed: CompressedEdwardsY,\n    point: EdwardsPoint,\n) -> bool {\n    let (x_affine, y_affine) = edwards_point_as_affine(point);\n    // The y-coordinate in the compressed form matches the affine y-coordinate\n    field_element_from_bytes(&compressed.0)\n        == y_affine\n    // The sign bit matches the sign of the affine x-coordinate\n     && (compressed.0[31] >> 7) == (((x_affine % crate::specs::field_specs_u64::p()) % 2) as u8)\n}",Spec function: check if a CompressedEdwardsY corresponds to an EdwardsPoint\nThe compressed form should match the affine y-coordinate and x sign bit,"Compressed(y,sign) matches (X:Y:Z:T) in E(F_p)",Relates a `CompressedEdwardsY` encoding to an `EdwardsPoint` (y-coordinate matches; sign bit matches x).
compressed_y_has_valid_sign_bit,curve25519-dalek/src/specs/edwards_specs.rs,503,"pub open spec fn compressed_y_has_valid_sign_bit(bytes: &[u8; 32]) -> bool {\n    let y = field_element_from_bytes(bytes);\n    let sign_bit = bytes[31] >> 7;\n    // If y² ≡ 1 (mod p), then x = 0, so sign_bit must be 0\n    // Equivalently: sign_bit == 1 implies y² ≢ 1\n    field_square(y) == 1 ==> sign_bit == 0\n}","Check if a CompressedEdwardsY has a valid sign bit.\n\n## Mathematical basis\n\nFor points with x = 0 on the Edwards curve, the curve equation gives y² = 1,\nso y = ±1. These special points (the identity (0,1) and the point (0,-1))\nhave only one valid sign bit: 0, since sign_bit = x % 2 = 0.\n\n## Definition\n\nIf the Y coordinate yields x = 0 (i.e., y² ≡ 1 mod p), the sign bit must be 0.",y^2 = 1 mod p => sign_bit = 0,Predicate capturing when the sign bit in a compressed Edwards-Y encoding is valid for decoding.
edwards_add,curve25519-dalek/src/specs/edwards_specs.rs,706,"pub open spec fn edwards_add(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n    let x1x2 = field_mul(x1, x2);\n    let y1y2 = field_mul(y1, y2);\n    let x1y2 = field_mul(x1, y2);\n    let y1x2 = field_mul(y1, x2);\n    let t = field_mul(d, field_mul(x1x2, y1y2));\n    let denom_x = field_add(1, t);\n    let denom_y = field_sub(1, t);\n    let x3 = field_mul(field_add(x1y2, y1x2), field_inv(denom_x));\n    let y3 = field_mul(field_add(y1y2, x1x2), field_inv(denom_y));\n    (x3, y3)\n}","Affine Edwards addition for a = -1 twisted Edwards curves (Ed25519).\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) + (x2,y2).\nFormulas:\nx3 = (x1*y2 + y1*x2) / (1 + d*x1*x2*y1*y2)\ny3 = (y1*y2 + x1*x2) / (1 - d*x1*x2*y1*y2)\n\nThese are the unified addition formulas for twisted Edwards curves with a = -1.\nReference: [BBJLP2008] Section 3.1, [RFC8032] Section 5.1.4","(x1,y1) + (x2,y2) on -x^2+y^2=1+dx^2y^2",Adds two affine Edwards points (group law).
edwards_double,curve25519-dalek/src/specs/edwards_specs.rs,721,"pub open spec fn edwards_double(x: nat, y: nat) -> (nat, nat) {\n    edwards_add(x, y, x, y)\n}",Affine Edwards doubling defined as addition with itself.,2P = P + P on twisted Edwards,Affine Edwards doubling defined as addition with itself.
edwards_neg,curve25519-dalek/src/specs/edwards_specs.rs,749,"pub open spec fn edwards_neg(point: (nat, nat)) -> (nat, nat) {\n    (field_neg(point.0), point.1)\n}","Affine Edwards negation for twisted Edwards curves with a=-1.\nThe negation of point (x, y) is (-x, y).","(x,y) -> (-x,y) on twisted Edwards",Negates an affine Edwards point (group inverse).
edwards_point_as_affine,curve25519-dalek/src/specs/edwards_specs.rs,394,"pub open spec fn edwards_point_as_affine(point: crate::edwards::EdwardsPoint) -> (nat, nat) {\n    let (x, y, z, _t) = spec_edwards_point(point);\n    let z_inv = field_inv(z);\n    (field_mul(x, z_inv), field_mul(y, z_inv))\n}","Returns the abstract affine coordinates (x, y) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) represents affine point (X/Z, Y/Z).","(X:Y:Z:T) -> (X/Z, Y/Z) in F_p x F_p",Converts an extended/projective Edwards point representation to affine coordinates.
edwards_point_limbs_bounded,curve25519-dalek/src/specs/edwards_specs.rs,366,"pub open spec fn edwards_point_limbs_bounded(point: crate::edwards::EdwardsPoint) -> bool {\n    fe51_limbs_bounded(&point.X, 52) && fe51_limbs_bounded(&point.Y, 52) && fe51_limbs_bounded(\n        &point.Z,\n        52,\n    ) && fe51_limbs_bounded(&point.T, 52)\n}",EdwardsPoint invariant: all coordinate limbs must be 52-bounded.,"all limbs of (X,Y,Z,T) < 2^52",EdwardsPoint invariant: all coordinate limbs must be 52-bounded.
edwards_scalar_mul,curve25519-dalek/src/specs/edwards_specs.rs,831,"pub open spec fn edwards_scalar_mul(point_affine: (nat, nat), n: nat) -> (nat, nat)\n    decreases n,\n{\n    if n == 0 {\n        math_edwards_identity()  // (0, 1)\n\n    } else if n == 1 {\n        point_affine\n    } else if n % 2 == 0 {\n        let half = edwards_scalar_mul(point_affine, (n / 2) as nat);\n        edwards_double(half.0, half.1)\n    } else {\n        let prev = edwards_scalar_mul(point_affine, (n - 1) as nat);\n        edwards_add(prev.0, prev.1, point_affine.0, point_affine.1)\n    }\n}","Scalar multiplication on Edwards curve points (affine coordinates).\n\nUses double-and-add instead of linear recursion to closer match the implementation of mul_by_pow_2\n\n- **Linear**: `n*P = (n-1)*P + P` — reveal gives `add(scalar_mul(P, n-1), P)`\n- **Double-and-add**: even n → `double(scalar_mul(P, n/2))`",[n]P via double-and-add on E(F_p),Computes scalar multiplication of an affine Edwards point by a natural number.
edwards_sub,curve25519-dalek/src/specs/edwards_specs.rs,757,"pub open spec fn edwards_sub(x1: nat, y1: nat, x2: nat, y2: nat) -> (nat, nat) {\n    edwards_add(x1, y1, field_neg(x2), y2)\n}","Affine Edwards subtraction for twisted Edwards curves.\nGiven (x1,y1) and (x2,y2) on the curve, returns (x3,y3) = (x1,y1) - (x2,y2).\nSubtraction is defined as addition with the negation of the second point.\nFor twisted Edwards curves, the negation of (x, y) is (-x, y).","(x1,y1) - (x2,y2) = (x1,y1) + (-x2,y2)",Subtracts two affine Edwards points.
fe51_limbs_bounded,curve25519-dalek/src/specs/field_specs.rs,27,"pub open spec fn fe51_limbs_bounded(fe: &FieldElement51, bit_limit: u64) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe.limbs[i] < (1u64 << bit_limit)\n}",Spec predicate: all limbs are bounded by a given bit limit,forall i in [0..5). limb[i] < 2^b,Checks that a field element’s radix-2^51 limbs are within the given bound.
group_order,curve25519-dalek/src/specs/scalar52_specs.rs,69,pub open spec fn group_order() -> nat {\n    pow2(252) + 27742317777372353535851937790883648493nat\n},,L = 2^252 + 27742317777372353535851937790883648493,Returns the Curve25519/Ed25519 scalar field modulus (group order).
is_canonical_scalar,curve25519-dalek/src/specs/scalar_specs.rs,30,pub open spec fn is_canonical_scalar(s: &Scalar) -> bool {\n    // Invariant #2: Scalar is reduced (< group order)\n    u8_32_as_nat(&s.bytes)\n        < group_order()\n    // Invariant #1: High bit is clear (< 2^255)\n     && s.bytes[31] <= 127\n},"Checks if a Scalar satisfies the canonical representation invariants:\n- Invariant #1: High bit (bit 255) is clear, ensuring s < 2^255\n- Invariant #2: Scalar is reduced modulo group order, i.e., s < ℓ",0 <= s < L and s < 2^255,Predicate that a `Scalar` is in canonical form (reduced modulo the group order).
is_clamped_integer,curve25519-dalek/src/specs/scalar_specs.rs,90,"pub open spec fn is_clamped_integer(bytes: &[u8; 32]) -> bool {\n    // The 3 least significant bits are cleared (divisible by 8)\n    bytes[0] & 0b0000_0111\n        == 0\n    // Bit 255 (MSB) is cleared, making it < 2^255\n     && bytes[31] & 0b1000_0000 == 0\n    // Bit 254 is set, so result >= 2^254\n     && bytes[31] & 0b0100_0000\n        == 0b0100_0000\n    // MSB cleared implies bytes[31] <= 127 (needed for mul_req precondition)\n     && bytes[31] <= 127\n}","Returns true iff a byte array represents a clamped integer for X25519.\nA clamped integer has:\n- The 3 least significant bits cleared (divisible by 8)\n- Bit 255 (MSB) cleared (< 2^255), which means bytes[31] <= 127\n- Bit 254 set (>= 2^254)\nThis creates values in range: 2^254 + 8*{0, 1, 2, ..., 2^251 - 1}","bits 0-2 clear, bit 254 set, bit 255 clear",Checks that a 32-byte array satisfies X25519 clamping (bit constraints).
is_equal_to_minus_one,curve25519-dalek/src/specs/montgomery_specs.rs,258,"pub open spec fn is_equal_to_minus_one(u: nat) -> bool {\n    u == field_sub(0, 1)  // u == -1\n\n}",Check if a Montgomery u-coordinate is invalid for conversion to Edwards\nu = -1 is invalid because it corresponds to a point on the twist,u = p - 1 (i.e. u = -1 mod p),Checks whether a field element equals -1 modulo the prime field.
is_identity_edwards_point,curve25519-dalek/src/specs/edwards_specs.rs,324,pub open spec fn is_identity_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n\n    z != 0 && x == 0 && y == z\n},"Check if an EdwardsPoint represents the identity point\nThe identity point is (0, 1) in affine coordinates\nIn projective coordinates (X:Y:Z:T), this means X/Z = 0 and Y/Z = 1\nWhich is equivalent to X ≡ 0 (mod p) and Y ≡ Z (mod p) with Z ≠ 0","X = 0, Y = Z, Z != 0 (projective identity)",Checks whether an Edwards point is the identity (neutral element).
is_in_even_subgroup,curve25519-dalek/src/specs/ristretto_specs.rs,346,"pub open spec fn is_in_even_subgroup(point: EdwardsPoint) -> bool {\n    exists|q: EdwardsPoint|\n        edwards_point_as_affine(point) == edwards_scalar_mul(\n            #[trigger] edwards_point_as_affine(q),\n            2,\n        )\n}",Point is in the even subgroup 2E = {2Q : Q ∈ E}; valid Ristretto points must lie in 2E.,P in 2E = {2Q : Q in E(F_p)},Predicate that an Edwards point lies in the even (torsion-free) subgroup used by Ristretto decoding.
is_valid_edwards_point,curve25519-dalek/src/specs/edwards_specs.rs,356,"pub open spec fn is_valid_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n    let t = fe51_as_canonical_nat(&point.T);\n\n    math_is_valid_extended_edwards_point(x, y, z, t)\n}",Check if an EdwardsPoint in extended coordinates is valid\nAn EdwardsPoint (X:Y:Z:T) is valid if:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T\n\nExtended coordinates (X:Y:Z:T) with X·Y = Z·T enable faster point arithmetic.\nReference: [HWCD2008] Section 3 for extended twisted Edwards coordinates,(X:Y:Z:T) satisfies curve eq + XY = ZT,Checks that an Edwards point satisfies the curve equation (mathematically valid).
is_well_formed_edwards_point,curve25519-dalek/src/specs/edwards_specs.rs,374,"pub open spec fn is_well_formed_edwards_point(point: crate::edwards::EdwardsPoint) -> bool {\n    is_valid_edwards_point(point) && edwards_point_limbs_bounded(point) && sum_of_limbs_bounded(\n        &point.Y,\n        &point.X,\n        u64::MAX,\n    )\n}",A well-formed EdwardsPoint: mathematically valid and properly bounded.,valid on curve + limbs bounded,Stronger validity predicate: point is valid and its internal representation satisfies required bounds.
math_edwards_identity,curve25519-dalek/src/specs/edwards_specs.rs,311,"pub open spec fn math_edwards_identity() -> (nat, nat) {\n    (0, 1)\n}","The identity point in affine coordinates (0, 1)","O = (0, 1) in affine coordinates",The affine identity point of the Edwards group.
field_add,curve25519-dalek/src/specs/field_specs.rs,110,"pub open spec fn field_add(a: nat, b: nat) -> nat {\n    (a + b) % p()\n}",Math-level field addition,"(a + b) mod p, p = 2^255-19",Math-level field addition
field_inv,curve25519-dalek/src/specs/field_specs.rs,141,"pub open spec fn field_inv(a: nat) -> nat {\n    if a % p() == 0 {\n        0  // Convention: inverse of 0 is defined as 0\n\n    } else {\n        spec_mod_inverse(a, p())\n    }\n}","Math-level field inversion: returns w such that (a * w) % p == 1\n\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\n\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\nwhich relies on p being prime.","a^(-1) mod p, p = 2^255-19","Math-level field inversion: returns w such that (a * w) % p == 1\n\nFor non-zero elements (a % p() != 0), this returns the unique multiplicative\ninverse modulo p. By convention, when a % p() == 0, this returns 0.\n\nThe existence of inverses for non-zero elements is guaranteed by field_inv_property,\nwhich relies on p being prime."
field_mul,curve25519-dalek/src/specs/field_specs.rs,120,"pub open spec fn field_mul(a: nat, b: nat) -> nat {\n    (a * b) % p()\n}",Math-level field multiplication,"(a * b) mod p, p = 2^255-19",Math-level field multiplication
field_neg,curve25519-dalek/src/specs/field_specs.rs,125,pub open spec fn field_neg(a: nat) -> nat {\n    (p() - (a % p())) as nat % p()\n},Math-level field negation,"-a mod p, p = 2^255-19",Math-level field negation
field_square,curve25519-dalek/src/specs/field_specs.rs,130,pub open spec fn field_square(a: nat) -> nat {\n    (a * a) % p()\n},Math-level field squaring,"a^2 mod p, p = 2^255-19",Math-level field squaring
field_sub,curve25519-dalek/src/specs/field_specs.rs,115,"pub open spec fn field_sub(a: nat, b: nat) -> nat {\n    (((a % p()) + p()) - (b % p())) as nat % p()\n}",Math-level field subtraction,"(a - b) mod p, p = 2^255-19",Math-level field subtraction
nat_invsqrt,curve25519-dalek/src/specs/field_specs.rs,510,"pub open spec fn nat_invsqrt(a: nat) -> nat {\n    if a % p() == 0 {\n        0\n    } else {\n        choose|r: nat|\n            #![auto]\n            !is_negative(r) && (is_sqrt_ratio(1, a, r) || is_sqrt_ratio_times_i(\n                1,\n                a,\n                r,\n            ))\n    }\n}",Spec-only model of inverse square root with a canonical sign choice.\n\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).,1/sqrt(a) mod p (canonical sign),Spec-only model of inverse square root with a canonical sign choice.\n\nReturns a nonnegative r such that either r^2 * a = 1 (mod p) or r^2 * a = i (mod p).
is_negative,curve25519-dalek/src/specs/field_specs.rs,503,pub open spec fn is_negative(a: nat) -> bool {\n    (a % p()) % 2 == 1\n},Spec predicate: a field element is negative if its canonical low bit is 1.,a mod p is odd (sign convention),Spec predicate: a field element is negative if its canonical low bit is 1.
is_sqrt_ratio,curve25519-dalek/src/specs/field_specs.rs,491,"pub open spec fn is_sqrt_ratio(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == u\n}",Spec function: r² * v = u (mod p) — math version operating on nat values\nThis is the mathematical equivalent of fe51_is_sqrt_ratio but without FieldElement wrappers.\nUse this when working with mathematical values directly in lemmas.,r^2 * v = u (mod p),Spec function: r² * v = u (mod p) — math version operating on nat values\nThis is the mathematical equivalent of fe51_is_sqrt_ratio but without FieldElement wrappers.\nUse this when working with mathematical values directly in lemmas.
is_sqrt_ratio_times_i,curve25519-dalek/src/specs/field_specs.rs,498,"pub open spec fn is_sqrt_ratio_times_i(u: nat, v: nat, r: nat) -> bool {\n    (r * r * v) % p() == (sqrt_m1() * u) % p()\n}",Spec function: r² * v = i*u (mod p) — math version operating on nat values\nUsed for the nonsquare case in sqrt_ratio_i.\nThis is the mathematical equivalent of fe51_is_sqrt_ratio_times_i.,"r^2 * v = i*u (mod p), i = sqrt(-1)",Spec function: r² * v = i*u (mod p) — math version operating on nat values\nUsed for the nonsquare case in sqrt_ratio_i.\nThis is the mathematical equivalent of fe51_is_sqrt_ratio_times_i.
math_is_valid_extended_edwards_point,curve25519-dalek/src/specs/edwards_specs.rs,341,"pub open spec fn math_is_valid_extended_edwards_point(x: nat, y: nat, z: nat, t: nat) -> bool {\n    z != 0 && math_on_edwards_curve_projective(x, y, z) && field_mul(x, y) == field_mul(\n        z,\n        t,\n    )\n}","Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\n\nThis is the ""unpacked"" version of `is_valid_edwards_point` that operates directly on the\nmathematical values `(x, y, z, t)` (all reduced mod p via `field_*`).\n\nAn (X:Y:Z:T) tuple is valid iff:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T","Z != 0, curve eq holds, XY = ZT","Math-level validity predicate for an Edwards point in **extended coordinates** (X:Y:Z:T).\n\nThis is the ""unpacked"" version of `is_valid_edwards_point` that operates directly on the\nmathematical values `(x, y, z, t)` (all reduced mod p via `field_*`).\n\nAn (X:Y:Z:T) tuple is valid iff:\n1. Z ≠ 0\n2. The projective curve equation holds: (Y² - X²)·Z² = Z⁴ + d·X²·Y²\n3. The Segre relation holds: X·Y = Z·T"
math_is_valid_y_coordinate,curve25519-dalek/src/specs/edwards_specs.rs,285,"pub open spec fn math_is_valid_y_coordinate(y: nat) -> bool {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n    let y2 = field_square(y);\n\n    // Compute u = y² - 1\n    let u = field_sub(y2, 1);\n\n    // Compute v = d·y² + 1\n    let v = field_add(field_mul(d, y2), 1);\n\n    if u % p() == 0 {\n        // If u = 0, then y² = 1, so y = ±1, which gives valid points (x=0, y=±1)\n        true\n    } else if v % p() == 0 {\n        // If v = 0 but u ≠ 0, division by zero case - invalid\n        false\n    } else {\n        // Check if there exists r such that r² * v ≡ ±u (mod p)\n        // This is what sqrt_ratio_i determines\n        exists|r: nat|\n            r < p() && (#[trigger] field_mul(field_square(r), v) == u % p()\n                || #[trigger] field_mul(field_square(r), v) == field_neg(u))\n    }\n}","Spec function: Check if a y-coordinate corresponds to a valid point on the curve.\nMirrors the sqrt_ratio_i computation from field.rs to determine if u/v is a square.\nFrom the curve equation: x² = (y² - 1) / (d·y² + 1)\nThis computes the same check as sqrt_ratio_i(&u, &v) where:\nu = y² - 1\nv = d·y² + 1\nReturns true if u/v is a square (i.e., x can be recovered)","exists x. (x, y) in E(F_p)",Checks whether a field element can be a y-coordinate of some Edwards curve point.
math_on_edwards_curve_projective,curve25519-dalek/src/specs/edwards_specs.rs,260,"pub open spec fn math_on_edwards_curve_projective(x: nat, y: nat, z: nat) -> bool {\n    let d = fe51_as_canonical_nat(&EDWARDS_D);\n\n    // Compute X², Y², Z²\n    let x2 = field_square(x);\n    let y2 = field_square(y);\n    let z2 = field_square(z);\n    let z4 = field_square(z2);\n\n    // LHS: (-X² + Y²)·Z² = (Y² - X²)·Z²\n    let lhs = field_mul(field_sub(y2, x2), z2);\n\n    // RHS: Z⁴ + d·X²·Y²\n    let rhs = field_add(z4, field_mul(d, field_mul(x2, y2)));\n\n    lhs == rhs\n}","Homogenized Edwards curve equation for projective coordinates\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\nThis is equivalent to the affine equation when Z ≠ 0\n\nReference: [BBJLP2008] Section 3",(Y^2 - X^2)Z^2 = Z^4 + dX^2Y^2,"Homogenized Edwards curve equation for projective coordinates\nA projective point (X:Y:Z) represents the affine point (X/Z, Y/Z)\nThe homogenized curve equation is: (-X² + Y²)·Z² = Z⁴ + d·X²·Y²\nThis is equivalent to the affine equation when Z ≠ 0\n\nReference: [BBJLP2008] Section 3"
montgomery_corresponds_to_edwards,curve25519-dalek/src/specs/montgomery_specs.rs,213,"pub open spec fn montgomery_corresponds_to_edwards(\n    montgomery: crate::montgomery::MontgomeryPoint,\n    edwards: crate::edwards::EdwardsPoint,\n) -> bool {\n    let u = spec_montgomery(montgomery);\n    let (x, y) = crate::specs::edwards_specs::edwards_point_as_affine(edwards);\n    let denominator = field_sub(1, y);\n\n    if denominator == 0 {\n        // Special case: Edwards identity (x=0, y=1) maps to Montgomery u=0\n        u == 0\n    } else {\n        // General case: u = (1+y)/(1-y)\n        let numerator = field_add(1, y);\n        u == field_mul(numerator, field_inv(denominator))\n    }\n}",Check if a MontgomeryPoint corresponds to an EdwardsPoint\nvia the birational map u = (1+y)/(1-y)\nSpecial case: Edwards identity (y=1) maps to u=0,"u = (1+y)/(1-y), birational map",Relates a Montgomery u-coordinate representation to an Edwards point under the standard birational map.
p,curve25519-dalek/src/specs/field_specs_u64.rs,11,pub open spec fn p() -> nat {\n    (pow2(255) - 19) as nat\n},,p = 2^255 - 19 (Curve25519 prime),
scalar_as_nat,curve25519-dalek/src/specs/scalar_specs.rs,17,pub open spec fn scalar_as_nat(s: &Scalar) -> nat {\n    u8_32_as_nat(&s.bytes)\n},,LE(s.bytes) -> nat,Interprets a `Scalar`’s canonical byte encoding as a natural number.
u8_32_from_nat,curve25519-dalek/src/specs/field_specs.rs,525,pub open spec fn u8_32_from_nat(n: nat) -> [u8; 32] {\n    choose|b: [u8; 32]| u8_32_as_nat(&b) == n % pow2(256)\n},Canonical little-endian bytes for a nat (mod 2^256).,n mod 2^256 -> [u8;32] little-endian,Canonical little-endian bytes for a nat (mod 2^256).
spec_clamp_integer,curve25519-dalek/src/specs/scalar_specs.rs,112,"pub open spec fn spec_clamp_integer(bytes: [u8; 32]) -> [u8; 32] {\n    // Build the result array element by element\n    [\n        bytes[0] & 0b1111_1000,  // Clear low 3 bits of byte 0\n        bytes[1],\n        bytes[2],\n        bytes[3],\n        bytes[4],\n        bytes[5],\n        bytes[6],\n        bytes[7],\n        bytes[8],\n        bytes[9],\n        bytes[10],\n        bytes[11],\n        bytes[12],\n        bytes[13],\n        bytes[14],\n        bytes[15],\n        bytes[16],\n        bytes[17],\n        bytes[18],\n        bytes[19],\n        bytes[20],\n        bytes[21],\n        bytes[22],\n        bytes[23],\n        bytes[24],\n        bytes[25],\n        bytes[26],\n        bytes[27],\n        bytes[28],\n        bytes[29],\n        bytes[30],\n        (bytes[31] & 0b0111_1111) | 0b0100_0000,  // Clear bit 7 and set bit 6 of byte 31\n    ]\n}","Spec function for clamping a byte array to produce a valid X25519 scalar.\nThis is the spec-level version of the `clamp_integer` exec function.\n\nThe clamping operation:\n- Clears the 3 least significant bits (bits 0-2 of byte 0)\n- Clears bit 255 (bit 7 of byte 31)\n- Sets bit 6 of byte 31)\n\nThis produces a value in the range [2^254, 2^255) that is divisible by 8.","clamp: clear bits 0-2 and 255, set bit 254",Specification function computing the clamped 32-byte scalar used in X25519.
spec_ed25519_basepoint,curve25519-dalek/src/specs/edwards_specs.rs,75,"pub open spec fn spec_ed25519_basepoint() -> (nat, nat) {\n    (u64_5_as_nat(ED25519_BASEPOINT_POINT.X.limbs), u64_5_as_nat(ED25519_BASEPOINT_POINT.Y.limbs))\n}","The Ed25519 basepoint B in affine coordinates (x, y).\nThis is the generator point of the prime-order subgroup.\n\nReferences the actual constant ED25519_BASEPOINT_POINT from constants.rs.\nThe y-coordinate is 4/5 mod p (the first 255 bits of the compressed form).\nThe x-coordinate is the positive square root satisfying the curve equation.\n\nReference: [RFC8032] Section 5.1","B = (x_B, y_B), Ed25519 generator",Returns the Ed25519 basepoint in affine coordinates (spec-level).
spec_edwards_point,curve25519-dalek/src/specs/edwards_specs.rs,384,"pub open spec fn spec_edwards_point(point: crate::edwards::EdwardsPoint) -> (nat, nat, nat, nat) {\n    let x = fe51_as_canonical_nat(&point.X);\n    let y = fe51_as_canonical_nat(&point.Y);\n    let z = fe51_as_canonical_nat(&point.Z);\n    let t = fe51_as_canonical_nat(&point.T);\n    (x, y, z, t)\n}","Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates.","(X, Y, Z, T) field values of extended point","Returns the field element values (X, Y, Z, T) from an EdwardsPoint.\nAn EdwardsPoint (X:Y:Z:T) is in extended projective coordinates."
spec_extended_gcd,curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs,908,"pub open spec fn spec_extended_gcd(a: nat, b: nat) -> ExtGcdResult\n    decreases b,\n{\n    if b == 0 {\n        ExtGcdResult { gcd: a, x: 1, y: 0 }\n    } else {\n        let r = spec_extended_gcd(b, a % b);\n        ExtGcdResult { gcd: r.gcd, x: r.y, y: r.x - (a / b) as int * r.y }\n    }\n}","Spec function: Extended Euclidean Algorithm\n\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\n\nThis is a constructive algorithm that produces the Bezout coefficients.\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\n= a*y' + b*(x' - (a/b)*y')\nso (gcd, y', x' - (a/b)*y')","gcd(a,b) = ax + by (Bezout coefficients)","Spec function: Extended Euclidean Algorithm\n\nComputes (gcd, x, y) such that gcd(a, b) = a*x + b*y (Bezout's identity)\n\nThis is a constructive algorithm that produces the Bezout coefficients.\nBase case: gcd(a, 0) = a = a*1 + 0*0, so (a, 1, 0)\nRecursive case: if gcd(b, a%b) = b*x' + (a%b)*y' = b*x' + (a - b*(a/b))*y'\n= a*y' + b*(x' - (a/b)*y')\nso (gcd, y', x' - (a/b)*y')"
fe51_as_canonical_nat,curve25519-dalek/src/specs/field_specs.rs,75,pub open spec fn fe51_as_canonical_nat(fe: &FieldElement51) -> nat {\n    fe51_as_nat(fe) % p()\n},"Returns the canonical mathematical value of a field element in [0, p)\nwhere p = 2^255 - 19","fe -> fe mod p, canonical in [0, p)",Interprets a field element value as an integer modulo the prime p.
fe51_as_nat,curve25519-dalek/src/specs/field_specs.rs,69,pub open spec fn fe51_as_nat(fe: &FieldElement51) -> nat {\n    u64_5_as_nat(fe.limbs)\n},,sum_i limb[i] * 2^(51i),
field_element_from_bytes,curve25519-dalek/src/specs/field_specs.rs,98,pub open spec fn field_element_from_bytes(bytes: &[u8; 32]) -> nat {\n    (u8_32_as_nat(bytes) % pow2(255)) % p()\n},"Returns the canonical mathematical value when creating a field element from bytes.\nThe bytes are interpreted as a little-endian integer with the high bit of byte[31] ignored.\nThe result is the canonical value in [0, p) where p = 2^255 - 19.",LE(b) mod 2^255 mod p,Interprets 32 bytes as a field element (spec-level decoding).
fe51_as_canonical_nat_sign_bit,curve25519-dalek/src/specs/field_specs.rs,104,pub open spec fn fe51_as_canonical_nat_sign_bit(fe: &FieldElement51) -> u8 {\n    ((fe51_as_canonical_nat(fe) % p()) % 2) as u8\n},"Spec function: Get the sign bit of a field element\nIn Curve25519, the sign bit is the least significant bit of the canonical representation",(fe mod p) mod 2 (parity bit),Returns the sign bit used in point compression (typically the parity of x).
spec_gcd,curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs,27,"pub open spec fn spec_gcd(a: nat, b: nat) -> nat\n    decreases b,\n{\n    if b == 0 {\n        a\n    } else {\n        spec_gcd(b, a % b)\n    }\n}","Spec function: Greatest Common Divisor using Euclidean algorithm\n\nThis is a constructive definition that computes gcd(a, b) recursively.\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0","gcd(a, b) via Euclidean algorithm","Spec function: Greatest Common Divisor using Euclidean algorithm\n\nThis is a constructive definition that computes gcd(a, b) recursively.\nThe algorithm is: gcd(a, 0) = a; gcd(a, b) = gcd(b, a % b) for b > 0"
spec_mod_inverse,curve25519-dalek/src/lemmas/common_lemmas/number_theory_lemmas.rs,980,"pub open spec fn spec_mod_inverse(a: nat, m: nat) -> nat\n    recommends\n        m > 1,\n        spec_gcd(a % m, m) == 1,\n{\n    if m <= 1 || spec_gcd(a % m, m) != 1 {\n        0  // Undefined case - return 0 by convention\n\n    } else {\n        let r = spec_extended_gcd(a % m, m);\n        // r.x might be negative, so normalize to [0, m)\n        (((r.x % (m as int)) + (m as int)) % (m as int)) as nat\n    }\n}","Spec function: Compute modular inverse using extended Euclidean algorithm\n\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\na * x ≡ 1 (mod m).\n\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\nTaking mod m: (a*x) % m = 1\n\nWe normalize the result to be in [0, m) by computing x % m (handling negative x).","a^(-1) mod m, via extended GCD","Spec function: Compute modular inverse using extended Euclidean algorithm\n\nFor a and m coprime (gcd(a, m) = 1), returns the unique x in [0, m) such that\na * x ≡ 1 (mod m).\n\nThe inverse is computed from Bezout's identity: a*x + m*y = 1\nTaking mod m: (a*x) % m = 1\n\nWe normalize the result to be in [0, m) by computing x % m (handling negative x)."
spec_montgomery,curve25519-dalek/src/specs/montgomery_specs.rs,206,pub open spec fn spec_montgomery(point: crate::montgomery::MontgomeryPoint) -> nat {\n    field_element_from_bytes(&point.0)\n},Returns the u-coordinate of a Montgomery point as a field element\nMontgomery points only store the u-coordinate; sign information is lost,MontgomeryPoint -> u in F_p,Interprets a `MontgomeryPoint` as a field element u-coordinate (spec-level).
spec_ristretto_basepoint,curve25519-dalek/src/specs/ristretto_specs.rs,194,"pub open spec fn spec_ristretto_basepoint() -> (nat, nat) {\n    spec_ed25519_basepoint()\n}",The canonical representative of the Ristretto basepoint.\n\nThe Ristretto basepoint is the equivalence class [B] where B is the\nEd25519 basepoint. We use B itself as the canonical representative.,[B] (Ristretto basepoint = Ed25519 B),Returns the Ristretto basepoint (spec-level).
spec_ristretto_compress,curve25519-dalek/src/specs/ristretto_specs.rs,113,"pub open spec fn spec_ristretto_compress(point: RistrettoPoint) -> [u8; 32] {\n    let (x, y, z, t) = spec_edwards_point(point.0);\n    spec_ristretto_compress_extended(x, y, z, t)\n}","Spec-only model of Ristretto compression from a RistrettoPoint.\n\nThis captures the canonical encoding of a Ristretto point.\nReference: [RISTRETTO], §5.3 ""Ristretto255 Encoding""","E/~ -> [u8;32], Ristretto encoding",Spec-level function computing the canonical compressed encoding of a Ristretto point.
spec_ristretto_compress_extended,curve25519-dalek/src/specs/ristretto_specs.rs,61,"pub open spec fn spec_ristretto_compress_extended(x: nat, y: nat, z: nat, t: nat) -> [u8; 32] {\n    let u1 = field_mul(field_add(z, y), field_sub(z, y));\n    let u2 = field_mul(x, y);\n    let invsqrt = nat_invsqrt(field_mul(u1, field_square(u2)));\n    let i1 = field_mul(invsqrt, u1);\n    let i2 = field_mul(invsqrt, u2);\n    let z_inv = field_mul(i1, field_mul(i2, t));\n    let den_inv = i2;\n\n    let iX = field_mul(x, sqrt_m1());\n    let iY = field_mul(y, sqrt_m1());\n    let enchanted_denominator = field_mul(\n        i1,\n        fe51_as_canonical_nat(&u64_constants::INVSQRT_A_MINUS_D),\n    );\n\n    let rotate = is_negative(field_mul(t, z_inv));\n    let x_rot = if rotate {\n        iY\n    } else {\n        x\n    };\n    let y_rot = if rotate {\n        iX\n    } else {\n        y\n    };\n    let den_inv_rot = if rotate {\n        enchanted_denominator\n    } else {\n        den_inv\n    };\n\n    let y_final = if is_negative(field_mul(x_rot, z_inv)) {\n        field_neg(y_rot)\n    } else {\n        y_rot\n    };\n    let s = field_mul(den_inv_rot, field_sub(z, y_final));\n    let s_final = if is_negative(s) {\n        field_neg(s)\n    } else {\n        s\n    };\n\n    u8_32_from_nat(s_final)\n}","Core Ristretto compression from extended coordinates (X, Y, Z, T).\nReference: [RISTRETTO], §5.3 ""Ristretto255 Encoding"";\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html.","(X,Y,Z,T) -> [u8;32], core encoding","Core Ristretto compression from extended coordinates (X, Y, Z, T).\nReference: [RISTRETTO], §5.3 ""Ristretto255 Encoding"";\n[DECAF], Section 6 (encoding formulas), and https://ristretto.group/formulas/encoding.html."
spec_ristretto_decompress,curve25519-dalek/src/specs/ristretto_specs.rs,131,"pub open spec fn spec_ristretto_decompress(bytes: [u8; 32]) -> Option<RistrettoPoint> {\n    let s_bytes_nat = u8_32_as_nat(&bytes);\n    let s = field_element_from_bytes(&bytes);\n    let s_encoding_is_canonical = s_bytes_nat < p();\n    let s_is_negative = is_negative(s);\n\n    if !s_encoding_is_canonical || s_is_negative {\n        None\n    } else {\n        let ss = field_square(s);\n        let u1 = field_sub(1, ss);\n        let u2 = field_add(1, ss);\n        let u2_sqr = field_square(u2);\n        let neg_d = field_neg(fe51_as_canonical_nat(&EDWARDS_D));\n        let u1_sqr = field_square(u1);\n        let v = field_sub(field_mul(neg_d, u1_sqr), u2_sqr);\n\n        let invsqrt_input = field_mul(v, u2_sqr);\n        let invsqrt = nat_invsqrt(invsqrt_input);\n        let ok = is_sqrt_ratio(1, invsqrt_input, invsqrt);\n\n        let dx = field_mul(invsqrt, u2);\n        let dy = field_mul(invsqrt, field_mul(dx, v));\n        let x_tmp = field_mul(field_add(s, s), dx);\n        let x = if is_negative(x_tmp) {\n            field_neg(x_tmp)\n        } else {\n            x_tmp\n        };\n        let y = field_mul(u1, dy);\n        let t = field_mul(x, y);\n\n        let t_is_negative = is_negative(t);\n        let y_is_zero = y == 0;\n\n        if !ok || t_is_negative || y_is_zero {\n            None\n        } else if exists|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t) {\n            Some(choose|p: RistrettoPoint| #![auto] spec_edwards_point(p.0) == (x, y, 1nat, t))\n        } else {\n            None\n        }\n    }\n}","Spec-only model of Ristretto decompression.\nReference: [RISTRETTO], §5.2 ""Ristretto255 Decoding"";\n[DECAF], Section 6 (decoding formulas), and https://ristretto.group/formulas/decoding.html.","[u8;32] -> Option<E/~>, Ristretto decoding",Spec-level function decoding a compressed Ristretto encoding to an optional point.
sqrt_m1,curve25519-dalek/src/specs/field_specs.rs,584,pub open spec fn sqrt_m1() -> nat {\n    fe51_as_canonical_nat(&constants::SQRT_M1)\n},The mathematical value of SQRT_M1 (sqrt(-1) mod p)\nThis is the 4th root of unity i such that i² = -1 (mod p),i in F_p : i^2 = -1 (mod p),The mathematical value of SQRT_M1 (sqrt(-1) mod p)\nThis is the 4th root of unity i such that i² = -1 (mod p)
sum_of_limbs_bounded,curve25519-dalek/src/specs/field_specs.rs,32,"pub open spec fn sum_of_limbs_bounded(\n    fe1: &FieldElement51,\n    fe2: &FieldElement51,\n    bound: u64,\n) -> bool {\n    forall|i: int| 0 <= i < 5 ==> fe1.limbs[i] + fe2.limbs[i] < bound\n}",Spec predicate: sum of limbs are bounded by a given bit limit,forall i. limb1[i] + limb2[i] < bound,Checks that adding two field-element limb arrays stays within a safe bound (used to justify u64/u128 arithmetic).
u64_5_as_nat,curve25519-dalek/src/specs/field_specs_u64.rs,52,pub open spec fn u64_5_as_nat(limbs: [u64; 5]) -> nat {\n                (limbs[0] as nat) +\n    pow2( 51) * (limbs[1] as nat) +\n    pow2(102) * (limbs[2] as nat) +\n    pow2(153) * (limbs[3] as nat) +\n    pow2(204) * (limbs[4] as nat)\n},,"sum_i limb[i] * 2^(51i), radix-2^51",
